## Server komponentlar qoidalari

Endi server komponentlarining qanday ishlashini tushunib yetganimizdan so'ng, server komponentlari bilan ishlashda amal qilishimiz kerak bo'lgan ba'zi qoidalarni, yoki kengroq ma'noda, server komponentlar bilan ishlashda e'tiborga olishimiz kerak bo'lgan jihatlarni muhokama qilamiz.


### Serializatsiya muhim
Server komponentlar bilan ishlashda barcha props’lar seriyalanadigan bo'lishi kerak. Buning sababi shundaki, server props’larni seriyalab, ularni klientga yuborishi kerak. Avval muhokama qilganimizdek, bu jarayon props’lar funksiyalar yoki boshqa seriyalanmaydigan qiymatlar bo'lishiga yo'l qo'ymaydi. Bu esa, [5-bobda](/docs/react/powerful-patterns/render-props) ko'rib chiqqanimiz "render props" pattern’ini amalda eskirgan qilib qo'yadi.

Server komponentlari serverda render qilinib, soft navigatsiya orqali klientga yuborilish jarayonini tushungan holda, bu qoida nimaga kerakligini tushunishimiz kerak. Misol uchun, agar bizda quyidagicha server komponent bo'lsa:
``` js copy
function ServerComponent() {
  return <ClientComponent onClick={() => alert("hi")} />;
}
```

Bu xato keltirib chiqaradi. Ammo, biz bu xatoni `onClick` props’ini `ClientComponent` ichida joylashtirish orqali bartaraf etishimiz mumkin.


### Effektli hook’lardan foydalanmaslik
Server klientdan keskin farq qiladigan muhitdir. U interaktiv emas, DOM’ga ega emas va unda `window` mavjud emas. Shu sababli, effektli hook’lar server komponentlarida qo'llab-quvvatlanmaydi.

Ba'zi freymvorklar, masalan, Next.js, server komponentlarida barcha hook’larni taqiqlovchi lint qoidalariga ega, lekin bu har doim ham zarur emas. RSCs state, effektlar yoki faqat brauzerga xos API’larga bog'lanmagan hook’larni ishlatishi mumkin. Masalan, useRef hook’ini server komponentlarida ishlatish mutlaqo to'g'ri, chunki u state, effekt yoki faqat brauzerga xos API’larga bog'liq emas. Bu esa bizga komponentlar bilan xavfsizroq ishlashga imkon beradi.


### State - klient komponentidagi state emas
Server komponentlaridagi state klient komponentlaridagi state’dan farq qiladi. Chunki server komponentlar serverda, klient komponentlari esa klientda render qilinadi. Bu, server komponentlaridagi state bir nechta klientlar orasida umumiy bo'lishi mumkinligini anglatadi, chunki server va klient o'rtasidagi aloqa keng tarqaluvchi (broadcast) usulda amalga oshadi, unicast (bitta klient, bitta state) kabi emas, va shu sababli klientlar o'rtasida state’ni oshkor qilish xavfi yuqori bo'lishi mumkin.

Hook’lar qoidasini hisobga olgan holda, `useState` yoki `useReducer` kabi state’ga bog'liq komponentlar eng yaxshi klient komponentlari sifatida ishlatilishi tavsiya etiladi. 


### Klient komponentlar server komponentlarni import qilolmaydi
Klient komponentlari server komponentlarini import qila olmaydi. Buning sababi, server komponentlari faqat serverda bajariladi, ammo klient komponentlari ham serverda, ham brauzerlarda bajariladi.

Masalan, agar bizda quyidagi kabi klient komponenti bo'lsa:
``` js copy
"use client";
import { ServerComponent } from "./ServerComponent";

function ClientComponent() {
  return (
    <div>
      <h1>Hey everyone, check out my great server component!</h1>
      <ServerComponent />
    </div>
  );
}
```

bu xato keltirib chiqaradi, chunki klient komponenti server komponentini import qilishga harakat qilmoqda. Server komponentlari faqat serverda bajarilishi sababli, bu komponent Node.js API’larini import qilishi mumkin, va ular klient muhitida mavjud emas, bu esa klientda xatolarga olib keladi.

Masalan, server komponenti quyidagicha ko'rinishi mumkin:
``` js copy
import { readFile } from "node:fs/promises";

export async function ServerComponent() {
  const content = await readFile("./some-file.txt", "utf-8");
  return <div>{content}</div>;
}
```

Agar biz bu komponentni klientda ishlatishga urinib ko'rsak, `readFile` funksiyasi va `node:fs/promises` moduli brauzerda mavjud emasligi sababli xato yuzaga keladi. Shu sababdan, klient komponentlari server komponentlarini import qila olmaydi.


#### Prop orqali kompozitsiya yordamida server komponentlarini o'z ichiga olish
Ammo, klient komponentlari server komponentlarini props orqali o'z ichiga olishi mumkin. Masalan, biz klient komponentini quyidagicha qayta yozishimiz mumkin:
``` js copy
"use client";

function ClientComponent({ children }) {
  return (
    <div>
      <h1>Hey everyone, check out my great server component!</h1>
      {children}
    </div>
  );
}
```

Keyin esa, bu klient komponentini o'z ichiga olgan ota server komponentda shunday qilish mumkin:
``` js copy
import { ServerComponent } from "./ServerComponent";

async function TheParentOfBothComponents() {
  return (
    <ClientComponent>
      <ServerComponent />
    </ClientComponent>
  );
}
```

Bu ishlaydi, chunki bu yerda klient komponenti server komponentini aniq import qilmayapti; aksincha, ota server komponent server komponentni props sifatida klient komponentiga uzatmoqda. Importlar orqali cheklov qo'yilishining sababi server komponentlarini klient uchun mo'ljallangan paketda ko'rish imkoniyatini oldini olishdir, chunki bundlerlar faqat import operatorlariga e'tibor beradi, props orqali kompozitsiyaga esa emas.


### Klient komponentlari yomon emas
E’tibor berish kerakki, server komponentlari paydo bo'lguniga qadar, React’da biz faqat klient komponentlarini ishlatardik. Bu, mavjud barcha komponentlarimiz klient komponentlari ekanligini anglatadi va bu yomon emas. Klient komponentlari React ilovalarining asosi bo'lib qoladi va hali ham eng ko'p yoziladigan komponentlar hisoblanadi.

Bu yerda bu mavzuni eslatib o'tishimizning sababi, ayrimlar server komponentlarini klient komponentlariga nisbatan ustunroq deb qabul qilayotganidir. Aslida, bu noto'g'ri. Server komponentlari klient komponentlariga qo'shimcha sifatida ishlatilishi mumkin bo'lgan yangi turdagi komponentdir, lekin klient komponentlari uchun o'rinbosar emas.


### Server harakatlari (Server actions)
Server komponentlari React’da kuchli bo'lgan yangi xususiyat bo'lsa-da, ular yagona yangilik emas. RSC'lar `"use server"` deb nomlangan yangi direktiva bilan birgalikda ishlaydi, bu direktiva klient kodidan chaqirilishi mumkin bo'lgan server tomonidagi funksiyalarni belgilaydi. Biz bu funksiyalarni *server harakatlari (server actions)* deb ataymiz.

Har qanday asinxron funksiya tanasining birinchi qatorida `"use server"` ni yozish orqali, bu funksiyani klient kodidan chaqirish mumkinligini, lekin faqat serverda bajarilishi kerakligini React va bundlerga bildiradi. Agar klient tomonda server harakatini chaqirganimizda, u serverga tarmoqli so'rov yuboradi va barcha argumentlarni serializatsiya qilib uzatadi. Agar server harakati qiymat qaytarsa, bu qiymat ham serializatsiya qilinib, klientga qaytariladi.

Agar alohida funksiyalarni `"use server"` bilan belgilashni xohlamasangiz, fayl boshiga bu direktivani qo'shib, fayldagi barcha eksport qilingan funksiyalarni *server actions* sifatida belgilash mumkin. Bu holatda, ularni klient kodidan ham import qilib ishlatish mumkin bo'ladi.


### Formalar va mutatsiyalar (Forms and mutations)
[8-bobda](/docs/react/frameworks) biz Next.js va Remix qanday qilib formalar va o'zgartirishlarni (mutatsiyalarni) boshqarishi haqida gaplashgan edik. React ham bu funksiyalar uchun birinchi darajali primitivlarni qo'shmoqda (yoki allaqachon qo'shgan). Quyidagi formani ko'rib chiqaylik:
``` js copy filename="./App.js"
async function requestUsername(formData) {
  'use server';
  const username = formData.get('username');
  // ...
}

export default function App() {
  return (
    <form action={requestUsername}>
      <input type="text" name="username" />
      <button type="submit">Request</button>
    </form>
  );
}
```

Ushbu misolda, `requestUsername` formaga server harakati sifatida berilgan. Foydalanuvchi formani yuborganida, `requestUsername` server funksiyasiga tarmoqli so'rov amalga oshiriladi. Formada server harakatini chaqirganda, React formaning `FormData` obyektini server harakatiga birinchi argument sifatida taqdim etadi.

Formaga server harakatini action sifatida berish orqali, React formani asta-sekin yaxshilaydi. Bu shuni anglatadiki, forma JavaScript paketi yuklanmasidan oldin yuborilishi mumkin.


### Formalardan Tashqarida
Server harakatlari ochiq server endpointlari hisoblanadi va klient kodida istalgan joydan chaqirilishi mumkin. 

Formadan tashqarida server harakatini ishlatishda, biz uni o'tish (transition) jarayonida chaqirishimiz mumkin, bu esa yuklanish indikatorini ko'rsatish, optimistik holat yangilanishlarini namoyish qilish va kutilmagan xatolarni boshqarish imkonini beradi. Mana formadan tashqarida server harakatiga misol:
``` js copy
"use client";

import incrementLike from "./actions";
import { useState, useTransition } from "react";

function LikeButton() {
  const [isPending, startTransition] = useTransition();
  const [likeCount, setLikeCount] = useState(0);

  const incrementLink = async () => {
    "use server";
    return likeCount + 1;
  };

  const onClick = () => {
    startTransition(async () => {
      // Server harakati qaytarayotgan qiymatni o'qish uchun, natijani kutamiz.
      const currentCount = await incrementLike();
      setLikeCount(currentCount);
    });
  };

  return (
    <>
      <p>Total Likes: {likeCount}</p>
      <button onClick={onClick} disabled={isPending}>
        Like
      </button>
    </>
  );
}
```

Shunday qilib, server harakatlari React’da klient tomonidagi koddan server tomonidagi funksiyalarni chaqirish imkonini beruvchi kuchli yangi xususiyatdir. Bu funksiyalar asosan kutubxonalar yoki freymvorklar  ichida ishlatish uchun mo'ljallangan, chunki ularni an’anaviy (vanilla) React’da ishlatish biroz qiyinchilik tug'dirishi va ko'p moslashtirish ishlari talab etiladi. Biroq, bu juda ko'p qiziqarli foydalanish holatlarini amalga oshirishga imkon beruvchi qudratli xususiyatdir.