## Yangilanishlarni amalga oshirish

RSC’larning ko'plab ijobiy jihatlari bo'lsa-da, e'tibor berish kerak bo'lgan ayrim cheklovlar ham mavjud, ya'ni server va klient komponentlari haqida o'ylashning ortiqcha mental yukini qabul qilish. Bu har qanday komponent server komponenti bo'lmasligini anglatadi.


### Misol: Counter Komponenti
Masalan, foydalanuvchi `+` tugmasini bosganida hisob qiymatini `1` ga oshiradigan oddiy Counter’ni komponentini ko'rib chiqaylik:
``` js copy
function Counter() {
  const [count, setCount] = useState(0);
  return (
    <div>
      <h1>Salom do'stlar, mening ajoyib hisoblagichimga qarang!</h1>
      <p>Mening haqqimda: Men pirojnoe yoqtiraman! Mehmonlar kitobimni imzolang!</p>
      <p>Hisob: {count}</p>
      <button onClick={() => setCount(count + 1)}>+</button>
    </div>
  );
}
```

Bu komponent ikkita sababga ko'ra server komponenti bo'lishi mumkin emas:

#### useState’dan foydalanish
Bu faqat klient tomonda ishlatiladigan API hisoblanadi. Bu shuni anglatadiki, server `count`ning boshlang'ich qiymatini bilmaydi, shuning uchun u boshlang'ich HTML’ni render qila olmaydi. Bu muammo, chunki server dastlabki HTML’ni render qilishi kerak, keyin klient interaktiv UI’ni render qilishi mumkin.

Server muhitida "state" tushunchasi bir nechta klientlar o'rtasida ulashiladi. Biroq, RSC’lar joriy qilinishidan oldin, React’da state hozirgi dasturga lokalizatsiya qilingan edi. Ushbu farq xavf tug'dirishi mumkin. Bu bir nechta klientlar o'rtasida state’ning sizib chiqishiga olib kelishi, potensial ravishda nozik ma'lumotlarni ochib berishi mumkin. Ushbu farq va unga tegishli xavfsizlik xavflari sababli, RSC’lar server tomonda `useState`dan foydalanishni qo'llab-quvvatlamaydi. Chunki server tomonidagi state klient tomonidagi state’dan asosan farq qiladi.

Bundan tashqari, `useState`dan olinadigan `setState` dispetcher funksiyasi serializatsiya qilinishi va klientga yuborilishi kerak, ammo funksiyalar serializatsiya qilinmaydi, shuning uchun bu imkonsiz bo'ladi.


#### onClick’dan foydalanish
Bu ham faqat klient tomonida ishlatiladigan API hisoblanadi. Chunki serverlar interaktiv emas: serverda ishlayotgan jarayonni "click" qilib bo'lmaydi, shuning uchun server komponentlarida `onClick` biroz imkonsiz holatdir. Bundan tashqari, server komponentlari uchun barcha props’lar serializatsiya qilinishi kerak, chunki server props’larni serializatsiya qilishi va klientga yuborishi kerak, funksiyalar esa serializatsiya qilinmaydi.


### Qisqa yechim
Shu sababli, oddiy hisoblagich endi server qismi va klient qismiga bo'linishi kerak, agar biz server komponentlarining kuchidan foydalanishni xohlasak:
``` js copy
// Server Component
function ServerCounter() {
  return (
    <div>
      <h1>Salom do'stlar, menim yaxshi hisoblagichimni ko'ring!</h1>
      <p>
        Men haqida: Men narsalarni hisoblashni yoqtiraman va men hisoblagichman va
        ba'zida narsalarni hisoblayman, lekin boshqa paytlarda Men chello chalishni
        yoqtiraman va bir marta band kampida men 1000 gacha hisobladim va qaroqchi
        paydo bo'ldi
      </p>
      <InteractiveClientPart />
    </div>
  );
}

// Client Component
"use client";
function InteractiveClientPart() {
  const [count, setCount] = useState(0);
  return (
    <div>
      <p>Hisob: {count}</p>
      <button onClick={() => setCount(count + 1)}>+</button>
    </div>
  );
}
```

Bu misol biroz boshqacha bo'lsa-da, siz olgan har qanday React komponentini server komponentiga aylantirib bo'lmaydi. Sizning komponentingizning qaysi qismlari serverda render qilinishi va qaysi qismlari klientda render qilinishi to'g'risida o'ylashingiz kerak. Bu bir oz qiyinchilik keltirib chiqaradi, chunki bu misolda serverda render qilinadigan va klientda render qilinadigan qismlar aniq, lekin real hayotdagi dasturlarda bu shunchalik aniq bo'lmasligi mumkin.

Shunday qilib, biz hisoblagich dasturimizning interaktiv qismidan kichik bir qismini ajratib oldik va faqat shu qism bizning foydalanuvchilarimizga JavaScript to'plam paketi sifatida yetkaziladi; qolgan qismi esa yetkazilmaydi. Natijada, biz tarmoq orqali juda kichik JavaScript paketlarini jo'natamiz, bu esa yuklash vaqtlarini tezlashtiradi va foydalanuvchilarimiz uchun CPU va tarmoq jihatidan yanada yaxshi ishlashni ta'minlaydi, chunki JavaScript’ni tahlil qilish va bajarish uchun kamroq ish qilinishi kerak va yuklanadigan ma'lumotlar kam bo'ladi.

Shu sababli, biz xavfsiz serverda imkon qadar ko'proq render qilishni xohlaymiz, shunda klient tomondagi paketlar ichiga kod qo'shmaymiz.


### Ichki mexanizmga chuqur nazar
Qo'shimcha mental yuklamani hisobga olgan holda, keling, React qanday qilib server komponentlari va klient komponentlarini ichki mexanizmda alohida ajratib va ulardan qanday foydalanishini ko'rib chiqaylik. Bu muhim, chunki bu bizga dasturimizga yangilanishlar kiritishni tushunishga yordam beradi.

#### Klient komponentlari
Klient komponentlari "use client" direktivasi yordamida ajratiladi va bu direktiva klient komponentlarini o'z ichiga olgan faylning yuqori qismida joylashadi. RSCs server va klient komponentlarini ushbu direktivalarning ishlatilishiga asoslanib farqlash uchun keyingi avlod vositalarini talab qiladi. 

Keyingi avlod vositalarini yig'uvchi yoki yig'uvchi konfiguratsiyasidan foydalangan holda, yig'uvchilar React ilovalari uchun alohida modul grafiklarini ishlab chiqarish imkoniyatiga ega: server grafik va klient grafik. Server grafiki hech qachon paketga aylantirilmaydi, chunki u foydalanuvchilarga yetkazib berilmaydi, lekin "use client" direktivasi bilan boshlanuvchi barcha fayllar bitta klient paketi yoki bir nechta paketlarga qo'shiladi, ularni ehtiyojga qarab yuklab olish mumkin. Ushbu amalga oshirish tafsilotlari RSCs ustida qurilgan freymvorklar bilan bog'liq.

#### Grafiklar
Shunday qilib, kontseptual jihatdan bizda serverda bajariladigan server grafigi va klientda kerak bo'lganda yuklab olinadigan va bajariladigan bitta yoki bir nechta klient paketlari mavjud. Ammo React klient komponentlarini qachon import qilish va bajarish kerakligini qanday biladi? Buni tushunish uchun biz odatiy React daraxtini ko'rib chiqishimiz kerak. Keling, hisoblagich misolimizdan foydalanamiz.

#### Komponentlar daraxti
Pastdagi rasmda, hisoblagich ilovamiz uchun komponentlar daraxtini vizualizatsiya qilamiz, bu yerda to'rtta komponentlar serverda render qilingan va yashil komponentlar klientda render qilingan. Daraxtning ildizi server komponenti bo'lgani uchun, butun daraxt serverda render qilinadi. Biroq, `InteractiveClientPart` komponenti klient komponenti bo'lgani uchun, u serverda render qilinmaydi. Buning o'rniga, server klient komponenti uchun joylashuvni render qiladi, bu esa klient yig'uvchisi ishlab chiqargan maxsus modulga havola hisoblanadi.

Ushbu modul havolasi asosan “agar siz daraxtda ushbu nuqtaga yetib kelsangiz, ushbu maxsus moduldan foydalanish vaqti keldi” degan ma'noni anglatadi.
![Server va klient komponentlar](/server-and-client-components.png)

Modul har doim faqat kechiktirib yuklab olinishi shart emas, balki dastlabki paketdan ham yuklab olinishi mumkin, chunki yig'uvchilar foydalanuvchilarga yetkazib beradigan paketlarda ko'plab modullarni qo'shadi. Bu tom ma'noda, `getModuleFromBundleAtPosition([0,4])` yoki shunga o'xshash narsa bo'lishi mumkin. Asosiy nuqtasi shundaki, server to'g'ri klient moduliga havolani yuboradi va React klient tomonida bo'sh joyni to'ldiradi.

Bu jarayon sodir bo'lganda, React modul havolasini klient paketi ichidagi haqiqiy modul bilan almashtiradi. Bu biroz soddalashtirish bo'lsa-da, mexanizmni yaxshi tushunishimizga yordam beradi. Klient komponenti klientda render qilinadi va klient komponenti bilan odatdagidek o'zaro aloqada bo'lish mumkin. RSCs uchun keyingi avlod yig'uvchisi kerak bo'lishining sababi shundaki, ular server va klient komponentlari uchun alohida modul grafiklarini ishlab chiqarishi kerak.


#### Render qilingan daraxt
Amalda, bu bizning hisoblagich misolimizda server quyidagi daraxtni render qiladi:
``` js copy
{
  $$typeof: Symbol(react.element),
  type: "div",
  props: {
    children: [
      {
        $$typeof: Symbol(react.element),
        type: "h1",
        props: {
          children: "Hello friends, look at my nice counter!"
        }
      },
      {
        $$typeof: Symbol(react.element),
        type: "p",
        props: {
          children: "About me: I like to count things"
        }
      },
      // Klient-qism elementi uchun vaqtinchalik joy tutuvchi(placeholder) modul havolasi
      // Diqqat qiling: bu modul havolasi!
      {
        $$typeof: Symbol(react.element),
        type: {
          $$typeof: Symbol(react.module.reference),
          name: "default",
          filename: "./src/ClientPart.js",
          moduleId: "client-part-1234"
        },
        props: {
          children: [
            {
              // ...boshqa server komponentlari va klient modul havolalari
              $$typeof: Symbol(react.element),
              type: {
                $$typeof: Symbol(react.module.reference),
                name: "default",
                filename: "./src/AnotherClientComponent.js"
              },
              props: {
                children: [],
              }
            },
            {
              $$typeof: Symbol(react.element),
              type: "div",
              props: {
                children: "I am a server component"
              }
            }
          ]
        }
      }
    ]
  }
}
```

Ushbu daraxt klient tomoniga yuboriladi va React uni render qilar ekan, modul havolasiga duch kelganda, React ushbu modul havolasini klient paketi ichidagi haqiqiy modul bilan aqlli tarzda almashtiradi. Shunday qilib, React qachon klient komponentlarini import qilish va bajarish kerakligini biladi.


#### Klient komponentlarining qayta qo'llanilishi
Shunday qilib, biz bundler serverda butun daraxtni render qilish imkoniyatiga ega ekanligini va faqat klientda to'ldirilishi kerak bo'lgan "teshiklar" qoldirilishini ko'ramiz, shu bilan birga, serverda klient komponentlarining bolalarini rekursiv tarzda render qilib, to'liq daraxt hosil qiladi. Klient, keyin esa zarur bo'lgan har qanday teshikni klient paketlarini yuklab olib va bajarish orqali to'ldiradi.

Server komponentlari, shuningdek, Suspense chegaralariga o'rnatilishi mumkin. Freymvorklar ushbu komponentlarni server tomondan foydalanuvchilarga "tayyor" bo'lganda, ya'ni ular talab qiladigan har qanday ma'lumot olinganda va boshqa har qanday zarur operatsiyalar asinxron ravishda bajarilganda, oqimda yuborish uchun kerakli ishlarni bajaradi.

Umid qilamanki, endi biz klient komponentlarining server komponentlaridan qanday ajratilishini tushundik, bu esa RSC’larga yo'naltirilgan ilovalarda yangilanishlarni amalga oshirish imkonini beradi. `"use client"` bilan belgilangan klient komponentlari mahalliy holat va `onClick` kabi event handler’larni muammosiz o'z ichiga olishi mumkin.

Endi biz klient komponentlari bilan tugaganimiz va server komponentlari qanday ishlashini, shuningdek, klient komponentlari qanday qilib klient paketlariga qo'shilishini tushunganimizdan so'ng, bu mavzular atrofida bir oz nozikliklarni muhokama qilishimiz kerak.