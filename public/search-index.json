[
  {
    "id": "tools",
    "title": "Veb Asboblar",
    "content": "JSON formatter, URL encoder, Base64 converter, QR generator, Password generator va boshqa foydali veb asboblar to'plami",
    "url": "/tools",
    "category": "tools",
    "tags": [
      "tools",
      "utilities",
      "json",
      "url",
      "base64",
      "qr",
      "password"
    ]
  },
  {
    "id": "book-fluent-react-common-questions-forget-about-all-this-page",
    "title": "React Forget: Avtomatik Memoizatsiya va useMemo Kelajagi",
    "content": "Bularni barchasini \"Unuting\" React Forget — bu React ilovalarida memoizatsiyani avtomatlashtirishga qaratilgan yangi vositalar to'plami bo'lib, ehtimol, bundan keyin va kabi hook’larni ishlatish ortiqcha bo'lib qolar. Memoizatsiyani avtomatik ravishda boshqarish orqali _React Forget_ komponentlarning qayta render qilishini optimallashtiradi, foydalanuvchi bilan ishlash qulayligi(UX) va dasturchi bilan ishlash qulayligi(DX)ni yaxshilaydi. Ushbu avtomatlashtirish React’ning qayta render qilish xulq-atvorini obyekt identifikatori o'zgarishlaridan semantik qiymat o'zgarishlariga o'tkazadi, chuqur taqqoslashlarsiz, shunday qilib, ishlash samaradorligini oshiradi. 2021-yilda React Conf’da taqdim etilgan _React Forget_ hozirda \"production\"da umuman mavjud emas, lekin Meta’da Facebook, Instagram va boshqa platformalarda ishlab chiqarishda foydalanilmoqda va ichki ko'rsatkichlarga ko'ra \"kutilgan natijalardan-da a'lo\".",
    "url": "/books/fluent-react/common-questions/forget-about-all-this/page",
    "category": "books",
    "tags": [
      "fluent-react",
      "tutorial",
      "guide",
      "react",
      "javascript",
      "frontend",
      "react",
      "ishlash",
      "forget",
      "memoizatsiyani",
      "lib",
      "avtomatik",
      "_react",
      "forget_",
      "qayta",
      "render",
      "bilan",
      "qulayligi",
      "2021",
      "bularni",
      "barchasini"
    ]
  },
  {
    "id": "book-fluent-react-common-questions-getting-fluent-in-react-memo-page",
    "title": "React.memo Tahlili: Nega Komponentlar Baribir Qayta Render Bo'ladi?",
    "content": "React.memo’ni chuqurroq o'rganish qanday ishlashini qisqacha tushuntirib o'tamiz. React’da yangilanish yuz berganda, sizning komponentingiz avvalgi renderdan qaytarilgan vDOM(virtual DOM) natijasi bilan taqqoslanadi. Agar bu natijalar boshqacha bo'lsa — ya'ni, props o'zgarsa — reconciler host muhiti (odatda brauzer DOM) ichida mavjud bo'lgan element uchun yangilash effektini ishlatadi yoki u mavjud bo'lmasa, joylashtirish effektini bajaradi. Agar props bir xil bo'lsa, komponent baribir qayta render qilinadi va DOM ham yangilanadi. ’ning asosiy afzalligi shundaki, u komponentning props qiymatlari har ikki render o'rtasida bir xil bo'lsa, kerak bo'lmagan qayta render qilishlardan qochishga yordam beradi. React’da buni qila olishimiz mumkin ekan, savol tug'iladi: qanchalik va qaysi holatlarda memoizatsiya qilishimiz kerak? Agar har bir komponentni memoizatsiya qilsak, umuman olganda ilovamiz tezroq bo'larmikin? Memoizatsiya qilingan komponentlar baribir qayta render bo'lishi komponentning props qiymatlari o'zgarganmi yoki yo'qligini aniqlash uchun _yuzaki taqqoslash (shallow comparison)_ usulidan foydalanadi. Bu yondashuvning kamchiligi shundaki, JavaScript’da skalyar turlar aniq taqqoslanishi mumkin bo'lsa-da, skalyar bo'lmagan turlar taqqoslashda aniq natija bermaydi. Bularni yaxshiroq tushunib olishimiz uchun, keling, avval skalyar va skalyar bo'lmagan turlar nima ekanligini hamda ularning taqqoslash operatsiyalaridagi xatti-harakatlarini ko'rib chiqamiz. Skalyar turlar (primitive types) Skalyar turlar, shuningdek, primitiv turlar deb ham ataladi, va ular asosiy, sodda qiymatlarni ifodalaydi. Bu turlar yakka, bo'linmas qiymatlarni ifodalaydi va array’lar yoki object’lar kabi murakkab ma'lumot strukturalariga ega emaslar. Skalyar turlar tabiatan o'zgarmas (immutable) hisoblanadi, ya'ni bir marta belgilanganidan so'ng, yangi qiymat yaratmasdan turib o'zgartirilishi mumkin emas. JavaScript’da bir necha skalyar turlar mavjud, jumladan, number, string, boolean, va boshqalar, masalan, symbol, BigInt, undefined, va null. Har biri o'ziga xos maqsadga xizmat qiladi. Misol uchun, number turlari o'z-o'zidan tushunarli bo'lsa, symbol qiymatlari takrorlanmas identifikatorlar yaratish uchun ishlatiladi, undefined va null esa turli kontekstlarda qiymatning yo'qligini ifodalash imkonini beradi. Skalyar qiymatlar taqqoslanayotganda, biz odatda ularning haqiqiy qiymatini yoki tarkibini taqqoslaymiz. Skalyar bo'lmagan turlar (reference types) Skalyarlarning soddaligidan tashqariga chiqsak, biz skalyar bo'lmagan yoki referens(reference) yoki havola turlari bilan tanishamiz. Bu turlar ma'lumotlarni o'zida saqlamaydi, balki ma'lumotlar xotirada saqlanadigan joyga ishora qiluvchi havola yoki ko'rsatkichni saqlaydi. Bu farqni anglash juda muhim, chunki bu turlar qanday taqqoslanishi, boshqarilishi va kodda o'zaro ishlashi bilan bog'liq xatti-harakatlariga ta'sir qiladi. JavaScript’da eng keng tarqalgan skalyar bo'lmagan turlar object’lar va array’lar hisoblanadi. Object’lar kalit-qiymat juftliklari bilan tuzilgan ma'lumotlarni saqlashga imkon beradi, array’lar esa tartiblangan to'plamni taqdim etadi. Funksiyalar ham JavaScript’da referens turlari hisoblanadi. Skalyar bo'lmagan turlarning asosiy xususiyati shundaki, bir nechta havola bir xil xotira joyiga ishora qilishi mumkin. Bu shuni anglatadiki, agar ma'lumot bir havola orqali o'zgartirilsa, bu o'zgarish boshqa bir xil ma'lumotga ishora qiluvchi havolalarga ham ta'sir qiladi. Taqqoslashga kelganda, skalyar bo'lmagan turlar xotiradagi havolasi orqali taqqoslanadi, tarkibi orqali emas, skalyar turlardan farqli o'laroq. Bu ba'zida ushbu nozik jihat bilan tanish bo'lmagan odamlar uchun kutilmagan natijalarga olib kelishi mumkin. Masalan, tarkibi bir xil bo'lgan ikkita array, lekin xotirada turli joylarda saqlanayotgan bo'lsa, ular qat'iy tenglik operatori yordamida taqqoslanganda teng bo'lmaydi. Yuqoridagi massivlarni taqqoslashda, array’lar, object’lar va boshqa skalyar bo'lmagan turlar havola, ya'ni _reference_, orqali taqqoslanadi: ya'ni chap tarafdagi array’ning kompyuter xotirasidagi joyiga bo'lgan havolasi o'ng tarafdagi array’ning xotiradagi joyiga tengmi yoki yo'qmi, shuni solishtiradi. Shuning uchun taqqoslash qiymatini qaytaradi. Object’lar uchun ham xuddi shunday. Obyektlarni taqqoslaganimizda, xotirada chap taraf va o'ng tarafda ikkita turli obyekt yaratamiz — tabiiyki, ular teng emas, ular xotirada ikki xil joyda yashaydigan ikkita turli obyekt! Ularning kontenti bir xil bo'lsa ham. React.memo’dan foydalanishda e'tibor qilish kerak bo'lgan jihatlar ishlatishda ba'zi bir chalg'ituvchi jihatlar bo'lishi mumkin. Quyidagi misol orqali buni ko'rib chiqamiz: deb nomlangan funksional komponentga items nomli massivni props sifatida uzatamiz va uni render qilamiz: Endi, bu komponentni ota komponent ichida ishlatamiz va har bir ota komponent qayta render qilinganda yangi massiv nusxasini uzatamiz: Har safar tugmasi bosilganda, qayta render qilinadi. Garchi komponentiga uzatilayotgan items massivining qiymati o'zgarmagan bo'lsa ham, har safar qayta kabi yangi massiv nusxasi yaratiladi. props’ni yuzaki taqqoslash (shallow comparison) orqali taqqoslaydi, shuning uchun bu yangi massiv nusxasini oldingi renderdagi massivdan farqli deb ko'radi va komponentini keraksiz qayta render qiladi. Bu muammoni hal qilish uchun, massivni yordamida memoizatsiya qilishimiz mumkin: Endi massiv faqat bir marta yaratiladi va har bir qayta render qilinishda bir xil havolani saqlaydi, bu esa komponentining keraksiz qayta render qilinishining oldini oladi. Bu misol va skalyar bo'lmagan, ya'ni referens turlar bilan, props’lar bilan ishlaganda havola bo'yicha taqqoslashni tushunish qanchalik muhimligini ko'rsatadi. Agar ehtiyotkorlik bilan foydalanilmasa, optimallashtirish o'rniga, tasodifan ishlash samaradorligiga salbiy ta'sir qiluvchi muammolarni yuzaga keltirishi mumkin. Funksiyalarni memoizatsiya qilish ko'pincha funksiyalar kabi referens turdagi qiymatlar tufayli ham chetlab o'tiladi. Quyidagi holatni ko'rib chiqamiz: Yuqoridagi kodda props’lar o'zgarmaydigandek tuyuladi: , , va o'zgarmas(constant) qiymatlarga ega. Ammo props’larni taqqoslasak, quyidagicha bo'ladi: Buning sababi shundaki, funksiyalar havola orqali taqqoslanadi. Har safar qayta render qilinganda, prop uchun yangi funksional nusxa yaratiladi va bu yangi havola(reference) deb hisoblanadi, natijada komponenti qayta memoizatsiya qilinmaydi. Bu muammoni hook’idan foydalanib hal qilish mumkin. yordamida ota komponent ichida funksiyani xotirada saqlab qo'yamiz, shunda u faqatgina uning qaramlik(dependency) ro'yxatidagi biror narsa o'zgarganda yangilanadi: Endi ishonchimiz komil bo'lishi mumkinki, hech qachon o'zgarmaydi, agar uning qaramliklar massividagi(ikkinchi argumenti) biror narsa o'zgarmasa. Shu orqali, biz qilgan memoizatsiya texnikasi to'liq va ishonchli bo'ladi. Bu funksiyalarni props orqali komponentga o'tkazganda tavsiya etiladigan usul hisoblanadi. Ajoyib! Ammo bu hali ham barcha holatlarda memoizatsiya qilinadigan komponentlar keraksiz ravishda qayta render qilinmasligini anglatadi, shundaymi yoki yo'qmi? Biz yana bir narsani inobatga olishimiz kerak bo'ladi, u haqida keyingi mavzuda batafsil to'xtalamiz.",
    "url": "/books/fluent-react/common-questions/getting-fluent-in-react-memo/page",
    "category": "books",
    "tags": [
      "fluent-react",
      "tutorial",
      "guide",
      "react",
      "javascript",
      "frontend",
      "bir",
      "skalyar",
      "turlar",
      "qayta",
      "render",
      "uchun",
      "lmagan",
      "lar",
      "props",
      "yoki",
      "ham",
      "mumkin",
      "orqali",
      "bilan",
      "lsa"
    ]
  },
  {
    "id": "book-fluent-react-common-questions-greater-control-ui-with-suspense-page",
    "title": "React Suspense: UI Yuklanish Holatlarini Samarali Boshqarish",
    "content": "Suspense yordamida UI'ni yaxshiroq boshqarish ishlash usuli bloklariga o'xshaydi. Misol uchun, qanday qilib istalgan joydan xatolik(exception)ni qilib, keyin uni boshqa joyda (hatto boshqa modulda ham) qilish mumkin bo'lsa, ham shunga o'xshash tarzda ishlaydi (garchi to'liq bir xil bo'lmasa ham). Komponent daraxtida har qanday joyda kerakli paytda yuklanadigan va asinxron primitivlarni joylashtirishingiz va keyin daraxtning istalgan yuqori qismida, hatto boshqa faylda joylashgan komponenti orqali ham ularni bilan ushlab olishingiz mumkin. Bu ma'lumotdan kelib chiqib, bizda 22 MB sidebar uchun yuklanish holatini (loading state) ko'rsatish joyini tanlash imkoniyati paydo bo'ladi. Masalan, biz sidebar yuklanayotgan paytda butun ilovani ko'rsatmasligimiz mumkin — bu yaxshi g'oya emas, chunki foydalanuvchidan ilovaning barcha ma'lumotlarini bloklaymiz, shunchaki faqat sidebar uchun — yoki faqat sidebar uchun yuklanish holatini ko'rsatamiz. Keling, birinchisini qanday amalga oshirishni ko'rib chiqaylik (garchi buni qilmasligimiz kerak), shunchaki imkoniyatlarini tushunish uchun: Bu misolda, biz butun komponentni bilan o'rab olamiz va ni (promise hal qilinmaguncha ko'rsatiladigan holatni) asinxron komponentlar hal qilinib bo'lmaguncha ko'rsatamiz. Bu degani, sidebar yuklanmaguncha butun ilova yashirin bo'lib turadi. Ba'zan bu foydali bo'lishi mumkin, masalan, hamma narsa tayyor bo'lganda foydalanuvchi interfeysini ko'rsatmoqchi bo'lsak, ammo bu holatda eng yaxshi g'oya emas, chunki foydalanuvchi nima bo'layotganini bilmay qoladi va ilova bilan muloqot qila olmaydi. Shuning uchun, faqat kerakli paytda yuklanadigan komponentlarni o'rab olish uchun ni ishlatish kerak, quyidagicha: chegarasi juda kuchli primitiv bo'lib, foydalanuvchi interfeysini yanada javob beruvchan va intuitiv qiladi. Agar yuqori sifatli skelet UI (Skeleton UI) uchun ishlatilsa, foydalanuvchilarga yuklanayotgan komponentlar tugashi bilan nima sodir bo'lishini va ular nimani kutishlari kerakligini tushunishga yordam beradi. Bularning barchasidan foydalanish ilovalarimizning ishlash samaradorligini yaxshilash va React’dan maksimal darajada foydalanishning ajoyib usuli hisoblanadi. Keyingi mavzuda, ko'plab React dasturchilari so'raydigan yana bir qiziqarli savolni ko'rib chiqamiz: qachon biz ni o'rniga ishlatishimiz kerak?",
    "url": "/books/fluent-react/common-questions/greater-control-ui-with-suspense/page",
    "category": "books",
    "tags": [
      "fluent-react",
      "tutorial",
      "guide",
      "react",
      "javascript",
      "frontend",
      "uchun",
      "sidebar",
      "ham",
      "mumkin",
      "bilan",
      "qanday",
      "boshqa",
      "paytda",
      "yuklanish",
      "biz",
      "butun",
      "faqat",
      "kerak",
      "foydalanuvchi",
      "react"
    ]
  },
  {
    "id": "book-fluent-react-common-questions-immer-and-ergonomics-page",
    "title": "Immer: Murakkab React State'ni Oson Boshqarish (useReducer & useState)",
    "content": "Immer va foydalanish qulayligi Immer - bu juda mashhur React kutubxonasi bo'lib, ilovalaringizdagi murakkab state boshqaruvida foydali hisoblanadi. State’ning shakli murakkab yoki ichma-ich joylashgan bo'lsa, an'anaviy state’ni yangilash usullari ko'p vaqt talab qilishi va xatolarga moyil bo'lishi mumkin. Immer bunday murakkabliklarni boshqarishda sizga o'zgaruvchan qoralama state (mutable draft state) bilan ishlashga imkon beradi, shu bilan birga ishlab chiqarilgan state o'zgarmas bo'lib qolishini ta'minlaydi. React ilovasida state boshqaruvi odatda yoki hook’lari orqali amalga oshiriladi. oddiy state uchun mos bo'lsa, murakkab state boshqaruvi uchun ko'proq mos keladi va aynan shu yerda Immer’ning eng katta foydasi namoyon bo'ladi. useReducer bilan ishlatish bilan ishlaganda, siz taqdim etgan reducer funksiyasi sof bo'lishi va doim yangi state obyektini qaytarishi kutiladi. Bu ichma-ich joylashgan state obyektlarini boshqarishda ko'p vaqt talab qiluvchi, ko'proq yoziladigan kodga olib kelishi mumkin. Ammo, _use-immer_ kutubxonasidagi orqali Immer’ni bilan integratsiya qilib, siz state’ni bevosita o'zgartirgandek yozishingiz mumkin, aslida esa Immer tomonidan taqdim etilgan qoralama state’da ishlaysiz. Shu tariqa, siz oddiy va intuitiv reducer funksiyalarini yozishingiz mumkin: Ushbu misolda, reducer funksiyasini sezilarli darajada soddalashtiradi, ichma-ich joylashgan state xususiyatlarini bevosita tayinlash orqali yangilash imkonini beradi, bu esa an’anaviy reducer’da yoki operatsiyalarini talab qilgan bo'lar edi. useState bilan ishlatish Bundan tashqari, Immer faqat bilan cheklanmagan. Agar sizda murakkab state obyekti bo'lsa va state’ni yangilashda o'zgarmasligini ta’minlashni istasangiz, uni bilan ham ishlatishingiz mumkin. Immer funksiyasini taqdim etadi, bu orqali hozirgi state’ga asoslangan holda va bir qator ko'rsatmalar yordamida yangi state yaratishingiz mumkin: funksiyasida, Immer’ning funksiyasi hozirgi va state’ning ini qabul qiladigan funksiyani oladi. Ushbu funksiya ichida bilan go'yo u o'zgaruvchan kabi ishlashingiz mumkin, Immer esa ishlab chiqarilgan state’ning yangi o'zgarmas obyekt ekanligini ta’minlaydi. Immer’ning soddalashtirish qobiliyati Imme’rning state yangilanishlarini soddalashtirish qobiliyati, ayniqsa murakkab yoki ichma-ich joylashgan state strukturalarida, React’ning state boshqaruvi hook’lariga ajoyib yordamchi bo'lib, kodni toza, oson boshqariladigan va xatolarga kamroq moyil bo'lishiga yordam beradi.",
    "url": "/books/fluent-react/common-questions/immer-and-ergonomics/page",
    "category": "books",
    "tags": [
      "fluent-react",
      "tutorial",
      "guide",
      "react",
      "javascript",
      "frontend",
      "state",
      "immer",
      "bilan",
      "ning",
      "mumkin",
      "murakkab",
      "react",
      "yoki",
      "ichma",
      "ich",
      "joylashgan",
      "orqali",
      "reducer",
      "lib",
      "lsa"
    ]
  },
  {
    "id": "book-fluent-react-common-questions-its-guideline-not-rule-page",
    "title": "React.memo: Bu Qoida Emas! Memoizatsiya Qachon Ishlamaydi?",
    "content": "Bu Qoida emas, Yo'riqnoma! React funksiyasidan o'zining reconciler’iga ishora sifatida foydalanadi, agar komponentning props’lari o'zgarmasa, qayta render qilinishini xohlamasligimizni bildirish uchun mo'ljallangan. Bu faqatgina React uchun ishora bo'lib xizmat qiladi, lekin oxir-oqibatda React nima qilishni o'zi hal qiladi. ning yagona maqsadi ota komponentdan kelib chiqadigan qayta render qilinishlarni oldini olishga yordam berishdir. Biroq, bu komponent hech qachon qayta render qilinmasligini kafolatlamaydi. Ilk boblarimizda aytilganidek, React foydalanuvchi interfeysimizning deklarativ abstraksiyasi sifatida mo'ljallangan: biz qanday natija olishni xohlayotganimizni tasvirlaymiz, va React bu natijaga qanday erishishni o'zi aniqlaydi. ham ushbu jarayonning bir qismi hisoblanadi. doimiy ravishda qayta render qilinmasligini kafolatlamaydi, chunki React memoizatsiya qilingan komponentni qayta render qilishga turli sabablarga ko'ra qaror qilishi mumkin, masalan, komponentlar daraxtidagi o'zgarishlar yoki ilovaning global state’idagi o'zgarishlar tufayli. Keling, React manbasining kodidagi ba'zi kod qismlariga nazar tashlab ko'raylik, bu orqali yaxshiroq tushunishimiz mumkin bo'ladi. React.memo funksiyasi Avvalo, ning bajarilishini ko'rib chiqamiz: Ushbu implementatsiyada, memoizatsiya qilingan komponentni ifodalovchi yangi obyektni qaytaradi. Obyektning xususiyati uni memoizatsiya komponent sifatida aniqlaydi, xususiyati esa asl komponentga havola qiladi, va xususiyati esa memoizatsiya qilish uchun taqqoslash funksiyasini belgilaydi. React.memo’ning reconciler ichida ishlatilinishi reconciler ichida qanday ishlashini ko'rib chiqamiz: Funksiya tahlili 1. Dastlabki tekshiruv: funksiyasi bir nechta parametrlarni qabul qiladi, jumladan, joriy(current) va jarayondagi(work-in-progress) Fiber’lar, komponent, yangi props va render qatorlari (bu yangilanishlarning ustuvorligi va vaqtini belgilaydi). Dastlabki tekshiruv komponentning dastlabki render bo'layotganini aniqlaydi. Agar qiymati bo'lsa, demak, komponent birinchi marta yuklanmoqda. 2. Tip va tezkor yo'l(fast path)ni optimallashtirish: Keyin komponent oddiy funksiya komponenti ekanligini va va larni tekshirish orqali tezkor yo'ldan yangilanish uchun mosligin tekshiradi. Agar ushbu shartlar bajarilsa, jarayondagi Fiber’ning tegini ga o'rnatadi, bu komponent tipini soddalashtirish va samaraliroq yangilanish imkonini beradi. 3. Ishlab chiqish rejimi(development mode)da tekshiruvlar: Ishlab chiqish rejimida , funksiya qo'shimcha tekshiruvlarni amalga oshiradi, masalan, prop turlarini tasdiqlash va eskirgan xususiyatlar (masalan, funksiya komponentlaridagi ) haqida ogohlantirish. 4. Yangi Fiber yaratish: Agar bu dastlabki render’da bo'lsa, yordamida yangi Fiber yaratiladi. Bu Fiber React renderer uchun bir ish birligi(unit)ni ifodalaydi. U havolalarni sozlaydi va bola(yangi Fiber)ni qaytaradi. 5. Mavjud Fiber’ni yangilash: Agar komponent yangilanayotgan bo'lsa , u \"development mode\"dagi kabi tekshiruvlarni amalga oshiradi. Keyin eski props’ni yangi props bilan yuzaki taqqoslash yoki berilgan maxsus taqqoslash funksiyasidan foydalanib yangilanish kerakligini tekshiradi. 6. Yangilashdan chiqish: Agar props’lar teng bo'lsa va ref o'zgarmagan bo'lsa, yordamida yangilashdan chiqib ketishi mumkin, ya'ni ushbu komponent uchun qo'shimcha render ishlari talab qilinmaydi. 7. Jarayondagi Fiber’ni yangilash: Agar yangilanish kerak bo'lsa, funksiya jarayondagi Fiber’ni bayrog'i bilan belgilaydi va joriy bola asosida yangi jarayondagi bola Fiber yaratadi, lekin yangi props bilan. Xulosa qilib aytganda, ushbu funksiya memoizatsiyalangan komponentni ( bilan o'ralgan komponent), uning ishlash samaradorligini optimallashtirish uchun yangilash kerakmi yoki yangilanishni o'tkazib yuborsa bo'ladimi, shuni aniqlaydi. U dastlabki render va keyingi yangilanishlarni boshqaradi hamda yangi Fiber yaratish yoki mavjudini yangilashga qarab turli operatsiyalarni bajaradi. React.memo’ning renderlash shartlari Mana bu yerda, ushbu funksiyadagi qaysi qismlar komponentining qayta render qilinish yoki qilinmasligi shartlarini qanday belgilashi haqida: - Avvalgi render yo'q (birinchi marta o'rnatish(mount)): Agar bo'lsa, komponent birinchi marta yuklanayotgan bo'ladi va shu sababli render qilishni o'tkazib yuborolmaydi. Yangi Fiber yaratiladi va render qilish uchun qaytariladi. - Oddiy funksiya komponentini optimallashtirish: Agar komponent oddiy funksiya komponenti bo'lsa (default props’larsiz va maxsus taqqoslash funksiyasiz), React uni ga optimallashtiradi. Bu React’ga yangilanishlar uchun tezkor yo'ldan foydalanishga imkon beradi, chunki u komponent faqat props’larga bog'liq ekanligi va yuzaki taqqoslash (shallow comparison) uni yangilash kerakmi yoki yo'qligini aniqlash uchun yetarli ekanligini taxmin qilishi mumkin. - Taqqoslash funksiyasi: Agar oldingi render mavjud bo'lsa, komponent faqat taqqoslash funksiyasi qiymat qaytargan taqdirda yangilanadi. Ushbu taqqoslash funksiyasi, agar berilgan bo'lsa, maxsus bo'lishi mumkin yoki aks holda yuzaki tenglikni tekshiruvchi bo'lishi mumkin. Agar taqqoslash funksiyasi yangi props’larni avvalgilari bilan bir xil deb aniqlasa va o'zgarmagan bo'lsa, komponent qayta render qilinmaydi va funksiya render jarayonidan chiqib ketadi. - Default props va prop turlarini \"development\"da tekshirish: Ishlab chiqish rejimida , va uchun tekshiruvlar mavjud. Ishlab chiqish rejimida ishlatilishi ogohlantirish beradi, chunki React’ning kelgusi versiyalarida funksional komponentlarda dan foydalanish tavsiya qilinmaydi. Prop turlari esa validatsiya maqsadida tekshiriladi. - Yangilanishdan chiqish shartlari: Agar hech qanday rejalashtirilgan yangilanish yoki _context_ o'zgarishi bo'lmasa ( qiymati bo'lsa), taqqoslash funksiyasi eski va yangi props’larni teng deb aniqlasa va o'zgarmagan bo'lsa, funksiya natijasini qaytaradi va qayta render qilishni samarali tarzda o'tkazib yuboradi. Ammo, agar rejalashtirilgan _context_ yangilanishlari bo'lsa, komponent qayta render qilinadi — hatto uning props’lari o'zgarmagan bo'lsa ham, chunki _context_ yangilanishlari komponent props’lari doirasidan tashqarida hisoblanadi. _State_ o'zgarishlari, _context_ o'zgarishlari va rejalashtirilgan yangilanishlar ham qayta render qilinishiga olib kelishi mumkin. - Bajarilgan ish bayrog'i: Agar yangilanish zarur bo'lsa, Fiber’da bayrog'i o'rnatiladi, bu esa ushbu Fiber joriy render davomida ishni bajarganligini ko'rsatadi. Shunday qilib, komponentlari faqat eski va yangi props orasidagi taqqoslash (berilgan maxsus taqqoslash funksiyasi yoki default yuzaki taqqoslash yordamida) props’larni teng deb belgilasa va _state_ yoki _context_ o'zgarishlari sababli rejalashtirilgan yangilanishlar bo'lmasa, qayta render qilinmaydi. Agar props’lar boshqacha, ya'ni o'zgargan, deb aniqlansa yoki _state_ yoki _context_ o'zgarishlari mavjud bo'lsa, komponent qayta render qilinadi.",
    "url": "/books/fluent-react/common-questions/its-guideline-not-rule/page",
    "category": "books",
    "tags": [
      "fluent-react",
      "tutorial",
      "guide",
      "react",
      "javascript",
      "frontend",
      "render",
      "komponent",
      "lsa",
      "agar",
      "props",
      "react",
      "fiber",
      "yangi",
      "taqqoslash",
      "qayta",
      "yoki",
      "uchun",
      "funksiya",
      "ushbu",
      "funksiyasi"
    ]
  },
  {
    "id": "book-fluent-react-common-questions-lazy-loading-page",
    "title": "React'da Lazy Loading: Sayt Tezligini React.lazy bilan Oshirish",
    "content": "Lazy loading (kerakli vaqtda yuklash) Bizning ilovalarimiz o'sib borishi bilan, ko'plab JavaScript kodlari to'planadi. Foydalanuvchilar keyin ushbu katta JavaScript to'plam paketlarini yuklab olishadi — ba'zida bu to'plam paketlari megabaytlarda ikki xonali raqamlarga yetadi — lekin ular faqat kichik bir qismidan foydalanishadi. Bu muammo bo'ladi, chunki bu foydalanuvchilarimizning dastlabki yuklash vaqtini sekinlashtiradi, shuningdek, keyingi sahifalarni yuklashni ham sekinlashtiradi, chunki ular butun to'plamni qayta yuklab olishga majbur bo'lishadi, ayniqsa biz bu to'plamlarni yetkazib beruvchi serverlarga kirish huquqiga ega bo'lmaganimizda va zaruriy keshlash sarlavhalarini qo'sholmaganimizda. JavaScript’ning ortiqcha yuklanishi Juda ko'p JavaScript yetkazib berishning asosiy muammolaridan biri shundaki, bu sahifa yuklash vaqtini sekinlashtirishi mumkin. JavaScript fayllari odatda boshqa veb-resurslarga, masalan, HTML va CSS’ga qaraganda kattaroq bo'ladi va ularni bajarish uchun ko'proq qayta ishlash vaqti talab etiladi. Bu ayniqsa sekin internet aloqasi bo'lgan yoki eski qurilmalarda uzoqroq sahifa yuklash vaqtiga olib kelishi mumkin. Masalan, quyidagi kod qismini ko'rib chiqaylik, u sahifa yuklash vaqtida katta JavaScript faylini yuklaydi: Bu misolda, _large.js_ fayli sahifaning qismida yuklanadi, ya'ni u sahifadagi boshqa barcha kontentlardan oldin bajariladi. Bu sekin sahifa yuklash vaqtlariga olib kelishi mumkin, ayniqsa sekin internet aloqasi yoki eski qurilmalarda. Ushbu muammoni hal qilishning keng tarqalgan yechimi JavaScript fayllarini atributidan foydalanib asinxron yuklashdir: Bu misolda, _large.js_ fayli atributi yordamida asinxron ravishda yuklanadi. Bu, fayl sahifadagi boshqa resurslar bilan parallel yuklanishi mumkinligini bildiradi, bu esa sahifa yuklash vaqtlarini yaxshilashi mumkin. Ma'lumotlar sarfi JavaScript’ni juda ko'p yetkazib berishning yana bir muammosi shundaki, bu ma'lumotlar sarfini oshirishi mumkin. JavaScript to'plam paketlari odatda boshqa veb-resurslarga qaraganda kattaroq bo'ladi, shuning uchun tarmoq orqali ko'proq ma'lumot uzatilishini talab qiladi. Bu cheklangan ma'lumotlar limitlariga ega foydalanuvchilar yoki sekin internet aloqasiga ega bo'lganlar uchun muammo tug'dirishi mumkin, chunki bu xarajatning oshishiga va sahifaning yuklash vaqtini sekinlashishiga olib kelishi mumkin. Ushbu muammolarni yengillatish uchun foydalanuvchilarga yetkaziladigan JavaScript miqdorini kamaytirish uchun bir nechta yondashuvlar qo'llashimiz mumkin. Yondashuvlardan biri kodlarni ajratib yuklash (code splitting) orqali ma'lum sahifa yoki funksiya uchun kerak bo'lgan JavaScript’ni yuklashdir. Bu faqat kerakli kodni yuklash orqali sahifa yuklash vaqtlarini va ma'lumotlar sarfini kamaytirishga yordam beradi. Masalan, quyidagi kod qismini ko'rib chiqaylik, u kodlarni ajratib yuklash orqali faqat kerakli JavaScript’ni yuklaydi: Bu misolda, funksiyasi asinxron ravishda _large.js_ faylini faqat kerak bo'lganda yuklaydi. Bu sahifa yuklash vaqtlarini va ma'lumotlar sarfini kamaytirishga yordam beradi. Yana bir yondashuv bu \"lazy loading\" orqali kerak bo'lmagan JavaScript’ni sahifa yuklangandan keyin yuklashni kechiktirishdir. Bu sahifa yuklash vaqtlarini va ma'lumotlar sarfini kamaytirishga yordam beradi, chunki muhim bo'lmagan kod faqat kerak bo'lganda yuklanadi. Masalan, muhim bo'lmagan JavaScript’ni yuklashni kechiktirish uchun \"lazy loading\"dan foydalanadigan quyidagi kod qismini ko'rib chiqamiz: Bu misolda, funksiyasi muhim bo'lmagan _non-critical.js_ faylini “Ko'proq yuklash” tugmasi bosilgandan keyin asinxron ravishda yuklaydi. Bu muhim bo'lmagan kodni faqat kerak bo'lganda yuklash orqali sahifa yuklash vaqtini va ma'lumotlardan foydalanishni kamaytirishga yordam beradi.. Yaxshiyamki, React bizga bu jarayonni yanada osonlashtiradigan yechimni taqdim etadi: va yordamida kerak bo'lganda yuklash. Keling, bular qanday qilib bizning ilovamizning ishlash samaradorligini yaxshilashga yordam berishini ko'rib chiqamiz. Kerakli vaqtda yuklash (lazy loading) Lazy loading — bu komponentni faqat kerak bo'lganda yuklash texnikasi, masalan, oldingi misoldagi dinamik import yordamida. Bu texnika katta ilovalar uchun foydali bo'lib, ko'plab komponentlar dastlabki yuklashda zarur bo'lmasa qo'llaniladi. Misol uchun, agar bizda katta ilova bo'lib, unda boshqa sahifalarga havolalar bo'lgan ro'yxatni o'z ichiga olgan yig'iladigan sidebar bo'lsa, dastlabki yuklashda ushbu sidebar’ni yuklashni xohlamasligimiz mumkin, agar u dastlabki yuklashda yig'ilgan bo'lsa. Buning o'rniga, foydalanuvchi sidebar’ni ochganida uni yuklaymiz. Quyidagi kod namunasi orqali buni ko'rib chiqaylik: Bu misolda, — bu 22 MB JavaScript kodi. Bu juda katta JavaScript kodi bo'lib, yuklab olish, tahlil qilish va bajarish uchun ko'p vaqt talab etiladi. Dastlabki yuklashda sidebar yig'ilgan bo'lsa, uni yuklash shart emas. Buning o'rniga, biz funksiyasidan foydalanib, komponentni faqat qiymati bo'lganda \"lazy loading\" texnikasi orqali yuklaymiz, ya'ni faqat kerak bo'lsa: Bu yerda faylini statik import qilishning o'rniga, biz uni dinamik ravishda import qilamiz, ya'ni funksiyasiga modulli import qilinadigan funksiyani qaytaruvchi va'da(promise)ni uzatamiz. Dinamik import promise qaytaradi, chunki modul darhol mavjud bo'lmasligi mumkin, uni dastlab serverdan yuklash kerak bo'ladi. funksiyasi import’ni ishga tushiradi, lekin asosiy komponent (bu yerda ) ekranga chiqarilmaguncha chaqirilmaydi. Shunday qilib, biz komponentini yuklashdan oldin 22 MB sidebar’ni ilovaga qo'shib yubormaslik imkoniyatiga ega bo'lamiz. Yana bir yangi import’ni payqagan bo'lishingiz mumkin: . Biz ni daraxt ichidagi komponentni o'rab qo'yish uchun ishlatamiz. — bu komponent, bizga promise yechimini kutayotgan paytda (o'qish: sidebar yuklanayotgan paytda) zaxira(fallback) komponentni ko'rsatishga imkon beradi. Kodda biz yuklanayotgan og'ir sidebar’ni yengilroq versiyasi bilan almashtirganmiz. Bu usul foydalanuvchiga sidebar yuklanayotganda darhol javob berishni ta’minlash uchun ajoyib usul. Endi foydalanuvchi tugmani bosib sidebar’ni almashtirganida, ular \"skelet UI\"ni ko'radi va panel yuklanib, ekranga chiqarilguncha o'z o'rnini egallashi mumkin.",
    "url": "/books/fluent-react/common-questions/lazy-loading/page",
    "category": "books",
    "tags": [
      "fluent-react",
      "tutorial",
      "guide",
      "react",
      "javascript",
      "frontend",
      "yuklash",
      "javascript",
      "mumkin",
      "uchun",
      "sahifa",
      "faqat",
      "kerak",
      "sidebar",
      "lazy",
      "orqali",
      "loading",
      "import",
      "biz",
      "lumotlar",
      "lganda"
    ]
  },
  {
    "id": "book-fluent-react-common-questions-memoization-with-react-memo-page",
    "title": "React.memo Asoslari: Memoizatsiya bilan Ilovani Tezlashtirish",
    "content": "React.memo bilan memoizatsiya Memoizatsiya tushunchasi va misol Memoizatsiya(Memoization) — computer science’da funksiyalarning avvalgi hisoblangan natijalarini keshda saqlash orqali ularning ishlash samaradorligini oshirish uchun qo'llaniladigan texnika. Oddiy qilib aytganda, memoizatsiya funksiyaning kirish ma'lumotlariga asoslangan holda uning natijasini saqlaydi, shuning uchun funksiya xuddi shu kirish ma'lumotlari bilan yana chaqirilsa, u hisoblangan natijani qayta hisoblash o'rniga saqlangan natijani qaytaradi. Bu, ayniqsa, hisoblashlar ko'p vaqt talab qiladigan yoki tez-tez chaqiriladigan funksiyalar uchun vaqt va resurslarni sezilarli darajada tejaydi. Memoizatsiya funksiyaning sof(pure) bo'lishiga bog'liq bo'lib, bu funksiya ma'lum bir kirish ma'lumotlari uchun doimo bir xil natijani qaytarishi kerakligini anglatadi. Masalan, sof funksiyaga misol: Ushbu funksiyasi, agar argument sifatida va kiritilgan bo'lsa, doimo ni qaytaradi, shuning uchun uni xavfsiz tarzda memoizatsiya qilish mumkin. Agar funksiya qandaydir side effect’ga, masalan, tarmoq orqali bog'lanishga bog'liq bo'lsa, u holda memoizatsiya qilish mumkin bo'lmaydi. Masalan: Agar kirish ma'lumoti bo'lsa, bu funksiya har kuni turli xil natija qaytaradi va shuning uchun uni memoizatsiya qilish mumkin emas. Bu oddiy misol bo'lsa ham, asosiy memoizatsiya tushunchasini tushunishga yordam beradi. Memoizatsiya ayniqsa murakkab hisob-kitoblar bilan shug'ullanishda yoki katta ro'yxatdagi elementlarni render qilishda foydali bo'ladi. Masalan: funksiyasini birinchi marta chaqirish bir necha daqiqa davom etishi mumkin, lekin ikkinchi, uchinchi, to'rtinchi yoki n-marta chaqirilganda bu og'ir ishlarni bajarish o'rniga saqlangan natijani qaytaradi. Bu memoizatsiyaning asosiy mazmunidir. React’da memoizatsiya React konteksida memoizatsiya funksional komponentlarga komponenti yordamida qo'llanishi mumkin. Ushbu funksiya yangi komponentni qaytaradi, u faqat props o'zgargan taqdirda qayta render qilinadi. 4-bobga asoslanib, \"qayta render qilish\" funksional komponentni qayta chaqirishni anglatishini bilamiz. Agar komponent bilan o'ralgan bo'lsa, props o'zgarmagan taqdirda uni qayta chaqirish amalga oshirilmaydi. Funksional komponentlarni memoizatsiya qilish orqali kerak bo'lmagan qayta render qilishlarning oldini olish mumkin, bu esa umumiy ishlash samaradorligini oshiradi. Biz allaqachon bilamizki, React komponentlari reconciliation jarayonida chaqiriladigan funksiyalardir. React funksional komponentlarini ularning props’i bilan rekursiv ravishda chaqirib, keyin ikki Fiber daraxti asosida foydalaniladigan vDOM daraxtini yaratadi. Ba'zan, funksional komponent jadal hisob-kitoblar yoki uni DOM’ga qo'llashda joylashtirish(placement) yoki yangilash(update) effekti natijasida render qilish uzoq vaqt olishi mumkin, 4-bobda yoritilganidek. Bu ilovaning ishlashini sekinlashtiradi va foydalanuvchiga kechikuvchi UI taqdim etadi, bu esa UX tomonidan yomon hisoblanadi. Memoizatsiya bu muammoni qimmatli hisob-kitoblar natijalarini saqlab, xuddi shu bir xil kirish qiymatlari funksiyaga yoki komponentga o'tkazilganida ularni qaytarish orqali bartaraf etish usuli hisoblanadi. Nega muhim? Keling, ning ahamiyatini tushunish uchun keng tarqalgan bir holatni ko'rib chiqamiz, bunda bizda ro'yxatdagi elementlarni komponentda render qilish kerak bo'ladi. Masalan, bizda vazifalar ro'yxati (to do list) mavjud bo'lib, uni komponentda ko'rsatish kerak, quyidagicha: Endi bu komponentni foydalanuvchi kiritishlari bo'yicha qayta render qilinadigan boshqa komponentga qo'shamiz: Bizning komponentimizda, input maydonidagi har bir klaviatura bosilishi bilan qayta render qilinadi: har bir klaviatura bosilishi bilan funksional komponenti o'z props’i bilan qayta chaqiriladi. Bu ishlash samaradorligi muammolarini keltirib chiqarishi mumkin va ehtimol, keltirib chiqaradi. Biroq, bu React’ning qanday ishlashida muhim hisoblanadi: komponentda state o'zgarishi sodir bo'lganda, daraxtda o'sha komponentdan pastdagi har bir funksional komponent reconciliation jarayonida qayta chaqiriladi. Sodda misol: vazifalar ro'yxati Agar vazifalar ro'yxati katta bo'lsa va komponent tez-tez qayta render qilinsa, bu ilovada ishlashda to'siqlar(bottleneck)ga sabab bo'lishi mumkin. Ushbu komponentni optimizatsiya qilish usullaridan biri uni yordamida memoizatsiya qilishdir: komponentini bilan o'rash orqali, React faqat props o'zgarganda komponentni qayta render qiladi. Atrofidagi state o'zgarishlari unga ta'sir qilmaydi. Bu shuni anglatadiki, agar vazifalar ro'yxati o'zgarmasa, komponent qayta render qilinmaydi va uning keshlangan natijasi ishlatiladi. Bu ayniqsa komponent murakkab bo'lsa va vazifalar ro'yxati katta bo'lsa, sezilarli darajada vaqt va resurslarni tejash imkonini beradi. Murakkab misol: Ichma-ich joylashgan komponentlar Keling, murakkab tarkibga ega, bir necha ichki komponentlarni o'z ichiga olgan, render qilish qimmatli bo'lgan boshqa bir komponentni ko'rib chiqamiz: Agar prop tez-tez o'zgaradigan bo'lsa, bu komponentni render qilish qimmatga tushishi mumkin, ayniqsa ichki komponentlar ham murakkab bo'lsa. Biz ushbu komponentni optimallashtirish uchun har bir ichki komponentni yordamida memoizatsiya qilishimiz mumkin: Har bir ichki komponentni memoizatsiya qilish orqali, React faqat o'zgargan komponentlarni qayta render qiladi va o'zgarmagan komponentlar uchun keshlangan natijalar ishlatiladi. Bu komponentining ishlashini sezilarli darajada yaxshilaydi va kerak bo'lmagan qayta render qilishlarni kamaytiradi. Shu tariqa, React’da funksional komponentlarning ishlashini optimallashtirish uchun muhim vosita ekanini ko'rish mumkin. Bu ayniqsa render qilish qimmat bo'lgan yoki murakkab logikaga ega komponentlar uchun foydalidir.",
    "url": "/books/fluent-react/common-questions/memoization-with-react-memo/page",
    "category": "books",
    "tags": [
      "fluent-react",
      "tutorial",
      "guide",
      "react",
      "javascript",
      "frontend",
      "memoizatsiya",
      "render",
      "qayta",
      "bir",
      "qilish",
      "mumkin",
      "uchun",
      "react",
      "bilan",
      "lsa",
      "komponentni",
      "funksional",
      "yoki",
      "agar",
      "orqali"
    ]
  },
  {
    "id": "book-fluent-react-common-questions-memoization-with-useMemo-page",
    "title": "useMemo Hook: React'da Og'ir Hisob-kitoblarni Memoizatsiya Qilish",
    "content": "useMemo bilan memoizatsiya qilish va ikkalasi ham memoizatsiya vositalaridir, lekin ularning ishlatilish maqsadlari tubdan farq qiladi. butun komponentni memoizatsiya qiladi, uni qayta render qilishdan saqlaydi. esa komponent ichidagi alohida hisoblashlarni memoizatsiya qiladi, murakkab hisoblashlarni oldini olish va natija uchun izchil referensni saqlab qolish uchun qo'llaniladi. useMemo’ga misol Keling, bilan qisqacha tanishamiz. Quyidagi komponentni ko'rib chiqamiz: Ushbu komponent bizning ilovamizni sekinlashtirishi mumkin, chunki unda saralash operatsiyasi mavjud. Saralash operatsiyasining vaqt murakkabligi odatda o'rtacha va eng yomon holatlarda ga teng. Agar bizda, masalan, bir million odam bo'lsa, bu har bir renderda sezilarli hisoblash yukini keltirib chiqarishi mumkin. Computer science’da saralash operatsiyasining samaradorligi asosan elementlar soni, n, bilan belgilanadi, shuning uchun vaqt murakkabligiga ega. Buni optimizatsiya qilish uchun, hook’idan foydalanib, har renderda odamlar ro'yxatini saralashning oldini olishimiz mumkin, ayniqsa massivida o'zgarishlar bo'lmaganda. Samaradorlik muammosi Komponentning joriy implementatsiyasi sezilarli darajada samaradorlik muammosini keltirib chiqaradi. Har safar state yangilanganda, ya'ni input maydonida har bir klaviatura bosilishida komponent qayta render qilinadi. Agar kiritilgan ism 5 ta belgidan iborat bo'lsa va ro'yxatimizda 1,000,000 odam bo'lsa, komponent 5 marta qayta render bo'ladi. Har bir renderda ro'yxat saralanadi, bu saralashning vaqt murakkabligi tufayli 1,000,000 × log(1,000,000) operatsiyalarni o'z ichiga oladi. Bu shunchaki 5 ta belgili ism kiritishda ko'plab millionlab operatsiyalarni amalga oshiradi! Yaxshiyamki, ushbu samarasizlikni yordamida kamaytirish mumkin, bu saralash operatsiyasi faqat massivida o'zgarishlar bo'lganda bajarilishini ta'minlaydi. Keling, ushbu kodni biroz o'zgartiraylik: Mana, endi ancha yaxshi! Biz qiymatini ning birinchi argumentiga o'tkazilgan funksiyaga o'rab qo'ydik. ga berilgan ikkinchi argument esa qiymatlar massivini ifodalaydi, agar bu qiymatlar o'zgarsa, massiv qayta saralanadi. Chunki massivda faqat bor, u faqat bir marta saralanadi va har safar odamlar ro'yxati o'zgarganda amalga oshadi — kimdur input maydonida ismni yozganda emas. Bu, dan foydalanib, keraksiz qayta renderlarni oldini olishning ajoyib misolidir.",
    "url": "/books/fluent-react/common-questions/memoization-with-useMemo/page",
    "category": "books",
    "tags": [
      "fluent-react",
      "tutorial",
      "guide",
      "react",
      "javascript",
      "frontend",
      "har",
      "000",
      "memoizatsiya",
      "qayta",
      "bir",
      "komponent",
      "uchun",
      "mumkin",
      "saralash",
      "usememo",
      "bilan",
      "qilish",
      "qiladi",
      "render",
      "oldini"
    ]
  },
  {
    "id": "book-fluent-react-common-questions-page",
    "title": "React: Keng Tarqalgan Savollar (Memoizatsiya, Lazy Loading)",
    "content": "Umumiy keng tarqalgan savollar va ularga javoblar Endi React nima qilishini va ichki ishlash mexanizmi qandayligini yaxshiroq tushunib olganimizdan so'ng, React ilovalarini yozishda uning amaliy qo'llanilishiga chuqurroq to'xtalib chiqmoqchimiz. Ushbu bobda React bo'yicha keng tarqalgan savollarga javoblarni o'rganib, memoizatsiya(memoization), kerakli paytda yuklash(lazy loading) va ishlash samaradorligi(performance) atrofidagi tushunchalarni kengaytiramiz. Keling, avvalo memoizatsiya haqida gaplashamiz.",
    "url": "/books/fluent-react/common-questions/page",
    "category": "books",
    "tags": [
      "fluent-react",
      "tutorial",
      "guide",
      "react",
      "javascript",
      "frontend",
      "react",
      "keng",
      "tarqalgan",
      "memoizatsiya",
      "savollar",
      "ishlash",
      "lazy",
      "loading",
      "umumiy",
      "ularga",
      "javoblar",
      "endi",
      "nima",
      "qilishini",
      "ichki"
    ]
  },
  {
    "id": "book-fluent-react-common-questions-usememo-considered-harmful-page",
    "title": "useMemo va useCallback: Qachon Ishlatish Kerak (va Kerak Emas)?",
    "content": "useMemo'dan ehtiyotkorlik bilan foydalaning Bir qarashda e'lon qilingan barcha o'zgaruvchilarni komponent ichida bilan o'rash jozibador ko'rinishi mumkin, lekin bu har doim ham foydali emas. asosan hisoblash jihatidan qimmatli bo'lgan operatsiyalarni memoizatsiya qilish yoki obyekt va massivlar uchun barqaror referenslarni saqlash uchun qimmatli hisoblanadi. Qator qiymatlar, masalan, string, number yoki boolean qiymatlar uchun ishlatish zarur emas. Chunki JavaScript’da bunday skalyar qiymatlar ularning haqiqiy qiymatlari orqali uzatiladi va taqqoslanadi, referens orqali emas. Shunday qilib, har safar siz skalyar qiymatni o'rnatasiz yoki taqqoslaysiz, bu haqiqiy qiymat bilan ishlashingizni anglatadi, referens bilan emas. Bunday hollarda, funksiyasini yuklash va bajarish u optimallashtirishga harakat qilayotgan amaliyotdan ko'ra ko'proq qimmatga tushishi mumkin. Misol uchun, quyidagi misolni ko'rib chiqaylik: Ushbu misolda, o'zgaruvchisi yordamida memoizatsiya qilingan. Biroq, skalyar qiymat bo'lganligi sababli, uni memoizatsiya qilish kerak emas. Buning o'rniga, biz ikkiga ko'paytirilgan hisobni to'g'ridan-to'g'ri JSX ichida hisoblashimiz mumkin: Endi, memoizatsiya qilinmaydi, lekin komponent hamon bir xil hisoblashni kamroq xotira sarflab va ortiqcha xarajatlarsiz bajaradi, chunki biz ni import qilmayapmiz va uni chaqirmayapmiz. Bu ni kerak bo'lmagan joyda ishlatmaslik uchun yaxshi misol. Ammo qo'shimcha ishlash samaradorligini keltirib chiqarishi mumkin bo'lgan narsa shuki, biz tugmasidagi ishlov beruvchi(handler) funksiyani har bir renderda qaytadan yaratmoqdamiz, chunki u xotirada referens orqali uzatiladi. Ammo bu yerda haqiqatan ham muammo bormi? Keling, buni yaxshiroq ko'rib chiqamiz. Ba'zilar da ishlov beruvchi ni yordamida memoizatsiya qilishni tavsiya qiladi: Lekin, buni qilish kerakmi? Javob - yo'q. Bu yerda funksiyasini memoizatsiya qilishdan hech qanday foyda yo'q, chunki brauzerning o'zini _native_ elementi bo'lib bo'lib, u chaqirilishi mumkin bo'lgan React funksional komponenti emas. Shuningdek, uning ostida React qayta render qilishi mumkin bo'lgan boshqa komponentlar yo'q. Bundan tashqari, React’ning o'zida mavjud bo'lgan yoki \"host\" komponentlar ( , , kabi) props (shu jumladan funksiya props’lari) bo'yicha maxsus komponentlardan bir oz farqli ravishda ishlaydi. Ichki o'rnatilgan (built-in) komponentlar uchun props’larning ishlashi Mavjud komponentlar uchun funksiyal props’lari qanday ishlashini ko'rib chiqamiz: To'g'ridan-to'g'ri uzatish Agar siz funksiya props’larini (masalan, ishlov beruvchi(handler))ni ichki o'rnatilgan komponentga uzatsangiz, React uni bevosita real DOM elementiga uzatadi. Bu funksiyalar ustida hech qanday o'ram yoki qo'shimcha ish qilinmaydi. Biroq, va boshqa event’ga asoslangan props’lar uchun, React event’larni boshqarishda event delegatsiyasidan foydalanadi, to'g'ridan-to'g'ri DOM elementlariga event ishlov beruvchilarini biriktirmaydi. Bu shuni anglatadiki, siz React’dagi kabi React’da mavjud elementga ishlov beruvchisini berganingizda, React uni bevosita button’ning DOM tuguniga biriktirmaydi. Buning o'rniga, React barcha event’larni yuqori darajada, bitta event tinglovchisi(listener)ni ishlatib, ushlaydi. Bu tinglovchi dokumentning ildiziga (yoki React ilovasining ildiziga) biriktiriladi va u individual elementlardan kelib chiqadigan event’larni ushlash uchun \"event bubbling\" hodisasiga tayanadi. Bu usul samarali bo'lib, event ishlov beruvchilarini dastlabki sozlash vaqtini va xotira hajmini qisqartiradi. Har bir element uchun event ishlov beruvchilarini alohida boshqarish o'rniga, React bitta haqiqiy event tinglovchisi yordamida barcha shu turdagi event’larni (masalan, click) boshqarishi mumkin. Event sodir bo'lganda, React uni tegishli komponentga moslab, siz belgilagan ishlov beruvchilarga chaqiradi, bu jarayon esa kutilgan propagatsiya yo'li (expected propogation path) bo'ylab amalga oshadi. Shunday qilib, event’lar yuqori darajada ushlansa-da, ular xuddi tegishli elementlarga bevosita biriktirilgandek ishlaydi. Ushbu \"event delegation\" tizimi React ilovasini yozayotganingizda asosan ko'zga tashlanmaydi; siz ishlov beruvchilarini ular to'g'ridan-to'g'ri biriktirilgandek belgilaysiz. Biroq, uning ichki ishlash mexanizmida React event’larni boshqarishni siz uchun optimizatsiya qiladi. Qayta render qilish xatti-harakati Agar ichki o'rnatilgan(built-in) komponentlar qayta render qilingan yuqori darajadagi komponentning bir qismi bo'lmasa, funksiya props’lari o'zgarganida qayta render qilinmaydi. Misol uchun, agar ota komponent qayta render bo'lib, ichki o'rnatilgan komponentga yangi funksiyani props sifatida uzatsa, ichki o'rnatilgan komponent qayta render qilinadi, chunki uning props’lari o'zgardi. Biroq, bu qayta render bo'lish odatda juda tez bo'lib, profiling’da muammo bo'lmas ekan, optimallashtirish talab qilinmaydi. Funksiyalar uchun virtual DOM taqqoslash yo'q Ichki o'rnatilgan komponentlar uchun virtual DOM taqqoslashi props’larning o'ziga asoslangan. Agar siz \"inline\" funksiyani uzatsangiz (masalan, ), har safar komponent qayta render qilinganda yangi funksiya yaratiladi, lekin React funksiyalarda o'zgarishlarni aniqlash uchun chuqur taqqoslash qilmaydi. Yangi funksiya DOM elementida eskisini almashtiradi, shuning uchun ichki o'rnatilgan komponentlarda ishlash samaradorligi ortadi. Event pooling React event handler’lar uchun event pooling’dan foydalanadi, bu esa xotiradagi ortiqcha yuklanishlarni kamaytiradi. Event pooling shuni anglatadiki, event handler’larga uzatilgan event obyekti sintetik event bo'lib, bu obyekt turli event’lar uchun qayta ishlatiladi, shu orqali chiqindi yig'ish(garbage collection) yukini kamaytiradi. Custom va host komponentlar Bu maxsus(custom) komponentlar bilan kuchli qarama-qarshilikdir. Agar siz maxsus komponentlarga yangi funksiyani prop sifatida o'tkazsangiz, bola komponenti sof(pure) komponent bo'lsa yoki memoizatsiya qo'llanilgan bo'lsa (masalan, React.memo bilan), u holda props’larda o'zgarishni sezishi sababli qayta render bo'lishi mumkin. Biroq, host komponentlar uchun React bunday ichki memoizatsiyani taqdim etmaydi, chunki bu ko'p hollarda foydasiz ortiqcha yuklama keltiradi. React natijaviy chiqargan real DOM elementlarida memoizatsiya tushunchasi yo'q; ular shunchaki xususiyatlar o'zgarganda yangi funksiya referensini yangilaydi. Amalda, siz maxsus komponentlarga yangi funksiya nusxalarini o'tkazishda ehtiyot bo'lishingiz kerak, chunki bu qimmatga tushishi mumkin, lekin ichki o'rnatilgan komponentlar bilan bunday qilish kamdan-kam muammoga olib keladi. Biroq, har doim yangi funksiyalarni yaratish va ularga o'tkazish qanchalik ko'p bo'layotganiga e'tibor berish yaxshi, chunki keraksiz funksiya yaratish chiqindilarni to'plashga olib kelishi mumkin, bu juda yuqori chastotali yangilanishlar holatlarida ishlash samaradorligi muammosi bo'lishi mumkin. Shunday qilib, bu yerda yordam bermaydi va aslida foydasizdan ham yomonroq: u nafaqat hech qanday qiymat bermaydi, balki dasturimizga ortiqcha yuklama olib keladi. Bu import qilinishi, chaqirilishi va qaramliklarni o'tkazishi kerakligini anglatadi, so'ngra funksiyaning qayta hisoblanishi kerakmi yoki yo'qligini tekshirish uchun qaramliklarni taqqoslashi kerak. Bularning barchasi ishga tushirish murakkabligini keltirib chiqarishi mumkin, bu esa dasturimizga ko'proq ziyon yetkazishi mumkin. Xo'sh, unda uchun yaxshi misol nima? , agar sizda ko'p qayta render bo'lishi mumkin bo'lgan komponent bo'lsa va siz \"callback\"ni bola komponentiga o'tkazsangiz, ayniqsa, agar bola komponenti yoki bilan optimallashtirilgan bo'lsa, juda foydalidir. Callback’ning memoizatsiya qilinishi ota komponenti render qilinganda bola komponentining keraksiz qayta render bo'lishini oldini oladi. useCallback misoli Bu yerda foydali bo'lgan misol keltirilgan: Ushbu misolda: - : bu bola komponenti bo'lib, bilan o'ralgan. Bu demak, faqat uning props’lari o'zgarganda qayta render bo'ladi. Har bir render’da yangi funksiya nusxasini o'tkazmaslik kerak. - : ikkita state’ga ega: va . - : bu ni yangilaydigan callback. Bu bilan memoizatsiya qilingan, demak ning ’i o'zgarganda komponenti qayta render bo'lmaydi. - : funksiyasi ni o'zgartiradi, lekin u yoki boshqa bolalarga o'tkazilmaydi, shuning uchun bilan memoizatsiya qilinishi shart emas. dan foydalanish orqali, boshqa sabablarga ko'ra, ya'ni bilan bog'liq bo'lmagan, qayta render bo'lganda ning keraksiz qayta render bo'lishini oldini olamiz. Bu, bolalar komponentini render qilish og'ir bo'lgan hollarda va render’lar sonini kamaytirish orqali ishlash samaradorligini optimallashtirishni xohlayotganda foydalidir. Bu dan keraksiz qayta render’larni oldini olish uchun qanday foydalanishni yaxshi misoli. Faqatgina og'ir komponentga o'tkaziladigan funksiya bir marta yaratiladi va qayta render’lar davomida bir xil manzilni saqlaydi. Bu og'ir komponentning keraksiz qayta render’larini oldini oladi. asosan funksiyalar uchun kabidir. useMemo misoli Keling, yana boshqa bir misolga qaraymiz: Bu yerda biz dan foydalanmayapmiz, asosan, komponentda state yo'q. Bu yaxshi! Lekin agar bizda quyidagicha qayta render qilishga sabab bo'ladigan bo'lsa: Endi har bir klaviatura bosishida qayta hisoblanmoqda. Keling, buni bilan to'g'irlaymiz: Bu yaxshi, chunki har bir marta komponent qayta render bo'lganda bir xil obyektga havola bo'ladi va biz komponent har doim bir kunda qayta render bo'ladi deb hisoblaymiz. <Callout type=\"info\"Agar foydalanuvchining soati yarim tun atrofida to'xtab qolsa, bu yerda bir oz muammo bor, lekin bu hozirgi paytda e'tiborga olishimiz mumkin bo'lgan kamdan-kam holatdir. Albatta, real ishlab chiqarish kodida yaxshiroq ishlarni amalga oshiramiz. </CalloutBu misol kattaroq bir savolni yuzaga keltiradi: qiymatini bilan o'rab olishimiz kerakmi? Agar shunday qilsak, nima bo'ladi? Javob shundaki, buni qilmasligimiz kerak, chunki — bu skalyar qiymat bo'lib, xotira ajratishdan boshqa hech qanday hisoblashni talab qilmaydi. Biz ni bir necha marta chaqiramiz, lekin JavaScript dvigateli va React runtime’lari bularni biz uchun yanada samaraliroq ishlatishiga ishonamiz. Bu bir oddiy \"assignment\" bo'lib, boshqa hisoblashlar, masalan, saralash, filtr yoki \"mapping\"lar yo'q. Ushbu holatda useMemo’dan foydalanish to'g'rimi? Ushbu holatda, dan foydalanmaslik kerak, chunki u ilovamizni tezlashtirishdan ko'ra sekinlashtirish ehtimoli ko'proq, chunki o'zini ishlatishdan kelib chiqadigan ortiqcha yuk, shu jumladan import qilish, chaqirish, qaramliklarni o'tkazish va keyin qiymatni qayta hisoblash kerakmi yoki yo'qligini taqqoslash bilan bog'liq. Bularning barchasi ishga tushirish murakkabligini keltirib chiqarishi mumkin, bu esa dasturimizga ko'proq ziyon yetkazishi mumkin. O'rniga, React’ga tayinlaymiz va kerak bo'lganda, o'z optimizatsiyalari bilan komponentimizni aql bilan qayta render qilishiga ishonamiz. Hozirgi vaqtda ilovalarimiz og'ir hisoblashlar mavjud bo'lsa ham tezroq qayta render qilish foydasiga ega, lekin bundan tashqari ko'proq narsalar qila olamizmi? Keyingi mavzuda, biz hozirgacha ko'rgan narsalar bir necha yildan keyin ahamiyatsiz bo'lishi mumkinligini ko'rib chiqamiz, chunki React jamoasi avtomatik ravishda memoizatsiyani ko'rib chiqish ustida ishlamoqda, bu esa bizga ortiqcha tafsilotlarni unutishga imkon beradi va o'z ilovalarimizga e'tibor berishimizga yordam beradi.",
    "url": "/books/fluent-react/common-questions/usememo-considered-harmful/page",
    "category": "books",
    "tags": [
      "fluent-react",
      "tutorial",
      "guide",
      "react",
      "javascript",
      "frontend",
      "qayta",
      "render",
      "uchun",
      "event",
      "react",
      "bir",
      "bilan",
      "mumkin",
      "chunki",
      "yoki",
      "props",
      "memoizatsiya",
      "lekin",
      "har",
      "siz"
    ]
  },
  {
    "id": "book-fluent-react-common-questions-usestate-vs-usereducer-page",
    "title": "useState vs useReducer: React'da State'ni Qanday Boshqarish Kerak?",
    "content": "useState va useReducer React state’ni boshqarish uchun mo'ljallangan ikkita hook’larni taklif etadi: va . Ikkalasi ham komponentda state’ni boshqarish uchun ishlatiladi. Farqi shundaki, birgina state’ni boshqarishga yaxshiroq mos kelsa, murakkabroq state’ni boshqarish uchun ishlatiladi. Keling, bilan komponentda state’ni boshqarish usulini ko'rib chiqaylik: Ushbu misolda, biz dan foydalanib bitta state’ni boshqaryapmiz: . Ammo, agar bizning state’imiz biroz murakkabroq bo'lsa-chi? Endi ko'rib turibmizki, bizdagi state’lar biroz murakkabroq. Bizda , , va mavjud. Tugmani bosish orqali hisobni oshiramiz, bu esa state’ni eski qiymatlar bilan bir xil bo'lgan yangi obyektga o'rnatadi, faqat birga oshirilgan bo'ladi. Bu React’da juda keng tarqalgan amaliyot. Ammo, bu usulda xatolik yuzaga kelishi mumkin, masalan, agar eski state’ni diqqat bilan \"spread\" qilmasak, ba'zi xususiyatlar noto'g'ri o'zgartirilishi mumkin. useState ham useReducer’dan foydalanadi ichida aslida ishlatiladi. ni ning yuqori darajadagi abstraksiyasi deb hisoblash mumkin. Hatto, istasangiz, ni yordamida qayta yaratishingiz mumkin: Keling, shu misolni yordamida qanday amalga oshirishni ko'rib chiqaylik: Ba’zilar bu usulda kod ga qaraganda bir oz ortiqcha cho'zilib ketishini aytadilar va ko'pchilik bunga qo'shiladi, lekin bu abstraksiyalarni pastroq darajada ishlatishda odatiy hol: abstraksiya qanchalik past bo'lsa, kod shunchalik batafsilroq bo'ladi. Abstraksiyalar odatda murakkab logikani oddiyroq sintaksis bilan almashtirish uchun mo'ljallangan, bular ya'na _syntactic sugar_ ham deb ataladi. Nima uchun useReducer ishlatish foydali? Tabiiyki bir savol tug'ilishi mumkin, xo'sh, agar biz yordamida bilan bir xil narsani qiloladigan bo'lsak, nima uchun har doim ni ishlatmaymiz, axir u oddiyroq-ku? dan foydalanishning uchta katta afzalligi mavjud: 1. Logikani komponentdan ajratadi U yangilanish holati logika qismnini komponentdan ajratadi. Uning qo'shimcha qilib berilgan funksiyasi alohida holatda test qilinishi mumkin va uni boshqa komponentlarda qayta ishlatish mumkin. Bu bizning komponentlarimizni toza va oddiy saqlash hamda yagona ma'suliyat tamoyili(single responsibility principle)ni qo'llashning ajoyib usulidir Biz reducer funksiyasini quyidagicha test qilishimiz mumkin: Ushbu misolda biz ikki ssenariy holatida test qilmoqdamiz: biri increment harakati reducer’ga uzatilganda, ikkinchisi esa noma'lum harakat yuborilganda. Birinchi testda biz qiymati bo'lgan boshlang'ich state obyektini va increment harakati obyektini yaratmoqdamiz. Shundan keyin biz qiymatining natijaviy state’da ga oshirilishini kutmoqdamiz. Buning uchun matcher(ya'ni moslashtiruvchi)’idan foydalanib, kutilayotgan va asl state obyektlarini taqqoslaymiz. Ikkinchi testda esa qiymati bo'lgan boshlang'ich state obyektini va noma’lum harakat obyektini yaratmoqdamiz. Keyin biz natijaviy state’ning boshlang'ich state obyektiga teng bo'lishini kutmoqdamiz. Buning uchun matcher’idan foydalanib, kutilayotgan va asl state obyektlarini taqqoslaymiz, chunki biz havolali tenglikni test qilyapmiz. funksiyasini shu tarzda test qilish orqali biz uning to'g'ri ishlashini va turli kirish holatlarida kutilgan natijani ishlab chiqarishini ta’minlashimiz mumkin. 2. State va uning o'zgarishlari aniq ko'rinadi bilan bizning state va uning qanday o'zgarishi doim aniq ko'rinib turadi, va ba'zilar JSX daraxti qatlamlari orqali komponentning umumiy state’ini yangilash oqimini noaniq qilib qo'yishi mumkinligini ta'kidlashadi. 3. Event’ga asoslangan modelni yaratadi bu voqealarga asoslangan (event sourced) model bo'lib, bizning dasturimizda sodir bo'lgan event’larni modellashtirish uchun ishlatilishi mumkin, bu event’larni audit log turidagi ro'yxatga yozib borishimiz mumkin. Ushbu audit log dasturimizdagi event’larni qayta ijro etish, xatolarni takrorlash yoki vaqt bo'yicha orqaga siljish orqali xatolarni tuzatish uchun ishlatilishi mumkin. Bundan tashqari, kuchli pattern’lar, masalan, bekor qilish/qaytarish, optimistik yangilanishlar va interfeysimizdagi umumiy foydalanuvchi harakatlarini kuzatish kabi imkoniyatlarni taqdim etadi. Qachon qay birini ishlatgan ma'qul qulay vosita bo'lsa-da, uni har doim ishlatish shart emas. Aslida, ko'pincha uni ishlatish ortiqcha bo'lishi mumkin. Shunday ekan, qachon ni va qachon ni ishlatish kerak? Javob sizning state’ingizning murakkabligiga bog'liq. Lekin umid qilamizki, barcha ushbu ma'lumotlar bilan siz qaysi biri sizning dasturingizda ishlatilishi kerakligi haqida ko'proq tushunchaga ega bo'lasiz.",
    "url": "/books/fluent-react/common-questions/usestate-vs-usereducer/page",
    "category": "books",
    "tags": [
      "fluent-react",
      "tutorial",
      "guide",
      "react",
      "javascript",
      "frontend",
      "state",
      "mumkin",
      "uchun",
      "biz",
      "bilan",
      "boshqarish",
      "ishlatish",
      "test",
      "event",
      "usereducer",
      "larni",
      "ushbu",
      "bizning",
      "orqali",
      "bir"
    ]
  },
  {
    "id": "book-fluent-react-concurrent-react-page",
    "title": "React Concurrent Rejimiga Kirish: Samaradorlikning Yangi Davri",
    "content": "React’ning concurrent rejimi Oldingi bobda biz React yordamida server tomonida render qilish olamiga chuqur sho'ng'idik. Ilovalarimizning ishlash tezligini va foydalanuvchi bilan ishlash qulayligini yaxshilash uchun server tomonida render qilishning qanchalik muhimligini, ayniqsa zamonaviy veb-ishlab chiqish kontekstida o'rgandik. va kabi turli server tomonida render qilish API’larini o'rganib chiqdik hamda ularning foydalanish holatlari va afzalliklarini muhokama qildik. Shuningdek, server tomonida render qilishni joriy qilishdagi qiyinchiliklarga to'xtaldik va bu jarayonning murakkabliklarini hal qilishda Next.js va Remix kabi mavjud freymvorklarga tayangan ma'qul ekanligini ko'rsatdik. Hidratsiya tushunchasini va uning serverda yaratilgan HTML kodini klient tomoni React komponentlari bilan bog'lab, muammosiz foydalanuvchi bilan ishlash qulayligini yaratishdagi ahamiyatini ko'rib chiqdik. Bundan tashqari, bir nechta klient ulanishlarini boshqarishda paydo bo'ladigan xavfsizlik muammolari va qiyinchiliklarni muhokama qildik hamda bu muammolarni samarali hal qilish uchun freymvorklardan foydalanish zarurligini ta'kidladik. Endi biz concurrent React (bir vaqtning o'zida bajariluvchi React) mavzusiga o'tib, ilgari o'rgangan bilimlarimizni yanada kengaytiramiz. Fiber reconciler haqida bilib olamiz va React’ning bir vaqtning o'zida bajariladigan imkoniyatlari, shuningdek, yangilanishlar va render qilishni qanday samarali boshqarishi haqida tushuncha hosil qilamiz. Rejalashtirish, yangilanishlarni kechiktirish va renderlanish yo'llari kabi mavzularni o'rganish orqali React’ning asosiy arxitekturasi orqali yaratilgan ishlash optimizatsiya yo'llaridan xabardor bo'lamiz. <Callout type=\"info\"Shuni yana bir bor ta'kidlash joizki, Fiber o'zi va biz muhokama qilayotgan barcha narsalar React’ning kelajakda o'zgarishi mumkin bo'lgan implementatsiyaviy tafsilotlardir. React’dan samarali foydalanish uchun ushbu bilimlar shart emas, ammo asosiy mexanizmlarni o'rganish React qanday ishlashini yaxshiroq tushunishingizga va undan samarali foydalanishingizga yordam beradi hamda sizni umuman muhandis sifatida bilimdonroq qiladi. </CalloutShunday qilib, bilimlarimizni kengaytirishda davom etib, yuqori samaradorlikka ega ilovalarni yaratish uchun React imkoniyatlaridan foydalanishning yangi usullarini o'rganish maqsadida concurrent React olamiga qiziqarli sayohatni boshlaymiz.",
    "url": "/books/fluent-react/concurrent-react/page",
    "category": "books",
    "tags": [
      "fluent-react",
      "tutorial",
      "guide",
      "react",
      "javascript",
      "frontend",
      "react",
      "render",
      "ning",
      "concurrent",
      "server",
      "tomonida",
      "ishlash",
      "uchun",
      "bir",
      "samarali",
      "biz",
      "qilish",
      "bilan",
      "kabi",
      "hamda"
    ]
  },
  {
    "id": "book-fluent-react-concurrent-react-problem-with-synchronous-rendering-page",
    "title": "React'da Sinxron Renderlash: Muammo va Concurrent Yechimi",
    "content": "Sinxron render qilish bilan bog'liq muammo Qayta eslab olish uchun, sinxron render qilishdagi muammo shundaki, bu asosiy thread’ga to'sqinlik qiladi, natijada foydalanuvchi bilan ishlash qulayligiga salbiy ta'sir qilishi mumkin. Bu ayniqsa ko'p komponentli va tez-tez yangilanadigan murakkab ilovalar uchun juda dolzarbdir. Bunday holatlarda, foydalanuvchi interfeysi javobsiz bo'lib qolishi mumkin, bu esa foydalanuvchini hafsalasini pir qilishi mumkin. Ushbu muammoni bartaraf etish uchun odatiy bir yechim – bu yangilanishlar seriyasini to'plab, asosiy thread’dagi ishlashni minimallashtirish: masalan, 10 ta narsani 10 marta qayta ishlash o'rniga, ularni to'plab bir marta qayta ishlash. Biz 4-bobda guruhlab yangilash(batching update) haqida gaplashgan edik, shuning uchun bu yerda ko'p tafsilotlarga to'xtab o'tirmaymiz. Ammo bizning muhokamamiz uchun tushunish muhimki, guruhlab yangilash bu muammolarga qarshi vaqtinchalik yechimdir va u ham o'ziga xos cheklovlarga ega, buni kelgusi mavzularda ko'rib chiqamiz. Guruhlab yangilash(batching update) muammolari Hatto guruhlab yangilash bilan ham bog'liq bo'lgan muammolar, sinxron render qilishda ustuvorlik tushunchasi mavjud emasligi bilan yanada murakkablashadi. Sinxron render qilish barcha yangilanishlarga bir xil yondashadi, ularning ko'rinishidan qat'i nazar. Masalan, sinxron render qilish bilan siz asosiy thread’ga foydalanuvchi ko'ra olmaydigan narsalarni (masalan, ko'rinmayotgan qism yoki modal oynaning ortidagi kontent yoki yuklanayotgan holatda bo'lgan kontent) render qilish ishlari bilan to'sqinlik qilishingiz mumkin. Siz bunday elementlarni render qilmoqchisiz, agar protsessor imkoniyati bo'lsa, lekin foydalanuvchi ko'ra oladigan va u bilan muloqotda bo'ladigan narsalarni ustuvorlik bilan render qilishingiz kerak. React concurrent (bir vaqtda bajariluvchi) funksiyalari mavjud bo'lishidan oldin, ko'pincha muhim yangilanishlar kam ahamiyatli yangilanishlar bilan to'sib qo'yilgan holatlar bo'lar edi, bu esa, albatta, foydalanuvchi bilan ishlash qulayligini yomonlashtirishga olib kelardi. Concurrent renderlashning afzalligi Concurrent render qilish bilan React yangilanishlarni ularning ahamiyati va shoshilinchligiga qarab ustuvorlik bilan bajarishi mumkin, bu esa muhim yangilanishlarning kamroq ahamiyatli yangilanishlar tomonidan to'sib qo'yilmasligini ta'minlaydi. Bu React’ga katta yuklama ostida ham javob bera oladigan foydalanuvchi interfeysini saqlab qolishga imkon beradi va yaxshiroq foydalanuvchi bilan ishlash qulayligini yaratadi. Masalan, foydalanuvchi tugmani bosganda yoki uning ustiga olib borganida, bu harakatga darhol javob qaytarilishini kutadi. Agar React uzun ro'yxatni qayta render qilish bilan band bo'lsa, unda bu tugma ustidagi harakat yoki aktiv holat \"feedback\"i butun ro'yxat tugagunga qadar kechiktiriladi. Concurrent render qilish bilan protsessor resurslarini ko'proq talab qiladigan render qilish vazifalari yanada muhimroq bo'lgan foydalanuvchi interaktivligi va animatsiyalar kabi vazifalarga ko'proq ustuvorlik beradi. Bundan tashqari, concurrent render qilish imkoniyatlari bilan React vaqtni taqsimlab ishlashga qodir: ya'ni, u render qilish jarayonini kichik bo'laklarga bo'lib, ularni bosqichma-bosqich qayta ishlay oladi. Bu React’ga bir nechta kadr davomida ishlashni amalga oshirishga imkon beradi va agar ishni to'xtatish kerak bo'lsa, u to'xtatilishi mumkin. Keling, bularning barchasini batafsil o'rganishni endi boshlaymiz.",
    "url": "/books/fluent-react/concurrent-react/problem-with-synchronous-rendering/page",
    "category": "books",
    "tags": [
      "fluent-react",
      "tutorial",
      "guide",
      "react",
      "javascript",
      "frontend",
      "bilan",
      "render",
      "qilish",
      "foydalanuvchi",
      "react",
      "sinxron",
      "mumkin",
      "concurrent",
      "qayta",
      "uchun",
      "ishlash",
      "bir",
      "yangilanishlar",
      "masalan",
      "guruhlab"
    ]
  },
  {
    "id": "book-fluent-react-concurrent-react-problems-with-concurrent-rendering-page",
    "title": "React Concurrent Rendering: Tearing (Vizual Nomuvofiqlik) Muammosi",
    "content": "Concurrent renderingdagi muammolar Concurrent(bir vaqtda) renderlash foydalanuvchilarning samarali va tezkor javob beruvchan interaktivligiga ruxsat etish bilan birga, dasturchilar uchun yangi muammolarni keltirib chiqaradi. Asosiy muammo shundaki, yangilanishlarning qaysi tartibda ishlov berilishini tushunish qiyin, bu esa kutilmagan xatti-harakatlar va xatolarga olib kelishi mumkin. Bunday xatolardan biri _tearing_ (vizual nomuvofiqlik) deb nomlanadi, bunda UI bir tekis bo'lmagan holatga keladi, chunki yangilanishlarga tartibsiz ishlov beriladi. Bu xususan, komponent hali renderlash jarayonida bo'lganida ba'zi qiymatlar yangilansa, yuzaga kelishi mumkin. Natijada, ilovalar mos kelmaydigan ma'lumotlar bilan render qilinishi mumkin. Keling, bu masalani yanada chuqurroq tushunib chiqaylik. Tearing muammosi Tearing bu xatolik bo'lib, u komponent ma'lum bir state’ga bog'liq bo'lganda, lekin shu vaqtda ilova hali renderlash jarayonida bo'lsa yuzaga keladi. Keling, bu xatoni tushunishlik uchun sinxron va concurrent renderlashni taqqoslab ko'raylik. Sinxron dunyoda, React komponentlar daraxtini yuqoridan pastga birma-bir renderlashda davom etadi, bu esa ilovaning holati butun renderlash jarayonida izchil bo'lishini ta'minlaydi, chunki har bir komponent oxirgi holat bilan render qilinadi. Ushbu misolni ko'rib chiqamiz: Tearing’ni sababi Dasturimizning yuqori qismida bizda o'zgaruvchisi mavjud: bu o'zgaruvchini global darajada o'rnatib, orqali React’ning render qilish siklidagina emas, balki tashqaridan doimiy yangilab turamiz. Shu tarzda, dastur ishlayotgan paytda yangilanishlar jarayonida _tearing_ xatosini simulyatsiya qilishga erishamiz. Renderlash jarayoni bir vaqtning o'zida bajariladigan va to'xtatilishi mumkin bo'lgani sababli, bir necha xil qiymatlari bilan render qilinishi va foydalanuvchiga mos kelmaydigan ma'lumot ko'rsatilishi yoki _tearing_ xatosi sodir bo'lishi mumkin. ichida ning mos kelmaydigan qiymatlari paydo bo'lishini kutamiz, chunki React foydalanuvchi kiritmalariga javob berish uchun render qilish jarayonini \"to'xtatib\", yanada dolzarb yangilanishga, masalan, matn kiritish maydonini yangilashga ustuvorlik beradi. Bu esa ba'zi holatlarda da ning eskirgan qiymatini qoldirishi mumkin. Ushbu misolda matn kiritish maydoni va 5 ta ro'yxatini render qilamiz. Bu komponentlar ataylab memoizatsiya qilinmagan, chunki bu yerda ishlash samaradorligi muammolarini ko'rsatish uchun kerak. Tushuntirish maqsadida _tearing_ muammosini aniqlash uchun bu muammolar muhimdir. Real hayotda siz ni bilan o'rab qo'yishingiz mumkin, ammo bu yerda dasturdagi tearingni namoyish qilish uchun buni ataylab bajarmayapmiz. render qilish uchun uzoq vaqt oladi va hisoblash jihatdan murakkab jarayonni simulyatsiya qiladi. shuningdek, har bir millisekundda yangilanadigan o'zgaruvchisining joriy qiymatini ko'rsatadi va bu qiymat tashqi store’dan, ya'ni global namespace’dan o'qiladi. da tearing hodisasi Agar ushbu misolni ishga tushirsak, biz render qiladigan ning beshta nusxasi uchun input’da kiritilgan bir necha tugmalarni yozganimizdan so'ng, komponentining uchun turli qiymatlar bilan renderlashini ko'ramiz. Buning sababi, besh marta render qilinadi va har safar render qilinganda hisoblash qiymati boshqacha bo'ladi. React komponentlarni bir vaqtning o'zida render qilayotganligi sababli, komponenti uchun turli qiymatlar bilan render qilinishi mumkin, natijada foydalanuvchiga mos kelmaydigan ma'lumotlar ko'rsatiladi. Bu holat _tearing_ deb ataladi va komponent dasturni renderlash davomida yangilanayotgan biror state’ga bog'liq bo'lganda yuzaga keladigan xatodir. Bu misolda o'zgaruvchisiga bog'liq va komponent hali renderlanayotgan paytda yangilanib, ilovaning nomuvofiq ma'lumot bilan renderlanishiga sabab bo'ladi. _Tearing_ hodisasi sababli, beshta nusxasi uchun quyidagi chiqish natijalarini ko'ramiz: - - - - - Bunday bo'lishi tabiiy holat, chunki komponentning oldingi nusxalari renderlanadi, ning yangilangan qiymati tozalanadi/DOMga biriktiriladi va keyingi nusxalar yangi qiymatlari bilan render qilinishi va uzatilishi (tozalanishi, yangilanishi) davom etadi. Bu katta muammo emas, chunki React oxir-oqibat mos keluvchi state’ni renderlaydi. Asosiy muammo quyidagi kabi misollarda yuzaga keladi: Agar kod shunday bo'lsa va renderlar orasida foydalanuvchi global xotiradan o'chirilsa, bu xato albatta foydalanuvchini hayratga solishi mumkin. Mana shu sababli _tearing_ muammo hisoblanadi. Tearing muammosini hal qilish _Tearing_ muammosini hal qilish uchun, React deb nomlangan hook’ni taqdim etadi. Keling, ushbu hook’ni batafsil o'rganamiz.",
    "url": "/books/fluent-react/concurrent-react/problems-with-concurrent-rendering/page",
    "category": "books",
    "tags": [
      "fluent-react",
      "tutorial",
      "guide",
      "react",
      "javascript",
      "frontend",
      "render",
      "uchun",
      "bir",
      "bilan",
      "mumkin",
      "_tearing_",
      "react",
      "renderlash",
      "chunki",
      "tearing",
      "qilish",
      "komponent",
      "mos",
      "ning",
      "concurrent"
    ]
  },
  {
    "id": "book-fluent-react-concurrent-react-recap-page",
    "title": "Concurrent React Xulosasi: Fiber, Lanes, useTransition va Boshqalar",
    "content": "Bo'limni qisqacha takrorlash Ushbu keng qamrovli suhbat concurrent React haqida chuqur o'rganish bilan bog'liq bo'lib, Fiber reconciler, scheduler(rejalashtiruvchi), yangilanishlarni kechiktirish(defer updates), render yo'llari va yangi hook’lar, masalan, va kabi ko'p jihatlarni qamrab oldi. Biz Fiber reconciler haqida gaplashishdan boshladik, bu React’ning concurrent rendering mexanizmining yuragidir. Bu algoritm freymvorkning kichik ish birliklariga bo'lish va bajarish ustuvorligini boshqarish imkoniyatini ta'minlaydi, bu esa React’ga \"to'xtatib bo'ladigan\" va concurrent renderingni qo'llab-quvvatlash imkonini beradi. Bu React’ga murakkab va yuqori samarali ilovalarni silliq ravishda boshqarish qobiliyatiga katta hissa qo'shadi, foydalanuvchi interaktivligi og'ir hisob-kitoblar davomida ham javobgar bo'lishini ta'minlaydi. Keyin, rejalashtirish va yangilanishlarni kechiktirish tushunchasiga o'tdik. Bu asosan React’ga ma'lum state yangilanishlarini boshqalariga nisbatan ustuvorlik qo'yishga imkon beradi. React past ustuvorlikdagi yangilanishlarni yuqori ustuvorlikdagilarni afzal ko'rgan holda kechiktirishi mumkin, shuning uchun katta yuklama ostida ham silliq foydalanuvchi bilan ishlash qulayligini saqlab qoladi. Misol sifatida, kelayotgan xabar yangilanishlari intuitiv ravishda rejalashtirilgan va UI’ni blok qilmasdan render qilingan chat ilovasi keltirildi. Suhbat keyingi bosqichda render yo'llari(lanes), ya'ni React’ning concurrent xususiyatlaridagi markaziy tushuncha haqida bo'ldi. Render yo'llari — bu React’ning yangilanishlarga ustuvorlik berish va ularning bajarilishini samarali boshqarish uchun ishlatadigan mexanizmdir. Bu, React qanday yangilanishlarning zaruriy ekanini va darhol qayta ishlanishi kerakligini, qaysilarini esa keyinroqqa kechiktirilishi mumkinligini aniqlashning siridir. Tafsilotlarda, bu render yo'llari ko'p ustuvorliklarni samarali boshqarish uchun _bitmasking_ usulidan qanday foydalanishligi haqida ta'kidlab o'tildi. Keyin esa, React’da concurrent operatsiyalar uchun joriy etilgan yangi hook’lar — va haqida muhokama qildik. Bu hook’lar o'zgarishlarni boshqarish va vaqtni talab qiluvchi operatsiyalar uchun yanada silliq foydalanuvchi bilan ishlash qulayligini ta’minlashga mo'ljallangan. Birinchi navbatda hook’i muhokama qilindi. Bu hook React’ga state’lar o'rtasida o'tishga imkon beradi va hatto yangi state tayyorlanishi uzoq vaqt oladigan bo'lsa ham, foydalanuvchi interfeysining tezkor javob beruvchan bo'lib qolishini kafolatlaydi. Boshqacha qilib aytganda, agar komponent hozirda render qilinayotgan bo'lsa, yangilanishni keyingi render sikliga kechiktirishga imkon beradi. Shuningdek, hook’i haqida ham gapirdik. Bu hook komponentning kam muhim qismlarining yangilanishini kechiktiradi, shunday qilib noqulay foydalanuvchi bilan ishlash qulayligini oldini oladi. Aslida, bu React’ga yangi qiymat juda ko'p vaqt oladigan bo'lsa, avvalgi qiymatni bir oz uzoqroq ushlab turish imkonini beradi. Nihoyat, biz concurrent’lik bilan bog'liq muammolarni, shu jumladan _tearing_ (vizual nomuvofiqlik) muammosini ko'rib chiqdik va qanday qilib bir vaqtning o'zida bir nechta renderlar o'rtasida state’ni izchil saqlashga yordam berishini o'rgandik. Suhbat davomida takrorlanuvchi mavzu React’ning murakkab, dinamik ilovalarni og'ir hisoblash bilan boshqarish strategiyalarining \"nima\" va \"nega\"larini tushunish edi. Shuningdek, dasturchilar bu strategiyalarni qanday qilib foydalanuvchi bilan ishlash qulayligini silliq va tezkor javob beruvchi qilish uchun qo'llashlari mumkinligini ko'rsatdi. Takrorlash uchun savollar Ushbu bobda o'rganilgan tushunchalarni sinab ko'rish uchun o'zimizga bir nechta savollar beramiz: 1. _Fiber reconciler nima va u React’da murakkab, yuqori samarali ilovalarni boshqarishga qanday yordam beradi?_ 2. _React’da yangilanishlarni rejalashtirish va kechiktirish tushunchasi qanday? Bu katta yuklama ostida silliq foydalanuvchi bilan ishlash qulayligini qanday saqlashga yordam beradi?_ 3. _React’da render yo'llari nima va ular yangilanishlarning ijrosini qanday boshqaradi? Bir nechta ustuvorliklarni boshqarish uchun render yo'llari qanday bitmasking’dan foydalanadi?_ 4. _ va hook'larining maqsadi nima? Har bir hook qanday vaziyatda foydali bo'lishini tavsiflang_. 5. _ dan foydalanish nojo'ya bo'lgan vaziyatlar qachon bo'lishi mumkin? Bu hook’lardan foydalanish bilan bog'liq bo'lgan ayrim afzallik va kamchiliklar nima?_ Keyingi bo'lim Endi siz React’ning concurrent xususiyatlari va uning ichki ishlashini chuqur tushunishingiz bilan, yuqori samarali ilovalarni qurishda uning to'liq potensialidan foydalanishga tayyorsiz. Endi biz keyingi bobda, Next.js va Remix kabi React ustiga qurilgan turli mashhur freymvorklarni o'rganamiz, bu esa ishalb chiqish jarayonini yanada soddalashtiradi, eng yaxshi amaliyotlar, konvensiyalar va qo'shimcha qulaylik va xususiyatlarni taqdim etadi. Ushbu freymvorklar murakkab ilovalarni oson qurishga yordam berishi uchun mo'ljallangan, server rendering, routing va kodlarni bo'lib yuklash kabi ko'plab umumiy muammolarni hal qiladi. Ushbu freymvorklar kuchidan foydalanib, siz ilovangizning funksiyalarini va imkoniyatlarini qurishga e'tibor qaratishingiz mumkin, shu bilan birga optimal ishlash samaradorligi va foydalanuvchi bilan ishlash qulayligini ta'minlay olasiz. Ushbu kuchli freymvorklar haqida chuqurroq o'rganish va React va uning ekotizimi yordamida kengaytiriladigan, samarali va funksional ilovalarni qanday qurishni o'rganish uchun tayyorlaning.",
    "url": "/books/fluent-react/concurrent-react/recap/page",
    "category": "books",
    "tags": [
      "fluent-react",
      "tutorial",
      "guide",
      "react",
      "javascript",
      "frontend",
      "react",
      "bilan",
      "uchun",
      "qanday",
      "hook",
      "render",
      "concurrent",
      "foydalanuvchi",
      "haqida",
      "boshqarish",
      "beradi",
      "ishlash",
      "llari",
      "samarali",
      "ilovalarni"
    ]
  },
  {
    "id": "book-fluent-react-concurrent-react-render-lanes-page",
    "title": "React'da Render Lanes (render yo'llari): Yangilanishlar Ustuvorligi Qanday Ishlaydi?",
    "content": "Render yo'llari (Render Lanes) Render yo'llari React'ning rejalashtirish tizimining muhim qismidir, bu tizim samarali render qilish va vazifalarning ustuvorligini ta'minlaydi. Render yo'li - bu bir ustuvorlik darajasini ifodalovchi ish birligi bo'lib, u React tomonidan renderlash sikli davomida ishlov berilishi mumkin. Render yo'llari tushunchasi React 18 versiyasida joriy qilingan bo'lib, u amal qilish muddatini ishlatgan oldingi rejalashtirish mexanizmi o'rnini egalladi. Keling, render yo'llarini, ularning ishlashini va bitmasklari sifatida ifodalangan asosiy tuzilmasini batafsil ko'rib chiqamiz. <Callout type=\"info\"Yana bir bor ta'kidlaymiz, bu React’ning istalgan vaqtda o'zgarishi mumkin bo'lgan ichki dasturiy tafsilotlari hisoblanadi. Bu yerda asosiy maqsad asosiy mexanizmni tushunish bo'lib, bu bizning kundalik injinerlik ishimizda yordam beradi va React qanday ishlashini tushunishga yordam beradi hamda undan samarali foydalanishimizni ta'minlaydi. Tafsilotlarga qadalib qolmaslik va aksincha, mexanizm va uning haqiqiy dunyodagi qo'llanilish imkoniyatlariga e'tibor qaratish foydaliroq bo'ladi. </CalloutBirinchidan, render yo'li bu React tomonidan renderlash jarayonida amalga oshirilishi kerak bo'lgan yangilanishlarni tartibga solish va ustuvorlik qilish uchun ishlatiladigan yengil abstraksiyadir. Masalan, funksiyasi chaqirilganda, ushbu yangilanish render yo'liga qo'shiladi. Turli ustuvorlik darajalarini yangilanishlarning kontekstiga qarab tushunishimiz mumkin: - Agar click ishlov beruvchisida chaqirilsa, u Sync (eng yuqori ustuvorlik) yo'liga qo'yiladi va mikrotask navbatiga rejalashtiriladi. - Agar useTransition hook’idan keladigan funksiyasi ichida chaqirilsa, u transition (quyi ustuvorlik) yo'liga qo'yiladi va mikrotask navbatida rejalashtiriladi. Render yo'llaridagi ustuvorliklar Har bir yo'l o'ziga xos ustuvorlik darajasiga ega bo'lib, yuqori ustuvorlikka ega yo'llar past ustuvorlikdagi yo'llardan oldin ishlanadi. React'dagi ba'zi yo'llarga misollar: - : Foydalanuvchilar hidratsiya paytida React ilovasida biror narsani bosganida, ya'ni click qilganida, click hodisasi ushbu yo'lga joylanadi. - : Foydalanuvchilar React ilovasida bosganda, click hodisasi ushbu yo'lga joylanadi. - : Hover hodisalari, skroll hodisalari va hidratsiya davomida boshqa davomiy hodisalar ushbu yo'lga joylanadi. - : Avvalgi bilan bir xil, lekin React ilovasi hidratsiya qilinganidan keyin. - : Tarmoqdan olingan yangilanishlar, kabi taymerlar va ustuvorlik aniqlanmagan dastlabki render ushbu yo'lga joylanadi. - : hidratsiya davomida dan har qanday transition’lar ushbu yo'lga joylanadi. - (1–15): hidratsiyadan keyin dan har qanday transition’lar ushbu yo'llarga joylanadi. - (1–4): Har qanday Suspense qayta urinishlari ushbu yo'llarga joylanadi. E'tibor bering, bu yo'llar yozish paytidagi React’ning ichki tuzilmasini ifodalaydi va o'zgarishi ham mumkin. Bizning asosiy maqsadimiz - React qanday ishlashini tushunish uchun mexanizmni tushunishdir, shuning uchun yo'llarning aniq nomlari muhim emas. Muhim tomoni - React bu tushunchani qanday qo'llaydi va uni o'z ishimizda qanday qo'llashimiz mumkinligini tushunishdir. Render yo'llari qanday ishlaydi React qachonki bir komponent yangilansa yoki render daraxtiga yangi komponent qo'shilsa, yangilanishga ustuvorligiga qarab yo'l (lane) belgilaydi, bu esa avval aytib o'tilgan render yo'llari asosida amalga oshiriladi. Ustuvorlik yangilanish turiga (masalan, foydalanuvchi interaktivligi, ma'lumot olish yoki orqa fondagi vazifalar) va boshqa omillarga, masalan, komponentning ko'rinishiga qarab belgilanadi. React keyinchalik yangilanishlarni rejalashtirish va ustuvorlik qilish uchun render yo'llaridan quyidagi tartibda foydalanadi: 1. Yangilanishlarni yig'ish: React so'nggi renderlashdan buyon rejalashtirilgan barcha yangilanishlarni yig'adi va ularni ustuvorligiga qarab tegishli yo'llarga belgilaydi. 2. Yo'llarni qayta ishlash: React yangilanishlarni o'z yo'llarida ustuvorlik bo'yicha qayta ishlaydi, bu jarayon eng yuqori ustuvorlikdagi yo'l bilan boshlanadi. Bir xil yo'lda joylashgan yangilanishlar bitta o'tishda guruhlanib qayta ishlanadi. 3. Commit bosqichi: Barcha yangilanishlar qayta ishlangandan so'ng, React commit bosqichiga kiradi, bu bosqichda o'zgarishlar DOM’ga qo'llaniladi, effektlar ishlatiladi va boshqa yakuniy vazifalar bajariladi. 4. Takrorlash: Har bir render uchun jarayon takrorlanadi, bu esa yangilanishlarning har doim ustuvorlik tartibida qayta ishlanishini va yuqori ustuvorlikdagi yangilanishlarning pastroq ustuvorlikdagi yangilanishlar tomonidan to'sib qo'yilmasligini ta'minlaydi. React yangilanishlarni bu ustuvorliklarga qarab tegishli yo'llarga belgilash bilan o'zi shug'ullanadi, bu esa ilovaning samarali ishlashini mustaqil ravishda, biror aralashuvsiz, ta'minlaydi. Yangilanishlarning ustuvorligini belgilash Yangilanish sodir bo'lganda, React quyidagi bosqichlarni amalga oshiradi, ustuvorlikni belgilaydi va uni to'g'ri yo'lda joylashtiradi: 1. Yangilanish kontekstini aniqlash: React yangilanish chaqirilgan kontekstni baholaydi. Bu kontekst foydalanuvchi interaktivligi, state yoki props o'zgarishlari natijasida sodir bo'lgan ichki yangilanish yoki server javobiga asoslangan yangilanish bo'lishi mumkin. Kontekst yangilanishning ustuvorligini belgilashda muhim rol o'ynaydi. 2. Kontekst asosida ustuvorlikni baholash: Kontekstga asoslanib, React yangilanishning ustuvorligini baholaydi. Masalan, agar yangilanish foydalanuvchi kiritishidan kelib chiqsa, u yuqori ustuvorlikka ega bo'lishi mumkin, aksincha, noaniq orqa fon jarayonidan kelib chiqqan yangilanish past ustuvorlikka ega bo'lishi mumkin. Biz allaqachon turli ustuvorlik darajalari haqida batafsil muhokama qildik, shuning uchun bu yerda qo'shimcha batafsil ma'lumot berishga hojat yo'q. 3. Har qanday ustuvorlikni bekor qilishni tekshirish: Ba'zi hollarda, dasturchilar yangilanishning ustuvorligini aniq belgilashlari mumkin, bu React’ning yoki hook’lari orqali amalga oshiriladi. Agar bunday ustuvorlikni bekor qilish mavjud bo'lsa, React baholanadigan ustuvorlikni emas, aksincha taqdim etilgan ustuvorlikni ko'rib chiqadi. 4. Yangilanishni to'g'ri yo'lda joylashtirish: Ustuvorlik belgilanganidan so'ng, React yangilanishni tegishli yo'lda joylashtiradi. Bu jarayon biz ko'rgan bitmask yordamida amalga oshiriladi, bu esa React'ga bir nechta yo'llar bilan samarali ishlash imkonini beradi va yangilanishlarni to'g'ri guruhlash va qayta ishlashni ta'minlaydi. Ushbu jarayon davomida React yangilanishlar sodir bo'layotgan kontekst va ichki heuristikalariga tayangan holda ustuvorliklar haqida ma'lumotli qarorlar qabul qiladi. Ushbu dinamik ustuvorlik va yo'llarni belgilash React’ga tezkorlik va samaradorlikni muvozanatlash imkonini beradi, dasturchilardan qo'lda aralashuv talab qilmasdan ilovalarning samarali ishlashini ta'minlaydi. Keling, React qanday qilib yangilanishlarni o'z yo'llari bo'yicha qayta ishlashini ko'rib chiqaylik. Yo'llarni qayta ishlash Yangilanishlar o'z yo'llariga tayinlangandan so'ng, React ularni ustuvorlik tartibida qayta ishlaydi. Bizning chat ilovamiz misolida, React yangilanishlarni quyidagi tartibda qayta ishlaydi: - : Xabar kiritish uchun yangilanishlarni tezda qayta ishlash, bu uning javob beruvchanligini va tez yangilanishini ta'minlaydi. - : Foydalanuvchilarga real vaqt fikr-mulohazalarni taqdim etish orqali yozish indikatoriga yangilanishlarni qayta ishlash. - : Yangilanishlarni xabarlar ro'yxatiga qayta ishlash, yangi xabarlar va yangilanishlarni normal tezlikda ko'rsatish. Yangilanishlarni ustuvorlik tartibida qayta ishlash orqali React ilovaning eng muhim qismlari, hatto katta yuklama ostida ham, tezkor bo'lib qolishini ta'minlaydi. Commit bosqichi Barcha yangilanishlarni o'z yo'llarida qayta ishlaganidan so'ng, React commit, ya'ni tatbiq qilish, bosqichiga o'tadi, bu yerda o'zgarishlarni DOM’ga qo'llaydi, effektlarni ishga tushiradi va boshqa yakuniy vazifalarni bajaradi. Bizning chat ilovamiz misolida, bu xabar kiritish qiymatini yangilash, yozish indikatorini ko'rsatish yoki yashirish va yangi xabarlarni xabarlar ro'yxatiga qo'shishni o'z ichiga olishi mumkin. Keyin React keyingi render sikliga o'tadi, yangilanishlarni to'plab, yo'llarni qayta ishlash va o'zgarishlarni amalga oshirish jarayonini takrorlaydi. _Entanglement_ va _rebasing_ tushunchalari Biroq, bu jarayon bu yerdagi tushuntirishlarimizdan ko'ra ancha murakkabdir: _entanglement_, ya'ni \"chigallik\", kabi tushunchalar mavjud, bu ikki yo'lning birgalikda qayta ishlanishi kerakligini aniqlaydi, va _rebasing_, ya'ni \"qayta asoslash\", kabi qo'shimcha tushunchalar mavjud bo'lib, yangilanish oldin qayta ishlangan yangilanishlar ustiga qayta asoslanishi kerakligini belgilaydi. Qayta asoslash, masalan, agar bir transition tayinlanishi tugallanmasidan oldin, sinxron yangilanish bilan to'xtatilsa, ikkalasini birgalikda ishga tushirish kerak bo'lganda foydali bo'ladi. Flushing\" effektlari Bundan tashqari, _flushing effects_, ya'ni \"tozalanadigan effect\", tushunchalari haqida ham ko'p gapirish mumkin. Masalan, agar sinxron yangilanish bo'lsa, React ta'minlangan sinxron yangilanishlar o'rtasida holatning izchilligini ta'minlash uchun yangilanishdan oldin/yoki keyin effektlarni flush(tozalash) qilishi mumkin. Natijada, bu React’ning asl maqsadi va haqiqatda \"sahna ortida\" yashirin qiymat mavjud: u yangilanish muammolarini, ularning ustuvorligini va tartibini boshqarish vazifasini bajaradi, biz esa ilovalarimizga e'tibor berishda davom etamiz. Ustuvorliklarni \"qo'lda\" sozlash Muhim bir nuqtani qayd etish kerakki, React ustuvorliklarni baholashda yaxshi bo'lsa-da, har doim mukammal emas. Dasturchi sifatida, siz ba'zida standart ustuvorliklarni bekor qilishingiz kerak bo'lib qolishi mumkin, buni hozirgacha qayd etib o'tilgan API’lardan foydalanib: va orqali ilovangizning ishlashini va javobgarligini yanada to'g'ri sozlash uchun. Keling, bu API’larni yanada batafsil ko'rib chiqamiz.",
    "url": "/books/fluent-react/concurrent-react/render-lanes/page",
    "category": "books",
    "tags": [
      "fluent-react",
      "tutorial",
      "guide",
      "react",
      "javascript",
      "frontend",
      "react",
      "qayta",
      "render",
      "ustuvorlik",
      "yangilanishlarni",
      "yangilanish",
      "mumkin",
      "qanday",
      "bir",
      "ushbu",
      "uchun",
      "yangilanishlar",
      "minlaydi",
      "har",
      "ishlash"
    ]
  },
  {
    "id": "book-fluent-react-concurrent-react-revisiting-fiber-page",
    "title": "React Fiber Reconciler: Concurrent Rendering Asoslari",
    "content": "Fiber’ga qayta tashrif 4-bobda yoritilganidek, \"Fiber reconciler\" React’da concurrent render qilish imkoniyatini ta'minlovchi asosiy mexanizm hisoblanadi. U React 16-versiyasida kiritilgan bo'lib, oldingi \"stack reconciler\" arxitekturasidan sezilarli farq qilar edi. Fiber reconciler’ning asosiy maqsadi React ilovalarining javob berish qobiliyati va unumdorligini, ayniqsa katta va murakkab foydalanuvchi interfeyslari uchun, yaxshilashdan iborat. Fiber reconciler bu maqsadga render qilish jarayonini Fiber deb ataluvchi kichikroq va boshqarilishi osonroq ish birliklari(unit)ga bo'lish orqali erishadi. Bu React’ga render qilish vazifalarini pauza qilish, davom etish va ularni ustuvorlik asosida bajarish imkoniyatini beradi. Shu tarzda yangilanishlar muhimligiga qarab kechiktirilishi yoki rejalashtirilishi mumkin bo'ladi. Bu dasturiy ta’minotning javob berish qobiliyatini yaxshilaydi va muhim yangilanishlarning kamroq kamroq muhim bo'lgan vazifalar tomonidan to'silib qolmasligini ta'minlaydi.",
    "url": "/books/fluent-react/concurrent-react/revisiting-fiber/page",
    "category": "books",
    "tags": [
      "fluent-react",
      "tutorial",
      "guide",
      "react",
      "javascript",
      "frontend",
      "fiber",
      "reconciler",
      "react",
      "qilish",
      "render",
      "concurrent",
      "imkoniyatini",
      "asosiy",
      "javob",
      "berish",
      "muhim",
      "kamroq",
      "qayta",
      "tashrif",
      "bobda"
    ]
  },
  {
    "id": "book-fluent-react-concurrent-react-scheduler-page",
    "title": "React Scheduler Tahlili: Microtask'lar va Rejalashtirish Sirlari",
    "content": "Scheduler (Rejalashtiruvchi) React arxitekturasining asos qismida mustaqil paket sifatida ishlaydigan scheduler (rejalashtiruvchi) joylashgan bo'lib, vaqtga oid turli yordamchi vositalarni taqdim etadi va u Fiber reconciler’iga bog'liq emas. React ushbu scheduler’ni reconciler ichida ishlatadi. Scheduler va reconciler, render yo'llari(lanes) yordamida vazifalarni ularning dolzarbligiga qarab ustuvorlik bilan tartiblaydi va ularga birgalikda ishlash imkonini beradi. Hademay render yo'llari haqida batafsil to'xtalamiz. Bugungi kunda React’dagi scheduler’ning asosiy vazifasi asosiy thread’ni boshqarishdan iborat bo'lib, asosan mikrotask’larni rejalashtirish orqali silliq bajarilishni ta'minlaydi. Bu jarayonni yanada yaxshiroq tushunish uchun, hozirgi vaqtdagi React’ning manba kodidan kichik bir qismga nazar tashlaymiz: funksiyasi, React kod bazasida render’ni boshqarishda muhim rol o'ynaydi. React ildizi, deb nomlangan, yangilanishni qabul qilganda, ushbu funksiya ikkita muhim harakatni bajarish uchun chaqiriladi. 4-bobdan eslang: React ildizi bu yakuniy \"o'zgartirish\" bo'lib, u yangilanishlarni amalga oshirish uchun commit(tatbiq qilish) bosqichida sodir bo'ladi. chaqirilganda, u root’ning ildiz jadvaliga kiritilganligini tasdiqlaydi: bu qayta ishlanishi kerak bo'lgan ildizlarni kuzatadigan ro'yxat. Ikkinchidan, ushbu ildiz jadvalini qayta ishlashga bag'ishlangan kutilayotgan mikrotask mavjudligini ta'minlaydi. Event loop va microtask’lar JavaScriptda mikrotask — bu hodisa sikli (event-loop) menejmentida ishlatiladigan tushuncha bo'lib, bu turdagi vazifalar mikrotask’lar navbati orqali boshqariladi. Mikrotask’larni tushunish uchun avvalo JavaScript event loop va unga tegishli vazifalar navbatlari(task queue)ni tushunish muhim: Event loop JavaScript dvigateli asinxron operatsiyalarni boshqarish uchun event loop’dan foydalanadi. Event loop uzluksiz ravishda bajarilishi kerak bo'lgan ish (masalan, callback funksiyani bajarish) bor-yo'qligini tekshiradi. U ikki turdagi vazifalar navbatida ishlaydi: vazifalar navbati (makrotask navbati) va mikrotasklar navbati. Vazifalar navbati (makrotask navbati(queue)) Bu navbat event’larni boshqarish, va callback’larini bajarish, va I/O operatsiyalarni bajarish kabi vazifalarni o'z ichiga oladi. Bu navbatdagi vazifalar bittalab qayta ishlanadi, va navbatdagi vazifa faqat joriy vazifa tugagandan so'ng tanlanadi. Mikrotasklar navbati Mikrotask — bu kichikroq, tezroq bajarilishi kerak bo'lgan vazifa. Mikrotask’lar promise’lar, va kabi operatsiyalardan hosil bo'ladi. Ular oddiy vazifalar navbatidan farq qiluvchi mikrotask’lar navbati(microtask queue)da saqlanadi. Bajarilish (execution) Mikrotas’klar joriy vazifa tugagandan keyin, JavaScript dvigateli keyingi (makro) vazifani vazifalar navbatidan olguniga qadar qayta ishlanadi. Vazifa bajarilgandan keyin, dvigatel mikrotask’lar navbatida vazifalar borligini tekshiradi va keyingi vazifaga o'tishdan oldin ularning barchasini bajaradi. Bu mikrotask’larning tezkor va ketma-ket qayta ishlanishini ta'minlaydi, joriy skript bajarilgandan keyin va boshqa vazifalardan, masalan, renderlash yoki event’larni boshqarishdan oldin. Xususiyatlari va qo'llanilishi Mikrotask’lar navbatdagi makrotask’ga o'tishdan oldin bajarilishi bilan yuqori ustuvorlikka ega, ya'ni ular makrotask’lardan oldin bajariladi. Agar mikrotask navbatga uzluksiz yangi mikrotasklar qo'shsa, bu vaziyat vazifalar(macrotask) navbati qayta ishlanmasligi holatiga olib kelishi mumkin. Bu holat _starvation (och qolish)_ deb ataladi. funksiyasi tahlili funksiyasi kontekstida mikrotask ildiz jadvalini qayta ishlash darhol va yuqori ustuvorlikda, joriy skript bajarilgandan so'ng va brauzer boshqa vazifalar, masalan, renderlash yoki event’larni boshqarishdan oldin bajarilishini ta'minlash uchun qo'llaniladi. Bu React’da silliq foydalanuvchi interfeysini yangilanishi va samarali vazifa boshqaruvini ta'minlaydi. Funksiya ildizni jadvalga qo'shishdan boshlanadi. Bu, ildizning oxirgi rejalashtirilgan ekanligini yoki jadvalda allaqachon mavjud ekanligini tekshirishni o'z ichiga oladi. Agar u jadvalda mavjud bo'lmasa, funksiya ildizni jadvalning oxiriga qo'shib, ni joriy ildizga ko'rsatishga yangilaydi. Agar ilgari hech qanday ildiz rejalashtirilmagan bo'lsa , joriy ildiz jadvalda ham birinchi, ham oxirgi ildiz bo'ladi. Keyingi qadamda funksiya bayrog'ini ga o'rnatadi. Bu bayroq sinxron ishlov berish kutilayotganini ko'rsatadi va bu holat keyingi bo'limda muhokama qilinadigan funksiyasi uchun muhimdir. Funksiya, shuningdek, ildiz jadvalini qayta ishlash uchun mikrotask rejalashtirilganligiga ishonch hosil qiladi. Bu ni ( ) chaqirish orqali amalga oshiriladi. Bu rejalashtirish React'ning va bilan ifodalangan test yordam dasturi doirasida ham, undan tashqarida ham sodir bo'ladi. Funksiya tarkibidagi yana bir muhim qism bayrog'ini tekshiruvchi shart blokidir. Agar bu bayroq o'chirilgan bo'lsa, funksiya render vazifasini mikrotask’ga qoldirish o'rniga darhol rejalashtiradi. Bu qismda (hozirgi paytda) izohi mavjud bo'lib, kelajakda qo'shimcha imkoniyatlarni ochish uchun ushbu funksiyani yoqish rejalashtirilganligini ko'rsatadi. Nihoyat, funksiya React’ning dasturida eski yangilanishlarni boshqarish uchun shartni o'z ichiga oladi. Bu o'zgacha test vaziyatlariga tegishli bo'lib, u yerda yangilanishlar boshqacha tartibda yig'iladi va eski yangilanish rejalashtirilgan har safar ro'yxatdan o'tkaziladi. Xulosa qilib aytganda, bu React’ning rejalashtirish va render qilish logikasini bir necha jihatlarini o'z ichiga olgan murakkab funksiyadir. U React ildizlariga yangilanishlarni samarali boshqarishga va vazifalar va mikrotask’larni strategik rejalashtirish orqali oson va silliq renderlashni ta'minlashga qaratilgan. Shu bilan biz React’dagi rejalashtiruvchi (scheduler) roli haqida tushuncha hosil qilamiz: ishni qaysi render yo'llariga (lanes) tushganiga qarab rejalashtirish. Keyingi bo'limda ushbu \"yo'l\"lar haqida batafsil tushunchaga ega bo'lamiz, ammo hozircha shuni aytish mumkinki, yo'llar yangilanishning ustuvorligini ko'rsatadi. \"scheduler\" va \"lanes\" Agar rejalashtiruvchining xatti-harakatlarini kodda modellashtirsak, u quyidagicha ko'rinadi: Shu orqali ko'rish mumkinki: - Agar keyingi yo'l bo'lsa, scheduler keyingi yo'lda darhol ishlov berish uchun mikrotask navbatini shakllantiradi. Bu yerda mikrotask’lar nima ekanligini va ularning qanday mos kelishini tushunamiz. - Agar keyingi yo'l bo'lmasa, scheduler qayta chaqirishni rejalashtiradi va keyingi yo'lda ishlov beradi. Shunday qilib, \"scheduler\" o'z nomiga mos keladi: u yo'liga qarab funksiyalarni bajarish uchun belgilangan tizimdir. Yaxshi, biz \"lane\"lar haqida ko'p gaplashdik. Endi ularni batafsil tushunib chiqamiz!",
    "url": "/books/fluent-react/concurrent-react/scheduler/page",
    "category": "books",
    "tags": [
      "fluent-react",
      "tutorial",
      "guide",
      "react",
      "javascript",
      "frontend",
      "mikrotask",
      "react",
      "uchun",
      "vazifalar",
      "scheduler",
      "lar",
      "qayta",
      "event",
      "navbati",
      "keyingi",
      "funksiya",
      "ildiz",
      "agar",
      "lib",
      "render"
    ]
  },
  {
    "id": "book-fluent-react-concurrent-react-scheduling-and-deferring-updates-page",
    "title": "React'da Yangilanishlarni Rejalashtirish va Kechiktirish",
    "content": "Yangilanishlarni rejalashtirish va kechiktirish React’da yangilanishlarni rejalashtirish va kechiktirish imkoniyati ilovaning javob berish qobiliyatini saqlab qolish uchun juda muhimdir. Fiber reconciler bu funksiyani rejalashtiruvchi(scheduler) va samarali API’lar orqali ta'minlaydi. Ushbu API’lar React’ga bo'sh vaqtlarida ish bajarish va yangilanishlarni eng qulay paytlarda rejalashtirish imkonini beradi. Rejalashtiruvchini keyingi bo'limlarda batafsil o'rganamiz, ammo hozircha uni quyidagicha tushunib olishingiz mumkin: yangilanishlarni qabul qiladigan va “bu ishni hozir qil,” yoki “bu ishni keyin qil” deb aytadigan tizimdir. Bu tizim , kabi brauzer API’lariga tayanadi. Real vaqtli chat ilovasi misoli Real vaqtli chat ilovasini ko'rib chiqamiz, unda foydalanuvchilar xabarlar yuborishi va qabul qilishi mumkin. Chat komponenti xabarlar ro'yxatini ko'rsatadi, va xabarlarni kiritish(input) komponenti foydalanuvchilarga xabar yozish va jo'natish imkonini beradi. Shuningdek, chat ilovasi serverdan real vaqt rejimida yangi xabarlarni qabul qiladi. Bu vaziyatda foydalanuvchi bilan o'zaro aloqani (xabar yozish va jo'natish) ustuvor qilish orqali foydalanuvchi bilan ishlash qulayligini yaxshilashini xohlaymiz, shuningdek kiruvchi xabarlar UI’ni blok qilmasdan, samarali tarzda render qilishni ta'minlashni istaymiz. Misolni aniqroq qilish uchun, avvalo xabarlar ro'yxati komponentini yaratamiz: Keyin, foydalanuvchilarga xabar yozish va jo'natish imkonini beruvchi xabar kiritish komponentini yarataylik: Nihoyat, ikkala komponentni birlashtiruvchi va xabarlarni yuborish va qabul qilish logikasini boshqaruvchi chat komponentini yaratamiz: Ushbu misolda React’ning concurrent render qilish qobiliyatlari xabarlar ro'yxatini va foydalanuvchi bilan o'zaro interaktivlikni samarali boshqaradi. Foydalanuvchi xabar yozayotganida yoki yuborayotganida, React tekst kiritish yangilanishlarini boshqa yangilanishlardan ustuvor deb hisoblab, qulay va silliq foydalanuvchi bilan ishlash qulayligini ta’minlaydi. Yangi xabarlarni pastroq ustuvorlikda render qilish Serverdan yangi xabarlar kelganida va ular render qilinishi kerak bo'lganida, ular odatiy yoki noma'lum render yo'li(render lane)da render qilinadi. Bu, DOM’ni sinxron va bir zumda bloklovchi tarzda yangilaydi, bu esa foydalanuvchi kiritishlarini kechiktiradi. Agar yangi xabarlar ro'yxatini render qilishni pastroq ustuvorlikka o'tkazmoqchi bo'lsak, tegishli state yangilanishini hook’idan funksiyasi orqali o'rab ishlatishimiz mumkin. Quyidagi kabi: Bu bilan, React’ga xabarlar ro'yxati yangilanishlarini pastroq ustuvorlikda rejalashtirish va ularni UI’ni bloklamasdan render qilishligi haqida signal beramiz. Bu chat ilovasining katta yuklama ostida ham samarali ishlashiga imkon beradi, foydalanuvchi kiritishlari hech qachon to'xtatilmaydi va kiruvchi xabarlar foydalanuvchi bilan o'zaro interaktivlikda kamroq ahamiyatli bo'lganligi sababli pastroq ustuvorlikda render qilinadi. Ushbu misol, React’ning concurrent render qilish qobiliyatlarini murakkab o'zaro ta’sirlar va tez-tez yangilanishlarni ishlash samaradorligi yoki foydalanuvchi bilan ishlash qulayligidan voz kechmasdan qanday boshqarish mumkinligini ko'rsatadi. Keyingi bo'limda hook’ini yanada chuqurroq o'rganamiz. Hozir esa React yangilanishlarni qanday rejalashtirishini yanada chuqurroq ko'rib chiqamiz. Chuqurroq o'rganish React’da yangilanishlarni rejalashtirish, ustuvorlikni belgilash va kechiktirish jarayoni foydalanuvchi interfeysining javob qaytaruvchanligini saqlab qolish uchun muhimdir. Bu jarayon yuqori ustuvorlikdagi vazifalarni tezda hal qilishga imkon beradi, past ustuvorlikdagi vazifalar esa kechiktirilishi mumkin, bu esa UI’ning katta yuklama ostida ham silliq ishlashini ta'minlaydi. Bu mavzuni chuqurroq o'rganish uchun bir nechta asosiy tushunchalarni ko'rib chiqamiz: rejalashtiruvchi (scheduler), vazifalarning ustuvorlik darajalari (priority levels of tasks) va yangilanishlarni kechiktirish (defer updates) mexanizmlari.",
    "url": "/books/fluent-react/concurrent-react/scheduling-and-deferring-updates/page",
    "category": "books",
    "tags": [
      "fluent-react",
      "tutorial",
      "guide",
      "react",
      "javascript",
      "frontend",
      "render",
      "foydalanuvchi",
      "yangilanishlarni",
      "react",
      "xabarlar",
      "bilan",
      "rejalashtirish",
      "chat",
      "qilish",
      "kechiktirish",
      "xabar",
      "uchun",
      "samarali",
      "beradi",
      "mumkin"
    ]
  },
  {
    "id": "book-fluent-react-concurrent-react-useDeferredValue-page",
    "title": "useDeferredValue Hook: React'da UI Yangilanishlarini Kechiktirish",
    "content": "useDeferredValue — bu React hook’i bo'lib, ma'lum UI yangilanishlarini keyinroq vaqtlarga kechiktirish imkonini beradi. Bu, ayniqsa, dastur katta yuklama yoki hisoblash bilan bog'liq murakkab vazifalar bilan ishlayotgan holatlarda foydali bo'lib, yangilanishlarni ustuvorlik asosida boshqarishga va silliq o'tishlarni ta'minlashga, foydalanuvchi bilan ishlash qulayligini yaxshilashga yordam beradi. Dastlabki render paytida qaytarilgan kechiktirilgan qiymat taqdim etilgan qiymat bilan bir xil bo'ladi. Keyingi yangilanishlarda esa, eski qiymatni uzoqroq saqlash orqali silliq foydalanuvchi bilan ishlash qulayligini ta'minlaydi va yangi qiymatga o'tishni kechiktiradi, ayniqsa ko'p hisoblashni talab qiluvchi vaziyatlarda. Bu ko'p marta eski va yangi qiymatlar bilan qayta render qilishni emas, balki boshqarilgan yangilanishni anglatadi. Ushbu mexanizm _yangilanguncha eskisini ko'rsatish_ strategiyasiga o'xshaydi, yangi qiymatlarni kutish davomida U’Ining javob beruvchanligini saqlaydi. useDeferredValue’ning ilk implementatsiyasi React’ning commit tarixini ko'rib chiqsak, ning birinchi implementatsiyasi quyidagicha bo'lgan: Keling, ushbu kod nima qilayotganini tushuntiramiz. Dastlab, berilgan dastlabki qiymat bilan state’i o'rnatiladi. Keyin bu funksiya hook’ini qo'llab, ushbu qiymatdagi o'zgarishlarni kuzatadi. O'zgarish aniqlanganda, yangilanishni kechiktirish uchun muhim bo'lgan funksiyasi chaqiriladi. ichidagi state yordamida yangi qiymatga yangilanadi. dan foydalanish React’ga bu yangilanishni shoshilinch emasligini bildiradi, bu esa React’ga boshqa muhimroq yangilanishlarga ustuvorlik berish imkonini beradi. Bu, deyarli hozirgi kunda qanday ishlashiga o'xshaydi va bu haqidagi tushunchamiz uchun foydali bo'lishi kerak. — bu React’ning concurrent’lik xususiyatlarining bir qismi bo'lib, ayrim state yangilanishlarini kechiktirish orqali to'xtatish imkoniyatini taqdim etadi. Komponent kechiktirilgan qiymat bilan qayta render qilinganda, React bir muddat eski qiymatni saqlab turadi, bu esa yuqori ustuvorlikdagi yangilanishlar past ustuvorlikdagilardan oldinroq ishlov berilishiga imkon beradi. Bu, renderlash ishini kichik qismlarga bo'lib, vaqt davomida tarqatib beradi, javob beruvchanligini yaxshilaydi va yuqori ustuvorlikdagi yangilanishlar (masalan, foydalanuvchi interaktivligi) past ustuvorlikdagilar tomonidan kechiktirilmasligini ta'minlaydi, shu bilan foydalanuvchi bilan ishlash qulayligini oshiradi. useDeferredValue hook’ining maqsadi ning asosiy maqsadi, kamroq ahamiyatga ega yangilanishlarni render qilishlikni kechiktirishga imkon berishdir. Bu, foydalanuvchi interaktivligi kabi muhimroq yangilanishlarni serverdan yangilangan ma'lumotlarni ko'rsatish kabi kamroq muhim bo'lgan yangilanishlarga nisbatan ustuvorlik berish uchun juda foydalidir. dan foydalanish orqali, siz foydalanuvchi bilan ishlash qulayligini yanada qulay va silliqroq ta’minlashingiz va ilovangizning katta yuklama ostida yoki murakkab operatsiyalar bilan shug'ullanayotganda ham javob beruvchanligini saqlab qolishingiz mumkin. Foydalanish misoli ’dan foydalanish uchun, uni React paketidan import qilishingiz va kechiktirilishi kerak bo'lgan qiymatni argument sifatida berishingiz kerak. Hook keyin sizning komponentingizda ishlatilishi mumkin bo'lgan kechiktirilgan versiyasini qaytaradi. Quyida ni oddiy ilovada qanday ishlatishni ko'rsatadigan sodda misol keltirilgan: Ushbu misolda, bizda qidiruv input’i va qidiruv natijalarini ko'rsatuvchi komponenti mavjud. Biz dan qidiruv natijalarini renderlashni kechiktirish uchun foydalanamiz, bu esa ilovaga foydalanuvchi kiritmalarini ustuvorlashtirish va natijalar ro'yxatini renderlash qiyin bo'lganda ham javob beruvchan bo'lib qolishiga yordam beradi. Buni yanada batafsil tushunib olaylik: 1. Oldingi boblarda muhokama qilinganidek, biz komponentda dan foydalanamiz, shunda u keraksiz yangilanmaydi. 2. Yangilanish sodir bo'lganda, bu natijalarning renderlanishi qiyin bo'lgani uchun ishlash samaradorligi muammolarini keltirib chiqaradi. 3. Biz unga kechiktirilgan prop, ya'ni berganimizda, bu prop o'zi zarur render ishlari tugagandan keyin yangilanganligi sababli, komponent ham yangilanadi. Shunday qilib, komponent faqat muhim ishlar bajarilganda, masalan, matn input maydonini yangilaganda qayta renderlanadi. Debounce va throttling texnikasi Yana kimdir, “Nega shunchaki ni _debounce_ qilish yoki _throttling_ qilib qo'ya qolmaymiz?” deb so'rashi mumkin. Ajoyib savol. Keling, ularni solishtiraylik: - Debouncing: Ro'yxatni yangilashdan oldin pauza qilishni o'z ichiga oladi, foydalanuvchi yozishni tugatguncha kutadi, masalan, bir soniyalik kechikish. - Throttling: Ro'yxatni belgilangan vaqt oralig'ida yangilaydi, masalan, bir soniyadan ko'p emas. Ushbu usullar ba'zi vaziyatlarda samarali bo'lishi mumkin, lekin render optimizatsiyasi uchun yanada moslashtirilgan yechim sifatida paydo bo'ladi, chunki u foydalanuvchining qurilmasining ishlash imkoniyatlariga muvofiq ravishda moslashadi va hech qanday tasodifiy kechikishni talab qilmaydi. Asosiy farqlar ning asosiy farqi, kechikishlarga dinamik yondashuvdir. Bu ma'lum bir kechikish vaqtini belgilash zaruratini yo'q qiladi. Yuqori samarali qurilmada, masalan, kuchli noutbukda, qayta render qilishdagi kechikish deyarli sezilmaydi, deyarli darhol sodir bo'ladi. Aksincha, sekinroq qurilmalarda renderlash kechikishi tegishlicha moslashadi, foydalanuvchi kiritishiga javoban ro'yxatni yangilashda biroz orqada qolishi, qurilmaning tezligiga proporsional bo'ladi. Qo'shimcha afzalliklar Bundan tashqari, ning kechiktirilgan qayta renderlarni to'xtatish imkoniyatida katta afzalligi bor. Agar React katta ro'yxatni qayta ishlayotgan bo'lsa va foydalanuvchi yangi tugma bosishi bilan kiritilsa, React qayta renderlashni to'xtatishi, yangi kiritishga javob berishi va keyin orqa fon jarayonida renderlash jarayonini davom ettirishi mumkin. Bu, _debouncing_ va _throttling_ bilan taqqoslaganda, yangilanishlarni kechiktirishiga qaramasdan, renderlash davomida interaktivlikni bloklaydi va disjoint (bir-biriga mos kelmaslik) muammosiga olib kelishi mumkin. Biroq, _debouncing_ va _throttling_ renderlash bilan bevosita bog'liq bo'lmagan vaziyatlarda hali ham foydali. Masalan, ular tarmoq so'rovlarining tezligini kamaytirishda samarali bo'lishi mumkin. Ushbu texnikalarni bilan birga kengaytirilgan optimizatsiya strategiyasi uchun ham ishlatish mumkin. dan foydalanishning afzalliklari Bular asosida, React ilovalarida dan foydalanishning bir necha afzalliklarini ko'rib o'tamiz: - Yaxshilangan javob beruvchanlik: Misolda, foydalanuvchi qidiruv maydoniga yozganda, kiritish maydoni darhol yangilanadi va natijalar kechiktiriladi. Agar foydalanuvchi tezda 5 ta belgini ketma-ket yozsa, kiritish maydoni darhol besh marta yangilanadi va faqat foydalanuvchi yozishni to'xtatganda bir marta render qilinadi. 1-4 belgilar uchun ning renderlanishi yangi qiymatlar bilan to'xtatiladi. - Deklarativ ustuvorlik: ilovangizda yangilanishlar ustuvorligini boshqarish uchun oddiy va deklarativ usulni taqdim etadi. Yangilanishlarni kechiktirish uchun logikani hook ichida joylashtirish orqali, komponent kodingizni toza va ilovangizning muhim jihatlariga diqqatni jamlashga imkon beradi. - Resurslardan yaxshiroq foydalanish: Kechiktirilgan kamroq muhim bo'lgan yangilanishlar bilan ilovangizning mavjud resurslaridan yaxshiroq foydalanishiga yordam beradi. Bu ishlashdagi qiyinchiliklar ehtimolini kamaytirishga va ilovangizning umumiy ishlashini yaxshilashga yordam beradi. useDeferredValue qachon ishlatiladi asosan ilovangizda ba'zi yangilanishlarni boshqalardan ustun qo'yish zarur bo'lgan vaziyatlarda juda foydali. dan foydalanishni ko'rib chiqish mumkin bo'lgan ba'zi umumiy vaziyatlar: - Katta ma'lumotlar to'plamlarini qidirish yoki filtr qilish - Murakkab vizualizatsiyalar yoki animatsiyalarni renderlash - Serverdan kelgan ma'lumotlarni orqa fon rejimida yangilash - Foydalanuvchi interaktivligiga ta'sir ko'rsatishi mumkin bo'lgan hisoblash jihatdan qiyin operatsiyalarni boshqarish Keling, ni ayniqsa foydali bo'lishi mumkin bo'lgan bir misolga qaraylik. Tasavvur qilingki, biz foydalanuvchi input’i asosida filtrlanishi kerak bo'lgan katta ro'yxatdagi elementlar mavjud. Katta ro'yxatni filtr qilish hisoblash jihatdan qiyin bo'lishi mumkin, shuning uchun dan foydalanish ilovani javobgar holda saqlashga yordam beradi: Ushbu misolda, filtrlangan ro'yxatni renderlashni kechiktirish uchun dan foydalanamiz. Foydalanuvchi filtr input maydonida yozganda, kechiktirilgan qiymat kamroq tez-tez yangilanadi, bu ilovaga foydalanuvchi input’ini ustuvorlash va tezkor javob beruvchanligini saqlashga imkon beradi. hook’i va massivlarini memoizatsiya qilish uchun ishlatiladi, bu esa keraksiz qayta renderlash va qayta hisoblashlarni oldini oladi. Bu esa ilovaning ishlashini yanada yaxshilaydi. useDeferredValue’dan qachon foydalanmaslik kerak ba'zi vaziyatlarda foydali bo'lishi mumkin bo'lsa-da, uning ayrim ijobiy va salbiy jihatlarini ko'rib chiqish muhimdir. Ya'ni, yangilanishlarni kechiktirish orqali, foydalanuvchiga ko'rsatiladigan ma'lumotlar biroz eski bo'lishi mumkin. Bu kamroq muhim yangilanishlar uchun odatda qabul qilinadi, ammo foydalanuvchilarga eski ma'lumotlarni ko'rsatishning oqibatlarini hisobga olish zarur. dan foydalanish yoki foydalanmaslik haqida qaror qabul qilishda o'zingizga berishingiz mumkin bo'lgan yaxshi savol: “Ushbu yangilanish foydalanuvchi input’imi?” React’ning React deb atalishining sababi shundaki, u bizning veb-ilovalarimizni voqealarga reaksiya qilishga imkon beradi. Foydalanuvchi biror narsa kiritganda, natijani kutishi kerak bo'lsa, bu yangilanishni kechiktirishga arziydimi yoki yo'qmi deb o'ylash kerak. Boshqa barcha yangilanishlar esa kechiktirilishi mumkin. dan foydalanish ilovangizning katta yuklama ostida ham javob beruvchanligini yaxshilashi mumkin, ammo bu uni muammolarni hal qilishning asosiy yechimi sifatida ko'rmaslik kerak. Har doim esda tutingki, samarali kod yozish va keraksiz hisoblashlardan qochish - samaradorlikni oshirishning eng yaxshi usuli.",
    "url": "/books/fluent-react/concurrent-react/useDeferredValue/page",
    "category": "books",
    "tags": [
      "fluent-react",
      "tutorial",
      "guide",
      "react",
      "javascript",
      "frontend",
      "foydalanuvchi",
      "bilan",
      "mumkin",
      "uchun",
      "react",
      "dan",
      "beradi",
      "lgan",
      "bir",
      "qayta",
      "ning",
      "kechiktirish",
      "katta",
      "render",
      "ushbu"
    ]
  },
  {
    "id": "book-fluent-react-concurrent-react-useSyncExternalStore-page",
    "title": "useSyncExternalStore: React'da Tearing Muammosini Hal Qilish",
    "content": "useSyncExternalStore — bu React hook bo'lib, u tashqi state’ni ilovangizning ichki state’i bilan sinxronlash imkonini beradi. Bu ayniqsa, _tearing_’ni oldini olish kerak bo'lgan murakkab hisob-kitob operatsiyalari bilan ishlaganda foydalidir. dagi “sync” so'zi ikki ma'noga ega: bu “sinxronlashtirish”ni ham, “sinxron”ni ham anglatadi, ya'ni store o'zgarganda sinxron yangilanishni majburiy qiladi. useSyncExternalStore tarkibi hook’ining ko'rinishi quyidagicha: Bu callback funksiyasini birinchi va yagona argument sifatida qabul qiladigan funksiya. Ushbu funksiya ichida tashqi store’dagi o'zgarishlarga obuna bo'lib, store o'zgarganda callback funksiyasi chaqiriladi. Bu callback’ni React’ga yangi qiymat bilan komponentni qayta render qilishga undovchi chaqiriq sifatida ko'rish mumkin. Ushbu funksiyaning kutilgan natijasi — store’dan obunani bekor qiluvchi \"cleanup\" funksiyasidir. funksiyasining oddiy ko'rinishi quyidagicha: Buning uchun oddiy foydalanish misoli brauzer event’lariga obuna bo'lish, masalan, yoki event’lari va ushbu event’lar sodir bo'lganda komponentni yangilash, masalan: Yuqoridagi misolda, brauzerning oyna hajmi o'zgarganda bizning React komponentlarimiz qayta render bo'ladi. Biroq, qanday qilib yangi qiymat olinadi? Buning uchun ning ikkinchi argumenti kerak bo'ladi. Bu tashqi store’ning joriy qiymatini qaytaradigan funksiya. Ushbu funksiya komponent renderlanganda chaqiriladi va qaytarilgan qiymat komponentning ichki state’ini yangilash uchun ishlatiladi. Ushbu funksiya sinxron chaqiriladi, shuning uchun u asinxron operatsiyalarni bajarmasligi yoki hech qanday _side effect_’ga ega bo'lmasligi kerak. Bu funksiya komponentning bir nechta nusxalarida render vaqtida state’ning mosligini ta'minlaydi. Oyna hajmi bo'yicha misolimizga qaytsak, quyidagi kod joriy oyna hajmini olish usulini ko'rsatadi: Bu obyekti oynaning joriy state’ining snapshoti bo'lib, bu qiymatni qaytaradi. Ushbu obyektni komponentimizda ishlatishimiz mumkin va uning holati barcha bir paytda bajariladigan renderlarda mos kelishini ishonch bilan bilishimiz mumkin. Bu ishonchni bizga nima beradi? Chunki funksiyasi sinxron ravishda qayta render qilishni majburlaydi va React’ga uni kechiktirishga ruxsat bermaydi. Bu _tearing_ muammosini hal qilishning asosiy kalitidir. Tearing muammosini bilan hal qilish Endi oldingi misolimizda _tearing_ muammosini qanday hal qilishimiz mumkinligini yordamida ko'rib chiqamiz. Eslasak, bizda _tearing_ tufayli har xil qiymatlarda o'zgaruvchisini qaytaruvchi bir nechta lar mavjud edi. Endi bu muammoni yordamida qanday hal qilishni ko'raylik. Avvalo, biz store’gaga obuna bo'lishni va yangilanishlar sodir bo'lganda React’ni qayta render qilishni istamaymiz; buning o'rniga, qayta renderlash foydalanuvchi kiritishiga bog'liq bo'lganda, mos holatni olishni xohlaymiz. Shunday qilib, bizning funksiyamiz bo'sh bo'ladi, lekin mos holatni olish uchun funksiyasidan foydalanamiz va ning joriy qiymatini qaytarib beramiz: bilan yangilangan misol Quyida oldingi misolimiz bilan qanday ko'rinishga ega bo'lishi: Endi ushbu misolni ishga tushirsak, lar uchun bir xil qiymat bilan renderlanadi, bu esa _tearing_’ning oldini oladi. hook’i render vaqtida komponentning bir nechta nusxalari uchun state’ni bir xil bo'lishini ta'minlaydi. Tearing muammosini hal qilishda funksiyasidan foydalanmaslik sababi Biz funksiyasidan foydalanmaymiz, chunki uning maqsadi React’ga eng so'nggi state qiymatida qayta render qilish kerakligini aytishdir. Biroq, bizning misolimizda faqat barcha renderlar davomida state mos bo'lishini xohlaymiz. funksiyasini ishlatib, ning joriy qiymatini qaytarib olamiz va shu orqali komponentning bir nechta nusxalarida render vaqtida state’ning mos bo'lishini ta'minlaymiz. Bu usulni oldingi misolimizda bilan _tearing_ muammosini hal qilish uchun qo'llash mumkin. Shu orqali komponentning bir nechta nusxalarida render vaqtida state’ning mos bo'lishini ta'minlay olamiz. bilan holatni moslash Shunday qilib, matn kiritish maydoni o'zgarganda va qayta render qilinganda, boshqa nusxalari bilan bir xil qiymatiga ega bo'ladi va _tearing_’ning oldi olinadi. Ammo, agar biz ichida ham ni tashqi bilan bir xil intervalda yangilamoqchi bo'lsak-chi? Buning uchun quyidagi kabi bir store yaratamiz, bu store bir xil yangilanish qoidalariga amal qiladi: Endi, har safar o'zgarganda, yangi qiymati bilan qayta renderlanadi va biz ning barcha nusxalarida bir xil qiymatini ko'ramiz. O'zgarishlarni aniqlash logikasi oddiy yoki murakkab bo'lishi mumkin, lekin muhim jihati shundaki, qanday ishlashini va uning asosiy vazifalarini tushunishimiz kerak: - Bir vaqtning o'zida renderlar davomida mos state’ni ta'minlash - Store’da o'zgarish bo'lganida sinxron qayta render qilishga majbur qilishlik va tearing muammosi Endi qanday ishlashini va _tearing_ muammosini qanday hal qilishini tushunganimizdan so'ng, biz nafaqat React’da concurrent rendering haqida, balki u bilan bog'liq muammolarni hal qilish haqida ham mustahkam tushunchaga egamiz. Bu React dasturchisi sifatida juda muhim. Bu narsalarni tushunishda biz ichkariga chuqurroq kirdik, lekin deyarli nihoyasiga yetdi. Keling, o'zlashtirganlarimizni bir eslab olamiz va xulosa qilamiz.",
    "url": "/books/fluent-react/concurrent-react/useSyncExternalStore/page",
    "category": "books",
    "tags": [
      "fluent-react",
      "tutorial",
      "guide",
      "react",
      "javascript",
      "frontend",
      "bir",
      "bilan",
      "state",
      "render",
      "ning",
      "react",
      "store",
      "qayta",
      "uchun",
      "hal",
      "_tearing_",
      "qanday",
      "ushbu",
      "mos",
      "muammosini"
    ]
  },
  {
    "id": "book-fluent-react-concurrent-react-useTransition-page",
    "title": "useTransition Hook: React'da State O'tishlarini Boshqarish",
    "content": "useTransition — bu kuchli React hook’i bo'lib, komponentlaringizda state yangilanishlarining ustuvorligini boshqarishga va yuqori ustuvorlikdagi yangilanishlar tufayli UI'ning javob beruvchanligini yo'qotmaslikka yordam beradi. Bu ayniqsa yangi ma'lumotlarni yuklash yoki sahifalar o'rtasida navigatsiya qilish kabi vizual tarzda buzilishi mumkin bo'ladigan yangilanishlarda foydali hisoblanadi. orqali qaytarilgan funksiyasiga o'ralgan har qanday yangilanishni \"transition lane\"ga (biz ilgari ko'rganimizdek, Sync yo'lidan pastroq ustuvorlik darajasiga) o'tkazadi. Bu sizga yangilanishlarning vaqtini boshqarish va yuqori ustuvorlikdagi boshqa yangilanishlar asosiy thread uchun raqobat qilayotgan bo'lsa ham, silliq foydalanuvchi bilan ishlash qulayligini ta'minlash imkonini beradi. useTransition tarkibi hook bo'lgani uchun uni faqatgina funksional komponentlar ichida ishlatishingiz mumkin. Bu ikkita elementdan iborat massivni qaytaradi: - : Bu o'zgaruvchi boolean qiymat bo'lib, o'tish (transition) jarayoni davom etayotganligini bildiradi. ning ishlashidagi qiziqarli jihat shundaki, chaqirilganda birinchi qiladigan ish bu sinxron ni o'rnatish uchun bajarish. Shu sababli, ga bog'liq yangilanishlar tezkor bo'lishi kerak, aks holda dan foydalanish maqsadini yo'qotadi. - : Pastroq ustuvorlikda bo'lishi yoki kechiktirilishi kerak bo'lgan yangilanishlarni o'rash uchun foydalaniladigan funksiya. API Bu yerda, API ham mavjudligini eslatib o'tish o'rinli, bu hook emas, balki oddiy funksiya sifatida mavjud. Shoshilinch bo'lmagan transition’ni boshlashning ikkinchi usuli bu React’dan bevosita import qilinadigan funksiyasidan foydalanishdir. Bu usul bizga bayrog'idan foydalanish imkonini bermaydi, lekin u hook kabi foydalanib bo'lmaydigan kod qismlarida, masalan hook’idan chaqirish kabi, pastroq ustuvorlikdagi yangilanishni React’ga bildirmoqchi bo'lgan holatlarda mavjud. Sodda misol Quyida, dan foydalanishni ko'rsatuvchi sodda misolni ko'rib chiqamiz: Ushbu misolda, biz dan foydalanib hisoblagichni oshiruvchi state yangilanishining ustuvorligini boshqaryapmiz. yangilanishini funksiyasi ichiga o'rab, biz React’ga bu yangilanishni kechiktirish mumkinligini bildiryapmiz. Shu orqali, agar boshqa yuqori ustuvorlikdagi yangilanishlar sodir bo'lsa ham, UI javob bermay qolmasligi ta'minlanadi. Murakkab misol: Navigatsiya sahifalar orasida o'tishda ham foydali. Navigatsiya bilan bog'liq yangilanishlarning ustuvorligini boshqarish orqali foydalanuvchi bilan ishlash qulayligini silliq va tezkor saqlash mumkin, hatto murakkab sahifa o'tishlarida ham. Ushbu misolda yordamida bir sahifali ilovada (SPA) sahifa o'tishlarini qanday boshqarish mumkinligini ko'rib chiqamiz: Ushbu misolda, bizning SPA’dagi turli sahifalarni ifodalovchi ikkita oddiy komponent mavjud. Biz ’dan foydalanib joriy sahifani o'zgartiruvchi state yangilanishini o'rab qo'yamiz, bu sahifa o'tishini boshqa yuqori ustuvor yangilanishlar (masalan, foydalanuvchi kiritadigan input ma'lumotlar) sodir bo'layotgan paytda kechiktiradi. Bu misolda shunday savol tug'ilishi mumkin: \"To'xtang, sahifa o'tishi foydalanuvchi bosganidan keyin darhol amalga oshishi kerak emasmi?\" Ha, siz to'g'ri fikr qilasiz; ammo, agar keyingi sahifa yordamida biror ma'lumotni yuklashni talab qilsa, unda sahifa o'tishi kechikishi mumkin. Bu yerda yordam beradi, chunki u navigatsiyaga tegishli yangilanishlarning ustuvorligini boshqarishga imkon beradi, murakkab sahifa o'tishlarida ham foydalanuvchi bilan ishlash qulayligi silliq va javob beruvchi bo'lishini ta'minlaydi. E'tiborga olish kerakki, agar keyingi sahifa ma'lumotni effekt (masalan bilan) orqali yuklashni talab qilsa, ushbu ma'lumotning yuklanishini kutmaydi; ammo, transition ichida kechiktirilganda, React state’ini ma'lumotni yuklash va qaytgandan so'ng uni ko'rsatishga bog'laydi. Ushbu holatda, sahifa o'tish jarayonida state’i bo'lib qoladi, bu foydalanuvchi tugmani bosishiga javoban darhol yuklanish indikatorini ko'rsatishga imkon beradi. O'tish yakunlangandan so'ng, state’i bo'ladi va yangi sahifa ko'rsatiladi. Chuqurroq tahlil qilish Reactning Fiber arxitekturasi, React rejalashtiruvchisi(scheduler), ustuvorlik darajalari va render yo'l(lane)lari mexanizmi bo'yicha asosiy bilimga ega bo'lib, endi hook’ining ichki ishlash mexanizmini chuqurroq o'rganishimiz mumkin. hook’i o'tish (transition) yaratish va o'sha transition ichidagi yangilanishlarga maxsus ustuvorlik darajasini tayinlash orqali ishlaydi. Biror yangilanish transition ichiga joylashtirilganda, React yangilanishni belgilangan ustuvorlik darajasi asosida rejalashtirish va render qilishni ta’minlaydi. Mana hook’idan foydalanishda bajariladigan qadamlar umumiy ko'rinishi: 1. Funksional komponent ichida hook’ini import qilish va chaqirish. 2. Ushbu hook ikki elementdan iborat massivni qaytaradi: birinchisi state’i, ikkinchisi esa funksiyasi. 3. Vaqtni nazorat qilmoqchi bo'lgan har qanday state yangilanishi yoki komponent render qilishini o'rash uchun funksiyasidan foydalaning. 4. state’i transition jarayoni hali tugallanmagan yoki tugallanganligini ko'rsatadi. 5. React transition’ga o'ralgan yangilanishlarni tegishli ustuvorlik darajasi bilan ishlov berishini ta’minlaydi. Bu yangilanishlarni tayinlash va boshqarish uchun jadval va render yo'llari mexanizmidan foydalanish orqali amalga oshiriladi. dan foydalanish orqali biz yangilanishlarning vaqtini samarali boshqara olamiz va yuqori ustuvorlikka ega yangilanishlar asosiy thread uchun raqobat qilayotganida ham silliq foydalanuvchi bilan ishlash qulayligini saqlashimiz mumkin.",
    "url": "/books/fluent-react/concurrent-react/useTransition/page",
    "category": "books",
    "tags": [
      "fluent-react",
      "tutorial",
      "guide",
      "react",
      "javascript",
      "frontend",
      "hook",
      "state",
      "sahifa",
      "react",
      "transition",
      "mumkin",
      "orqali",
      "uchun",
      "ham",
      "foydalanuvchi",
      "bilan",
      "yangilanishlar",
      "dan",
      "ushbu",
      "yuqori"
    ]
  },
  {
    "id": "book-fluent-react-entry-level-stuff-angular-page",
    "title": "AngularJS Tahlili: React'ning Yaratilishiga Nima Sabab Bo'ldi?",
    "content": "AngularJS’ ning rivojlanishi AngularJS 2010-yilda Google tomonidan ishlab chiqilgan bo'lib, veb ishlab chiqish sohasiga katta ta'sir ko'rsatgan dastlabki JavaScript freymvorklaridan biri edi. Bu freymvork avvalgi kutubxonalar va freymvorklardan keskin farq qildi, bir qator innovatsion funksiyalarni o'z ichiga oldi va bu funksiyalar keyinchalik React kabi boshqa kutubxonalar va freymvorklarda ham o'z aksini topdi. Keling, AngularJS bilan boshqa kutubxonalarni batafsil solishtirib, uning muhim funksiyalariga nazar tashlab, React uchun qanday yo'l ochilganini tushunishga harakat qilib ko'ramiz. Ikki tomonlama ma'lumotni bog'lash AngularJS’ning asosiy xususiyatlaridan biri ikki tomonlama ma'lumotni bog'lash(two-way data binding) edi, bu UI va dasturdagi ma'lumotlar o'rtasidagi o'zaro ta'sirni ancha osonlashtirdi. Agar model (asosiy ma'lumotlar) o'zgarsa, view (UI) avtomatik ravishda yangilanadi va aksincha. Bu jQuery kabi kutubxonalardan keskin farq qildi, chunki jQueryda dasturchilar DOM’ni qo'lda boshqarib, foydalanuvchi kiritgan ma'lumotlarni saqlashlari kerak edi. Quyida ikki tomonlama ma'lumotni bog'lash muhim rol o'ynagan oddiy AngularJS dastur kodi ko'rsatilgan: Ushbu kodda, direktivasi input maydonining qiymatini o'zgaruvchisiga bog'laydi. Siz input maydoniga yozganingizda, modeli yangilanadi va interfeys — bu holda — real vaqtda yangilanadi. Modulli arxitektura AngularJS modulli arxitekturani joriy qildi, bu dasturchilarga dastur komponentlarini mantiqiy tomondan ajratishga imkon berdi. Har bir modul alohida funksiyani o'z ichiga olib, mustaqil ravishda ishlab chiqilishi, test qilinishi va maintain qilinishi mumkin edi. Ba'zilar buni React’ning komponentlar modeliga turtki bo'lgan deb atashadi, lekin bu biroz bahsli masala. Quyida oddiy misol: Yuqoridagi misolda moduli bir nechta boshqa modullarga bog'liq: , , , va . Ushbu har bir bog'liq bo'lgan modul o'zining alohida JavaScript faylida bo'lishi mumkin va asosiy modulidan mustaqil ravishda ishlab chiqilishi mumkin. Bu tushuncha jQuery va Backbone.js kabi kutubxonalardan sezilarli darajada farq qildi, chunki ularda bunday \"modul\" tushunchasi mavjud emas edi. Biz bu bog'liq bo'lgan modullar( , va boshqalar)ni asosiy moduliga kiritamiz va Angularda mashhur bo'lgan \"dependency injection\"(bog'liqlikni kiritish) pattern’ini qo'llaymiz. Shuni ta'kidlash kerakki, bu pattern JavaScript modullari standartlashtirilishidan oldin keng tarqalgan edi. Keyinchalik va operatorlari tezda asosiy darajaga chiqdi. Bu dependency’larni React komponentlari bilan solishtirish uchun, dependency injection haqida bir oz mulohaza yuritamiz. Dependency Injection Dependency injection (DI) — bu dizayn pattern bo'lib, unda obyekt o'z dependency’larini o'zi yaratmasdan qabul qiladi. AngularJS ushbu pattern’ni o'z core dasturiga, ya'ni asosiy dasturiga, kiritgan va bu boshqa JavaScript kutubxonalarida keng tarqalgan xususiyat emas edi. Bu modullar va komponentlarni yaratish va boshqarish usullariga katta ta'sir ko'rsatdi, ular modullik va qayta foydalanish darajasini yuqori ravishda oshirdi. Quyida DI’ning AngularJS’da qanday ishlashiga misol keltirilgan: Bu misolda — bu DI orqali ga kiritiladigan servisdir. Kontroller servisni qanday yaratishni bilishi shart emas, u shunchaki servisni dependency sifatida belgilaydi va Angular uni yaratish va kiritish bilan shug'ullanadi. Bu dependency’larni boshqarishni osonlashtiradi, komponentlarni testlashni va qayta foydalanuvchanligini oshiradi. Backbone.js va Knockout.js bilan taqqoslash AngularJS taqdim etilgan davrda ikkala Backbone.js va Knockout.js ham mashhur kutubxonalar edi. Har ikkala kutubxona o'z kuchli tomonlariga ega bo'lgan bo'lsa-da, ular AngularJS’da bo'lgan ba'zi xususiyatlardan mahrum edi. Masalan, Backbone.js dasturchilarga kodlarini boshqarishda ko'proq erkinlik berar edi va AngularJS singari qat'iy qoidalariga ega emasdi. Bu erkinlik kuchli tomon bo'lishi bilan birga, zaif tomon ham edi: bu ko'proq moslashtirish imkoniyatini berdi, lekin ko'proq ortiqcha(boilerplate) kod talab qilardi. AngularJS esa ikki tomonlama ma'lumot bog'lash va dependency injection bilan ancha strukturalashgan edi. Ushbu qat'iy qoidalar dasturchilarning tezligini oshirishga olib keldi, biz buni hozirda Next.js, Remix kabi zamonaviy freymvorklarda ham kuzatamiz. Bu jihatdan AngularJS o'z davridan ancha oldinda edi. Backbone.js, shuningdek, DOM o'zgarishlarini boshqarishda to'g'ridan-to'g'ri yechim taklif qilmagan va ko'pincha bu vazifani dasturchilarning o'ziga qoldirgan. AngularJS esa DOM o'zgarishlarini ikki tomonlama bog'lash orqali boshqardi, bu esa katta afzallik edi. Knockout.js’da fokus asosan ma'lumot bog'lashga qaratilgan edi va AngularJS’da mavjud bo'lgan DI va modulli arxitektura kabi boshqa kuchli vositalarga ega emas edi. AngularJS, to'liq funksional freymvork sifatida, bir sahifali ilova(SPA)larni yaratish uchun kengroq yechimlarni taklif qildi. AngularJS o'z rivojlanishini to'xtatgan bo'lsa-da, uning keyingi variantlari, ya'ni Angular, xuddi shunday, lekin yanada rivojlangan funksiyalarni taqdim etdi va keng miqyosli ilovalar uchun mukammal tanlovdir. AngularJS’ning kamchiliklari AngularJS (1.x) taqdim etilgan paytda veb-ishlab chiqish amaliyotlarida katta qadamni amalga oshirgan edi. Biroq, veb-ishlab chiqish sohasining tez rivojlanishi natijasida AngularJS’ning ba'zi jihatlari uning zaif tomonlari sifatida ko'rila boshladi. Quyida ba'zi muhim kamchiliklar keltirilgan: Performance AngularJS katta miqyosli dasturlarda, ayniqsa murakkab ma'lumot bog'lashlarda, ish faoliyati bilan bog'liq muammolarga duch keldi. AngularJS’ning asosiy xususiyati bo'lgan o'zlashtirish sikli(digest cycle) katta ilovalarda yangilanishlarni sekinlashishiga va foydalanuvchi interfeysida kechikishlarga olib kelishi mumkin edi. Ikki tomonlama ma'lumot bog'lash innovatsion va ko'plab holatlarda foydali bo'lsa-da, bu ham performance muammolariga sabab bo'ldi. Murakkablik AngularJS ko'plab yangi tushunchalarni joriy qildi, jumladan, direktivalar, kontrollerlar, servislar, bog'liqlikni kiritish (DI), fabrika(factory)lar va boshqalar. Bu funksiyalar AngularJS’ni kuchli qilgan bo'lsa-da, ularni o'rganish murakkab va yangi dasturchilar uchun qiyin bo'ldi. Masalan, \"bu fabrika bo'lishi kerakmi yoki servismi?\" degan savol ko'plab dasturchi jamoalarni adashtirib qo'ydi. Angular 2+ ga o'tish muammolari Angular 2 e'lon qilinganda, bunda oldingi versiyalar bilan, ya'ni AngularJS 1.x bilan, o'zaro moslik yo'q edi va kodni Dart yoki TypeScript’da qayta yozishni talab qildi. Bu esa dasturchilarga katta miqdordagi kodlarini qayta yozishga majbur qildi va bu katta to'siq sifatida qaraldi. Angular 2+ ning joriy etilishi Angular hamjamiyatini bo'lib yubordi va tushunmovchiliklar keltirib chiqardi, bu esa React paydo bo'lishiga yo'l ochdi. Template’larda murakkab sintaksis AngularJS template(shablon) atributlarida murakkab JavaScript ifodalari, masalan, kabi ifodalarni ishlatishga ruxsat berishi muammo edi, chunki bu UI va biznes logikani birgalikda aralashtirib yuborardi. Bu yondashuv kodni maintain qilishni qiyinlashtirdi, chunki bir-biriga bog'langan kodlarni tushunish va boshqarish murakkab bo'lib qoldi Bundan tashqari, debugging ham qiyinlashdi, chunki template’lar murakkab logikani boshqarish uchun yaratilmagan edi. Template ichidagi bunday ifodalar tufayli yuzaga keladigan xatolarni aniqlash va tuzatish oson emasdi. Shu bilan birga, bunday amaliyotlar dasturiy ta'minotni loyihalashning \"ma'suliyatlarni ajratish\" prinsipiga zid edi. Bu prinsip dasturiy ta'minotning turli jihatlarini alohida boshqarishni talab qiladi, bu esa kod sifati va boshqariluvchanligini yaxshilaydi. Nazariy jihatdan, template biror yangilanishni amalga oshirish uchun kontroller metodini chaqirishi kerak edi, lekin bunday amaliyotni cheklovchi narsa yo'q edi. Tip xavfsizligining yo'qligi AngularJS template’lari statik tiplarni tekshiruvchi vositalar, masalan, TypeScript bilan ishlamasdi. Bu dasturlash jarayonida xatolarni oldindan aniqlashni qiyinlashtiradi. Bu katta miqyosli dasturlar uchun muhim kamchilik edi, chunki bunday dasturlarda tip xavfsizligi boshqaruvchanlik va kengaytiriluvchanlik uchun juda muhimdir. modelining chalkashligi AngularJS’dagi obyekti ko'pincha chalkashlikka olib kelar edi, chunki u ma'lumotlarni bog'lash va turli kontekstlarda o'zini qanday tutishiga javobgar edi. U view va kontroller o'rtasidagi bog'lanish rolini bajargan bo'lsa-da, uning xatti-harakati har doim intuitiv yoki bashorat qilinadigan emas edi. Bu, ayniqsa, yangi o'rganayotganlar uchun murakkabliklarga olib keldi, chunki bular model va view o'rtasidagi ma'lumotlar sinxronizatsiyasini tushunishda qiyinchilik tug'dirardi. Bundan tashqari, ichki kontrollerlarda parent scope’dan meros olishi mumkin edi, bu esa ma'lum bir xususiyati qayerda belgilanganini yoki o'zgartirilganini kuzatishni qiyinlashtirgan. Ushbu meros olish kutilmagan side effect’larga olib kelishi mumkin edi, ayniqsa, ichki qamrov(scope)lar ota va bola qamrovlarining o'zaro ta'siridan noxush natijalar tug'ilganda. Qamrovlar iyerarxiyasi tushunchasi va uning asosidagi prototip meros olish, JavaScriptda mavjud bo'lgan ko'proq an'anaviy leksik qamrov qilish qoidalari bilan mos kelmas edi, bu esa yana bir o'rganish murakkabligini qo'shgan edi. Misol uchun, Reactda state kerakli komponent bilan bir joyda saqlanadi va bu muammoni butunlay bartaraf etadi. Cheklangan development vositalari AngularJS debugging va ishlash samaradorligini profillash(performance profiling) uchun keng imkoniyatlarni taqdim etuvchi vositalarni taklif qilmadi. Ayniqsa, React DevTools bilan taqqoslaganda, masalan, Replay.io kabi vositalar React ilovalari uchun vaqt bo'ylab debugging imkoniyatlarini kengaytiruvchi imkoniyatlarni taqdim etadi.",
    "url": "/books/fluent-react/entry-level-stuff/angular/page",
    "category": "books",
    "tags": [
      "fluent-react",
      "tutorial",
      "guide",
      "react",
      "javascript",
      "frontend",
      "edi",
      "angularjs",
      "bog",
      "bilan",
      "uchun",
      "bir",
      "ning",
      "katta",
      "lgan",
      "dependency",
      "qildi",
      "react",
      "chunki",
      "esa",
      "kabi"
    ]
  },
  {
    "id": "book-fluent-react-entry-level-stuff-backbone-page",
    "title": "Backbone.js Tahlili: MVC Patterni va React'ning Yechimlari",
    "content": "Backbone’ning rivojlanishi Backbone, 2010-yillar boshida ishlab chiqilgan bo'lib, React paydo bo'lishidan avval veb-dasturlarda uchraydigan bir qancha muammolarga yechim edi: brauzer va JavaScript o'rtasidagi uyg'unlik yo'qligi holati, kodni qayta ishlatish, testlash imkoniyati va boshqalar. Bu juda sodda va samarali yechim bo'lib, “model” va “view” yaratish imkonini beradigan kutubxona edi. Backbone o'zining MVC (Model-View-Controller) design pattern(dizayn namunasi) bo'yicha yondashuvini yaratdi (rasmga qarang). Keling, bu patternni yaxshiroq tushunish uchun MVC haqida qisqacha to'xtalib o'taylik. !MVC pattern image MVC pattern MVC pattern’i bu dasturiy ta'minotni uchta o'zaro bog'langan komponentga bo'lish orqali ichki ma'lumotlar ko'rinishini foydalanuvchiga qanday ko'rsatilishi yoki undan qabul qilinishidan ajratishni ta'minlaydi. Bu uchta komponent quyidagilardir: - Model: Model dasturdagi ma'lumotlar va biznes logikalari uchun mas’ul bo'ladi. U View va Controller haqida hech narsa bilmaydi, ya'ni biznes logikasi foydalanuvchi interfeysidan to'liq izolyatsiyalangan bo'ladi. - View: View foydalanuvchi interfeysini ifodalaydi. U Modeldan olingan ma'lumotlarni foydalanuvchiga ko'rsatadi va foydalanuvchi buyruqlarini Controller’ga yuboradi. View passivdir, ya'ni u Model’dan ma'lumot kelishini kutadi va ma'lumotni o'zi qabul(fetch) qilmaydi yoki saqlamaydi. Bundan tashqari, foydalanuvchi interaktivligini mustaqil boshqarmaydi, bu vazifani Controller’ga topshiradi. - Controller: Controller Model va View o'rtasidagi interfeys rolini o'ynaydi. U View’dan kelgan foydalanuvchi kiritgan ma'lumotlarini qayta ishlaydi (masalan, Model’ni yangilaydi) va natijani View’ga qaytaradi. Controller Model’ni Viewd’an ajratib, tizimning arxitekturasini ko'proq moslashuvchan qiladi. MVC pattern’ining asosiy afzalligi — bu ma'suliyatlarni ajratish(separation of concerns) bo'lib, biznes logikasi, foydalanuvchi interfeysi va foydalanuvchi kiritgan ma'lumotlarini turli kod qismlariga ajratish imkoniyatini beradi. Bu nafaqat dasturni modulli qiladi, balki uni osonroq boshqarish, kengaytirish va test qilish imkonini beradi. Ushbu pattern veb-dasturlarda keng qo'llaniladi, Django, Ruby on Rails va ASP.NET MVC kabi ko'plab freymvorklar bu pattern’ni qo'llab-quvvatlaydi. MVC patterni ko'p yillar davomida dasturiy ta'minot dizaynida muhim rol o'ynab kelgan, xususan, veb-dasturlashda. Biroq, veb-dasturlar rivojlanib borgan sari va foydalanuvchilarning interaktiv va dinamik interfeyslarga bo'lgan talablari oshgani sayin, an’anaviy MVC’ning ba'zi cheklovlari yuzaga chiqa boshladi. Quyida MVC’ning ba'zi kamchiliklari va React ularni qanday hal qilishini ko'rib chiqamiz: Murakkab interaktivlik va state menejment An'anaviy MVC arxitekturasi ko'p interaktiv elementlarga ega murakkab foydalanuvchi interfeyslarini boshqarishda qiyinchiliklarga duch keladi. Dastur kengaygan sari state o'zgarishlarini boshqarish va ularning interfeysning turli qismlariga ta'siri murakkablashib boradi. Controller’lar soni ortishi mumkin va ba'zida ular boshqa Controller’lar bilan mos kelmasligi yoki Controller’lar noto'g'ri View’larni boshqarishi mumkin. Shu bilan birga, MVC komponentlari o'rtasidagi ajratish proyekt kodida aniq ifodalanmagan bo'lishi mumkin. React, o'zining komponentlarga asoslangan arxitekturasi va virtual DOM bilan, state o'zgarishlarini boshqarishni va ular interfeysga qanday ta'sir qilishini soddalashtiradi. React bu jarayonni soddalashtirib, UI komponentlarini funksiyalarga o'xshash kabi qiladi: ular input(props)’ni qabul qiladi va inputga asoslangan holda output(elementlar)’ni qaytaradi. Bu aqlli model MVC pattern’ni sezilarli darajada soddalashtiradi, chunki JavaScript’da funksiyalar keng qo'llaniladi va ular MVC kabi tashqi aqlli modellarga qaraganda osonroq tushuniladi. Ikki tomonlama ma'lumotni bog'lash Ba'zi MVC freymvorklari ikki tomonlama ma'lumot bog'lash(two-way data binding)ni qo'llaydi, bu esa ehtiyotsizlik bilan boshqarilsa, kutilmagan \"side effect\"larga olib kelishi mumkin, ya'ni ba'zan View Model bilan mos kelmay qolishi yoki aksincha bo'lishi mumkin. Bundan tashqari, ikki tomonlama ma'lumot oqimida ma'lumotlarga egalik qilish masalasi ko'pincha aniq javobga ega bo'lmaydi va ma'suliyatlar ajratilishi noaniq bo'lib qoladi. Bu ayniqsa qiziq, chunki MVC qo'llaniladigan loyihalarda ma'suliyatlarni to'g'ri ajratishni to'liq tushungan jamoalar uchun juda samarali model bo'lib qolsa-da, bu qoidalar tezkor development va jadal o'sish(rapid startup) jarayonida kamdan-kam hollarda to'liq qo'llaniladi. Natijada, MVC’ning eng katta kuchli tomonlaridan biri bo'lgan ma'suliyatlarni ajratish, qo'llashdagi sustkashlik tufayli zaif tomoniga aylanishi mumkin. React esa ikki tomonlama ma'lumot bog'lashga qarama-qarshi bo'lgan bir tomonlama ma'lumot oqimi(unidirectional data flow) pattern’ini qo'llaydi, bu esa ma'lumot oqimini tartibga solish va bir yo'nalishda harakatlanishini ta'minlashga kuchli ahamiyat beradi. Ushbu yondashuv foydalanuvchi interfeysini yangilashni prognoz qilishni osonlashtiradi, ma'suliyatlarni aniqroq ajratish imkonini beradi va natijada tezkorlik bilan o'sib borayotgan dasturiy jamoalar uchun samarali bo'ladi. Kuchli bog'lanish Ba'zi MVC arxitekturalarida Model, View, va Controller komponentlari bir-biriga kuchli ravishda bog'liq bo'lib(tight coupling) qolishi mumkin. Bu esa birini o'zgartirish yoki qayta ishlashda boshqalarga ta'sir qilishni qiyinlashtiradi. React esa o'zining komponentga asoslangan modeli orqali modulli va ajratilgan yondashuvni rag'batlantiradi. Bu yondashuv UI komponentlariga yaqin bog'liqliklarni joylashtirishni qo'llab-quvvatlaydi va bu orqali dasturni kengaytirish va qayta ishlashni osonlashtiradi. Bu pattern’ning tafsilotlariga juda chuqur kirishishimiz shart emas, chunki bunda asosan React haqida gaplashamiz, lekin bizning maqsadlarimiz uchun model’lar kontseptual jihatdan ma'lumot manbalari sifatida tasavvur qilingan, view’lar esa foydalanuvchi interfeyslari bo'lib, ular bu ma'lumotlarni iste'mol qilib, render qiladi. Backbone bu model va view’lar bilan ishlash uchun qulay API’larni eksport qilar edi va model va view’larni bir-biriga ulash yo'lini taqdim etardi. Bu yechim o'z davrida juda kuchli va moslashuvchan edi. Shuningdek, bu yechim foydalanishda kengaytirilishi mumkin bo'lgan va dasturchilarga kodni izolyatsiyalashda test qilishga imkon beruvchi yechim edi. Backbone’da \"Like\" button misoli Endi oldingi \"Like\" tugmasi misolimizni Backbone yordamida ko'rib chiqamiz: Diqqat qilinsa, bu yerda dan meros oladi va unda metodi mavjud, bu esa ni qaytaradi. Reactda ham shunga o'xshash metodini ko'ramiz, lekin bu haqida keyinroq gaplashamiz. Bu yerda yana bir narsani ta'kidlash joizki, Backbone aslida metodining haqiqiy amalga oshirilishini o'z ichiga olmaydi. Buning o'rniga, siz DOM’ni qo'lda o'zgartirishingiz yoki Handlebars kabi namuna tizimidan foydalanishingiz kerak edi. Backbone dasturchilarga obyektlarda logikani joylashtirish imkonini beruvchi zanjirli API’ni ochib berdi. Oldingi misol bilan solishtirsak, Backbone yordamida interaktiv tugma yaratish va foydalanuvchi interfeysi(UI)ni event’larga javoban yangilash ancha qulay bo'lganini ko'ramiz. Test qilish Shuningdek, Backbone logikani birlashtirib, bu jarayonni ancha strukturalashgan holga keltiradi. Bundan tashqari, Backbone yordamida ushbu tugmani izolyatsiyalangan holda test qilish osonlashadi, chunki biz namunasini yaratib, uning metodini chaqirib test qilishimiz mumkin. Ushbu komponentni quyidagicha test qilishimiz mumkin: Biz hatto button’ning holati o'zgarganidan keyingi harakatini, masalan, click event’i holatida ham test qilishimiz mumkin: Shu sababdan Backbone o'z vaqtida juda mashhur yechim bo'lgan. Muqobil yechim esa ko'p kod yozishni talab qilgan, bu kodni test qilish ham qiyin bo'lgan va uning kutilganidek ishlashiga hech qanday kafolat bo'lmagan. Shu bois Backbone bu masalaga juda kutilgan va mos yechim bo'lgan. Ba'zi tanqidlar Mashhurligining dastavvalida o'zining soddaligi va moslashuvchanligi bilan mashhur bo'lgan bo'lsa-da, u ham ba'zi tanqidlardan xoli emas edi. Quyida Backbone.js bilan bog'liq ba'zi salbiy jihatlar: - Boilerplate va ortiqcha kod: Backbone.js’ning tanqidlarga sabab bo'lgan jihatlardan biri, ko'pincha ko'p miqdorda qayta-qayta takrorlanadigan(boilerplate) kod yozishni talab qiladi. Oddiy dasturlar uchun bu muammo bo'lmasligi mumkin, lekin dastur kattalashgan sari boilerplate kod ham ortadi, bu esa ortiqcha va qiyin boshqariladigan kodga olib keladi. - Ikkit tomonlama ma'lumot bog'lashning yo'qligi: Ba'zi zamondoshlaridan farqli ravishda, Backbone.js ichki o'rnatilgan(built-in) ikki tomonlama ma'lumot bog'lash(two-way data binding)ni taklif qilmaydi. Bu shuni anglatadiki, agar ma'lumot o'zgarsa, DOM avtomatik ravishda yangilanmaydi va aksincha. Dasturchilar bunday funksionallikni qo'shish uchun ko'pincha maxsus kod yozishlari yoki plaginlardan foydalanishlari kerak. - Event’larga asoslangan arxitektura (Event-driven architecture): Modeldagi ma'lumotlarning yangilanishi butun dastur bo'ylab ko'plab event’larni qo'zg'atishi mumkin. Bu event’lar zanjiri boshqarilmas holga kelishi mumkin va ma'lumotning bir qismi o'zgarganda bu butun dasturga qanday ta'sir qilishini aniqlash, debug qilish va maintain qilish qiyin bo'lishi mumkin. Ushbu muammolarni hal qilish uchun dasturchilar butun dastur bo'ylab ko'pincha ehtiyotkorlik bilan event boshqaruv amaliyotlarini qo'llashlari kerak bo'lgan. - Kompozitsiyaning yetishmasligi: Backbone.js ichma-ich \"view\"larni osonlikcha joylashtirish uchun o'zini ichki o'rnatilgan funksiyalariga ega emas, bu esa murakkab foydalanuvchi interfeyslarini yaratishni qiyinlashtiradi. React esa, aksincha, \"children props\" yordamida komponentlarni osongina joylashtirishni ta'minlaydi, bu esa murakkab UI ierarxiyalarini yaratishni osonlashtiradi. Marionette.js, Backbone’ning kengaytmasi, ushbu kompozitsiya muammolarining ba'zilarini hal qilishga uringan, lekin u React’ning komponent modeli kabi integratsiyalashgan yechimni ta'minlamaydi. Zero, Backbone.js o'ziga xos muammolarga ega bo'lsa ham, hech qanday vosita yoki freymvork mukammal emasligini unutmaslik kerak. Eng yaxshi tanlov ko'pincha loyihani ehtiyojlariga va jamoaning afzalliklariga bog'liq. Shuningdek, veb-dasturlash vositalari kuchli jamoaga tayanishi kerakligini ta'kidlash joiz, afsuski, Backbone.js so'nggi yillarda, ayniqsa React paydo bo'lishi bilan, ommaviyligini yo'qotdi. Ayrimlar hatto React uni \"o'ldirdi\" deb aytishadi, lekin bu masala bo'yicha yakuniy hukmni keyinga qoldiramiz.",
    "url": "/books/fluent-react/entry-level-stuff/backbone/page",
    "category": "books",
    "tags": [
      "fluent-react",
      "tutorial",
      "guide",
      "react",
      "javascript",
      "frontend",
      "backbone",
      "mvc",
      "view",
      "model",
      "mumkin",
      "react",
      "foydalanuvchi",
      "bilan",
      "esa",
      "controller",
      "bog",
      "ning",
      "pattern",
      "uchun",
      "lumot"
    ]
  },
  {
    "id": "book-fluent-react-entry-level-stuff-enter-react-page",
    "title": "React'ning Paydo Bo'lishi: Yangi Arxitektura va G'oyalar",
    "content": "React’ning paydo bo'lishi Aynan shu davrda React mashhurlik kasb eta boshladi. React taqdim etgan asosiy g'oyalardan biri bu komponentga asoslangan arxitektura edi. Garchi amalga oshirish boshqacha bo'lsa-da, asosiy g'oya shunday edi: veb va boshqa platformalar uchun foydalanuvchi interfeyslarini qayta foydalanish mumkin bo'lgan komponentlar orqali yaratish optimal usuldir. AngularJS va React’ning farqi AngularJS model’ni view bilan bog'lash uchun direktivalardan foydalangan bo'lsa, React JSX va ancha soddalashtirilgan komponent modelini joriy qildi. Biroq, AngularJS komponentga asoslangan arxitekturani Angular modullari orqali ommalashtirmaganida, ba'zilar fikricha, React’ning modeliga o'tish bunchalik oson bo'lmagan bo'lardi. AngularJS’ning ikki tomonlama ma'lumotlarni bog'lash modeli sanoat standarti edi, ammo bu yirik ilovalarda ba'zi kamchiliklarga, masalan, performance muammolariga olib kelishi mumkin edi. React bu tajribadan saboq olib, bir tomonlama ma'lumot oqimi modelini kiritdi, bu esa dasturchilarga o'z ilovalarini yanada yaxshi nazorat qilish imkonini berdi va vaqt o'tishi bilan ma'lumotlarning qanday o'zgarishini tushunishni osonlashtirdi. React shuningdek, virtual DOM’ni taqdim etdi: bu konsepsiya to'g'ridan-to'g'ri DOM’ni boshqarishni minimallashtirish orqali samaradorlikni oshirdi. AngularJS esa DOM’ni bevosita boshqarar edi, bu esa performance’ga salbiy ta'sir ko'rsatishi va jQuery bilan avval muhokama qilingan kabi mavhum holatlar keltirib chiqarishi mumkin edi. Shunday bo'lsa-da, AngularJS veb-dasturlash amaliyotlarida katta o'zgarish kiritdi va AngularJS nafaqat veb-dasturlash sohasida inqilob qilgan, balki kelajakdagi freymvork va kutubxonalar, jumladan, React uchun yo'l ochganini ta'kidlash o'rinlidir. BoltJS va React’ning paydo bo'lishi Endi React’ning bu o'zgarishlarga qanday mos kelganini va u qayerdan paydo bo'lganini o'rganamiz. O'sha paytda foydalanuvchi interfeyslarini yangilash haligacha murakkab va yechilmagan masala edi. Bugungi kunda ham bu masala to'liq hal etilmagan, ammo React uni ancha osonlashtirdi va SolidJS, Qwik kabi boshqa kutubxonalarni ham ushbu yo'nalishda ilhomlantirdi. Meta (Facebook) ham foydalanuvchi interfeysi murakkabligi va kengayish masalasidan xoli emas edi. Natijada, Meta o'sha paytda mavjud bo'lgan yechimlarni to'ldiruvchi bir qator ichki yechimlarni yaratdi. Birinchilardan biri BoltJS edi: Facebook dasturchilari buni o'zlariga yoqqan bir qancha narsalarni “bolt” qilib yig'ib qo'yilgan vosita deb atashar edi. Foydalanuvchi interfeysini yangilashini qulaylashtirish va ko'proq intuitiv qilish uchun uchun vositalar to'plami yaratildi. Shu vaqtlar Facebook dasturchisi Jordan Walke amaldagi vaziyatdan kelib chiqib, u davr uchun butunlay yangi bo'lgan bir g'oyani ilgari surdi va yangilanishlar sodir bo'lganda sahifalarning minimal qismlarini yangi qismlar bilan almashtirish taklifini berdi. Avval ko'rganimizdek, JavaScript kutubxonalari foydalanuvchi interfeyslari (views) va ma'lumotlar manbalari (models) o'rtasidagi munosabatlarni ikki tomonlama ma'lumotlarni bog'lash modeli yordamida boshqarar edi. Ushbu modelning cheklovlarini hisobga olgan holda, Jordanning taklifi bir tomonlama ma'lumotlar oqimi modelidan foydalanish edi. Bu model ancha sodda edi va view va model’ni sinxronlashtirish osonroq bo'ldi. Bu React’ning asosini tashkil qiladigan bir tomonlama arxitektura paydo bo'lishiga olib keldi.",
    "url": "/books/fluent-react/entry-level-stuff/enter-react/page",
    "category": "books",
    "tags": [
      "fluent-react",
      "tutorial",
      "guide",
      "react",
      "javascript",
      "frontend",
      "react",
      "edi",
      "ning",
      "angularjs",
      "uchun",
      "bir",
      "paydo",
      "foydalanuvchi",
      "tomonlama",
      "bilan",
      "lishi",
      "arxitektura",
      "lsa",
      "veb",
      "mumkin"
    ]
  },
  {
    "id": "book-fluent-react-entry-level-stuff-flux-architecture-page",
    "title": "Flux Arxitekturasi: React'da Bir Tomonlama Ma'lumot Oqimi",
    "content": "Flux arxitekturasi Flux — bu Facebook (hozirgi Meta) tomonidan ommalashtirilgan, klient tomonidagi (client-side) veb-ilovalarni yaratish uchun mo'ljallangan arxitekturaviy dizayn pattern hisoblanadi(rasmga qarang). U ilova ichidagi ma'lumotlar oqimini prognozli qilish uchun bir tomonlama ma'lumot oqimini ta'minlaydi. !Flux architecture image Flux arxitekturasining asosiy tushunchalari quyidagilardan iborat: Actions (Harakatlar) Actions — bu yangi ma'lumotlarni va ularni aniqlovchi tip xususiyatini o'z ichiga olgan oddiy obyektlar. Ular tizimga kiruvchi tashqi va ichki ma'lumotlarni ifodalaydi, masalan, foydalanuvchi bilan o'zaro ta'sirni, server javoblari va form input’lari. Action’lar markaziy Dispatcher orqali turli Store’larga uzatiladi: Dispatcher (Dispetcher) Dispatcher — bu Flux arxitekturasining markaziy qismi. U action’larni qabul qiladi va ularni ilovadagi ro'yxatdan o'tgan store’ga uzatadi. U callback(qayta chaqirish funksiyalar)’lar ro'yxatini boshqaradi va har bir store o'zini va o'zining callback funksiyasini dispetcher’ga ro'yxatdan o'tkazadi. Action jo'natilganda, u barcha ro'yxatdan o'tgan callback’larga yuboriladi: Stores (Saqlovchilar) Store’lar ilovaning holati va logikasini saqlaydi. Ular MVC arxitekturasidagi modellarga biroz o'xshaydi, lekin ko'plab obyektlarning holatini boshqaradi. Store'lar dispetcher bilan ro'yxatdan o'tadi va action’larni qayta ishlash uchun callback funksiyalarini taqdim etadi. Store’ning holati yangilanganda, u o'zgarish sodir bo'lganini bildirish uchun views’ga change(o'zgarish) event’ini tarqatadi: Views (Ko'rinishlar) Views — bu React komponentlari. Ular store’dan keladigan o'zgarish event’larini tinglaydi va ularga bog'liq bo'lgan ma'lumotlar o'zgarganda o'zlarini yangilaydi. Shuningdek, ular tizim holatini yangilash uchun yangi action’lar yaratishi mumkin, shu tariqa ma'lumotlarning bir tomonlama aylanishini shakllantiradi. Flux arxitekturasi tizim bo'ylab bir tomonlama ma'lumot oqimini rag'batlantiradi, bu esa vaqt o'tishi bilan o'zgarishlarni kuzatishni osonlashtiradi. Ushbu prognozlilik(predictibility) xususiyati keyinchalik kodni yanada optimallashtirish uchun kompilyatorlar uchun asos bo'lib xizmat qilishi mumkin, masalan, React Forget bilan (bu haqida keyinroq batafsil gaplashamiz). Flux arxitekturasining afzalliklari Flux arxitekturasi veb-ilovalardagi murakkablikni boshqarish va ularni oson maintain bo'lishini ta'minlashda turli xil foydali jihatlar keltiradi. Quyida ba'zi muhim afzalliklari keltirilgan: - Yagona ishonch manbai (Single source of truth): Flux ilovaning state’ini bir markaziy boshqaruvda saqlashni ta'kidlaydi, bu store’larda saqlanadi. Ushbu markazlashtirilgan state menejmenti ilovaning xatti-harakatini prognoz qilish mumkin va bu tushunishni osonlashtiradi. Bu ko'p, o'zaro bir-biriga bog'liq bo'lgan markazlashtirilgan manbalar bilan bog'liq muammolarni bartaraf etadi, chunki bu xatoliklar va ilovada o'zaro mos kelmaydigan holatga olib kelishi mumkin. - Testlanuvchanlik: Flux’ning aniq strukturalari va prognoz qilinadigan ma'lumotlar oqimi ilovani juda testlanuvchan qiladi. Tizimning turli qismlari (masalan, actio’nlar, dispetcher, store’lar va view’lar) orasidagi ma'suliyatlarni ajratish har bir qismni alohida unit testlashni osonlashtiradi. Bundan tashqari, ma'lumotlar oqimi bir tomonlama bo'lganda va state ma'lum, prognoz qilish mumkin bo'lgan joylarda saqlanganda, test yozish ancha oson bo'ladi. - Ma'suliyatlarni ajratish (Separation of concerns, SoC): Flux, yuqorida aytilganidek, tizimning turli qismlarining ma'suliyatlarini aniq ajratib qo'yadi. Ushbu ajratish tizimni yanada modulli, maintain qilishni va tushunishni oson qiladi. Har bir qism aniq belgilangan ma'suliyatga ega va bir tomonlama ma'lumotlar oqimi bu qismlar qanday o'zaro aloqada bo'lishini aniq ko'rsatib beradi. Flux arxitekturasi mustahkam, kengaytiriladigan va oson maintain qilinadigan veb-ilovalar qurish uchun ishonchli poydevor taqdim etadi. Uning bir tomonlama ma'lumotlar oqimi, markaziy boshqaruvi va ma'suliyatlarning ajratilishiga urg'u berishi, ilovalarni ishlab chiqish, testlash va debug qilishni ancha osonlashtiradi.",
    "url": "/books/fluent-react/entry-level-stuff/flux-architecture/page",
    "category": "books",
    "tags": [
      "fluent-react",
      "tutorial",
      "guide",
      "react",
      "javascript",
      "frontend",
      "flux",
      "bir",
      "store",
      "uchun",
      "tomonlama",
      "lar",
      "lumotlar",
      "arxitekturasi",
      "bilan",
      "action",
      "mumkin",
      "oqimi",
      "ular",
      "zaro",
      "markaziy"
    ]
  },
  {
    "id": "book-fluent-react-entry-level-stuff-jquery-page",
    "title": "jQuery Tahlili: React'dan Oldingi Davrda Veb-ishlab Chiqish",
    "content": "jQuery Keling, veb texnologiyalaridagi ba'zi muammolarni React paydo bo'lishidan oldin qanday hal qilinganligini ko'rib chiqaylik va nega React muhimligini tushunamiz. Biz dastlab jQuery bilan boshlaymiz va oldingi _Like_ tugmasi misolimizni qayta ko'rib chiqamiz. jQuery’ning yechim bo'lishi Qisqacha eslatma, bu yerda biz brauzerdagi _Like_ tugmasinni interaktiv qilishni xohlaymiz: jQuery yordamida bu buttonga “like” funksiyasini quyidagicha qo'shamiz: Ushbu misoldan ko'rinib turibdiki, biz ma'lumotlarni foydalanuvchi interfeysiga bog'laymiz va bu ma'lumotlar orqali interfeysni yangilaymiz. jQuery bir vosita sifatida foydalanuvchi interfeysini to'g'ridan-to'g'ri boshqarishda juda faol. jQuery’ning kamchiliklari jQuery o'z nazorati ostida bo'lmagan state bilan o'zaro aloqada bo'ladi va tashqaridan doimiy ravishda o'zgartirib turadi, bu esa og'ir \"side-effect\"larga olib keladi. Biz buni \"side-effect\" deb ataymiz, chunki kodning boshqa joylaridan, hatto masofaviy skriptlar orqali ham sahifaning strukturasini bevosita va global ravishda o'zgartirish mumkin. Bu esa oldindan bilib bo'lmaydigan xatti-harakatlarga va kuzatish qiyin bo'lgan murakkab o'zaro ta'sirlarga olib kelishi mumkin. Sahifaning bir qismidagi o'zgarishlar boshqa qismlarga kutilmagan ta'sirlarni ko'rsatishi mumkin, bu esa kodni maintain(davom ettirish) qilish va xatolarni tuzatish(debug)ni qiyinlashtiradi. Zamonaviy freymvorklar bu muammolarni to'g'ridan-to'g'ri DOM bilan ishlashdan voz kechish orqali hal qiladi. O'sha davrda bu o'zgaruvchan va tuzilmaga ega bo'lmagan yondashuv keng tarqalgan edi, va dastur holati har doim o'zgarib turishi sababli, kodning ayni damdagi holatini aniqlash va test qilish qiyin bo'lgan. Ba'zi paytlar bo'lardiki, biz o'zimizga-o'zimiz savol berishimiz kerak edi:\"hozir dasturimizning brauzerdagi holati qay ahvolda?\" - bu savolga javob berish dasturimizni murakkabligi oshgani sayin qiyinlashib ketardi. jQuery’ni test qilishning qiyinchiliklari Bundan tashqari, jQuery bilan tugmani test qilish ham qiyin, chunki bu faqat event handler’dan iborat. Agar test yozadigan bo'lsak, u quyidagicha ko'rinadi: Bu yerda yagona muammo shundaki, test muhitida qiymat qaytaradi, chunki bu haqiqiy brauzer emas. Ushbu kodni test qilish uchun brauzer muhitini sun'iy ravishda yaratish kerak bo'ladi, bu esa juda ko'p mehnat talab qiladi. Bu jQuery bilan bog'liq keng tarqalgan muammo: uni test qilish qiyin, chunki u qo'shadigan xatti-harakatlarni izolyatsiyalab, ajratib olish qiyin. jQuery, shuningdek, brauzer muhiti bilan kuchli bog'liq bo'lib, brauzer foydalanuvchi interfeysiga egalik qilsa-da, jQuery shunchaki mehmon hisoblanadi. Bu \"bir tomonlama ma'lumot oqimi\"(one-way data flow) paradigmasidan og'ish jQuery va o'sha davr uchun keng tarqalgan muammolardan biri edi. jQuery’ning ommaviyligini yo'qotish sabablari Oxir-oqibat, veb-texnologiyalar rivojlanishi bilan jQuery o'z ommaviyligini yo'qota boshladi, chunki kuchliroq va kengaytiriladigan yechimlar zarur bo'lib qoldi. jQuery hali ham ko'plab foydalanish(production) dasturlarida qo'llanilsa-da, zamonaviy veb-dasturlarni yaratishda endi asosiy yechim emas. Quyida jQuery’ning mashhurligi pasayishiga sabab bo'lgan ba'zi omillarni keltiramiz: Yuklama va tezlik jQuery’ga bo'lgan muhim tanqidlardan biri uning hajmi edi. jQuery kutubxonasini to'liq integratsiya qilish veb-loyihalarga qo'shimcha yuklama keltiradi, bu esa ayniqsa tez yuklanishni maqsad qilgan saytlar uchun ortiqcha yuklama bo'lishi mumkin. Bugungi mobil internet davrida, ko'plab foydalanuvchilar sekin yoki cheklangan ma'lumot ulanishiga ega bo'lishi mumkin, shuning uchun har bir kilobayt muhimdir. jQuery kutubxonasini to'liq qo'shilishi mobil foydalanuvchilar uchun saytning ishlashiga salbiy ta'sir ko'rsatishi mumkin. React paydo bo'lishidan oldin, jQuery va Mootools kabi kutubxonalar uchun konfiguratsiya variantlarini taklif qilish keng tarqalgan edi, bu foydalanuvchilarga faqat kerakli funksionalliklarni tanlay olish imkoni berardi. Bu kamroq kodni yuklashga yordam bergan bo'lsa-da, dasturchilar uchun qaror qabul qilishni va umumiy development jarayonini murakkablashtirgan. Zamonaviy brauzerlarda ortiqchalik jQuery birinchi paydo bo'lganida, u turli brauzerlar o'rtasidagi noaniqliklarni bartaraf etishda va elementlarni tanlash va o'zgartirishda dasturchilarga yagona yo'lni taqdim etishda katta yordam bergan. Veb rivojlanib borgan sari brauzerlar ham rivojlandi. jQuery bo'lishini zarur qilgan ko'plab imkoniyatlar, masalan, DOM manipulatsiyasi yoki ma'lumot olish uchun tarmoqqa yo'naltirilgan(network-oriented) funksiyalar, hozirda zamonaviy brauzerlarni o'zi tomonidan qo'llab-quvvatlanmoqda. Bugungi veb ishlab chiqishda jQuery’dan foydalanish ortiqcha, keraksiz murakkablik qo'shishi mumkin. Masalan, jQuery’ning ichki selector API’sini o'rniga osonlik bilan ishlatilishi mumkin. Performance bo'yicha mulohazalar jQuery ko'plab vazifalarni soddalashtirsa-da, bu ko'pincha performance’ni pasaytirishi hisobiga amalga oshadi. Zamonaviy brauzerlarda JavaScript’ning o'zini \"Native runtime-level\" metodlari har bir yangilanishi bilan yaxshilanib takomillashadi va shu sababli ba'zi hollarda jQuery’dan ko'ra tezroq ishlashi mumkin. Kichik loyihalarda bu farq sezilmasligi mumkin, lekin yirik va murakkab veb-dasturlarda bu murakkabliklar to'planib, sezilarli darajada performance’ni susayishiga yoki javob berish tezligining pasayishiga olib kelishi mumkin. Yuqoridagi sabablar tufayli, jQuery veb evolyutsiyasida muhim rol o'ynagan va dasturchilar duch kelishi mumkin bo'lgan ko'plab muammolarni soddalashtirgan bo'lsa-da, zamonaviy veb dunyosida jQueryga endi kamroq ish tushyapti. Dasturchi sifatida biz jQuery’ning ijobiy va salbiy tomonlarini solishtirib ko'rishimiz kerak, ayniqsa, zamonaviy veb loyihalar kontekstida. jQuery’ning inqilobiy roli jQuery’ning kamchiliklariga qaramay, u o'sha paytda DOM bilan ishlashda haqiqiy inqilob bo'lgan. Bu shunday darajaga chiqdiki, boshqa kutubxonalar ham jQuery’ni qo'llab, lekin unga ko'proq prognoz qilishlik va qayta foydalanishlik imkoniyatlarini qo'shgan holda paydo bo'la boshladi. Bunday kutubxonalardan biri Backbone edi, bu kutubxona React bugungi kunda hal qilayotgan muammolarni o'z vaqtida hal qilishga harakat qilgan. Keling, bunga yanada batafsil kirishamiz.",
    "url": "/books/fluent-react/entry-level-stuff/jquery/page",
    "category": "books",
    "tags": [
      "fluent-react",
      "tutorial",
      "guide",
      "react",
      "javascript",
      "frontend",
      "jquery",
      "mumkin",
      "veb",
      "bilan",
      "ning",
      "uchun",
      "qilish",
      "zamonaviy",
      "test",
      "biz",
      "lgan",
      "edi",
      "react",
      "bir",
      "esa"
    ]
  },
  {
    "id": "book-fluent-react-entry-level-stuff-knockout-page",
    "title": "KnockoutJS Tahlili: MVVM Patterni va Reaktivlikning Boshlanishi",
    "content": "KnockoutJS’ning rivojlanishi Keling, ushbu yondashuvni o'sha paytda keng tarqalgan boshqa bir mashhur yechim — KnockoutJS bilan solishtiramiz. KnockoutJS 2010-yillar boshlarida yaratilgan va u \"observables\"(kuzatiladigan narsalar) va \"bindings\"(bog'lashlar) yaratish uchun imkoniyat bergan kutubxona edi. Bu usul har safar state o'zgarganda bog'liqlikni kuzatib borishni ta'minlardi. KnockoutJS eng dastlabkilardan yoki birinchi bo'lgan reaktiv JavaScript kutubxonalaridan biri edi. Bu yerda reaktivlik deganda, qiymatlar observables usulida state o'zgarishlariga javob berib yangilanishi tushuniladi. Zamonaviy reaktivlik usullari ba'zan \"signallar\" deb ataladi va ular Vue.js, SolidJS, Svelte, Qwik, hamda zamonaviy Angular kabi kutubxonalarda keng qo'llaniladi. Observables tushunchasi bu — kuzatilishi mumkin bo'lgan ma'lumot manbai, bindings esa — ushbu ma'lumotni iste'mol qiladigan va uni foydalanuvchi interfeysida ko'rsatadigan elementlar edi: observables modelga o'xshar edi, bindings esa view vazifasini bajarardi. Ammo, biz oldinroq muhokama qilgan MVC (Model-View-Controller) pattern’ining bir oz rivojlangan shakli sifatida, KnockoutJS Model-View-ViewModel yoki MVVM pattern’ga yaqinroq ishlardi (rasmga qarang). Keling, bu pattern’ni batafsilroq tushunishga harakat qilamiz. !MVVM pattern image MVVM pattern MVVM (Model-View-ViewModel) patterni — bu o'ziga xos arxitektura dizaynidir va ayniqsa WPF va Xamarin platformalarida yaratilgan murakkab foydalanuvchi interfeyslari uchun mashhurdir. Bu, an'anaviy MVC patternining rivojlangan shakli bo'lib, zamonaviy UI dasturlash platformalariga moslashtirilgan. Quyida MVVM tarkibiy qismlarini qisqacha ko'rib chiqamiz: Model - Dasturning ma'lumotlari va biznes logikalarini ifodalaydi. - Ma'lumotlarni olish, saqlash va qayta ishlash uchun javobgardir. - Odatda, u ma'lumotlar bazasi, servislar yoki boshqa ma'lumot manbalari bilan ishlaydi. - View va ViewModel bilan bog'liq emas, ulardan bexabar. View - Dasturning foydalanuvchi interfeysi(UI)ni ifodalaydi. - Foydalanuvchiga ma'lumotni ko'rsatadi va foydalanuvchi kiritgan ma'lumotlarni qabul qiladi. - MVVM’da View passiv hisoblanadi va hech qanday dastur logikasiga ega emas. Buning o'rniga, u ViewModel bilan deklarativ tarzda bog'lanadi va ma'lumotlarni bog'lash mexanizmlari orqali avtomatik ravishda o'zgarishlarni aks ettiradi. ViewModel - Model va View o'rtasidagi ko'prik vazifasini bajaradi. - View uchun ma'lumotlar va buyruqlarni ko'rsatadi. Bu ma'lumotlar ko'pincha tayyor ko'rinishga ega formatda bo'ladi. - Foydalanuvchi kiritgan ma'lumotlarni boshqaradi, ko'pincha buyruq pattern’i orqali. - Prezentatsiya logikasini o'z ichiga olib, ma'lumotlarni Model’dan olib, View’da osongina ko'rinadigan formatga aylantiradi. - Muhimi, ViewModel ishlatilayotgan maxsus View’dan bexabar, bu esa mustaqil arxitekturani yaratishga imkon beradi. MVVM pattern’ining afzalliklari MVVM pattern’ining asosiy afzalligi MVC’ga o'xshash ma'suliyatlarni ajratish prinsipi hisoblanadi, bu quyidagi yutuqlarga olib keladi: - Testlash qulayligi: ViewModel va View o'rtasidagi mustaqillik UI’ni ishtirok ettirmasdan unit testlar yozishni osonlashtiradi. - Qayta foydalanish qulayligi: ViewModel turli ko'rinishlar yoki platformalar o'rtasida qayta foydalanilishi mumkin. - Davom ettirish qulayligi (Maintainability): MVVM pattern’ida aniq ajratilgan ma'suliyatlar tufayli, kodni boshqarish, kengaytirish va refaktor qilish osonlashadi. - Ma'lumot bog'lash qulayligi (Data binding): MVVM pattern’i ma'lumot bog'lashni qo'llab-quvvatlovchi platformalarda juda yaxshi ishlaydi. Bu interfeys yangilanishi uchun yozilishi kerak bo'lgan ortiqcha boilerplate kodni kamaytiradi. MVC va MVVMning asosiy farqlari Biz MVC va MVVM pattern’larini muhokama qilganimiz sababli, ularning orasidagi farqni tushunishimiz uchun ularni tezda ko'rib chiqamiz: | Kriteriya | MVC | MVVM | | :----- | :----: | ----: | | Asosiy maqsad | Veb-dasturlar uchun foydalanuvchi interfeysi va logikani ajratadi. | Murakkab UI ilovalari uchun mo'ljallangan, ayniqsa desktop yoki SPA kabi ikki tomonlama ma'lumot bog'lashni ta'minlaydi. || | Komponentlar | Model: ma'lumot va biznes logikasi. View: foydalanuvchi interfeysi. Controller: foydalanuvchi kiritgan ma'lumotlarni boshqaradi, View’ni yangilaydi. | Model: ma'lumot va biznes logikasi. View: foydalanuvchi interfeysi elementlari. ViewModel: Model va View orasida ko'prik. || | Ma'lumot oqimi | Controller foydalanuvchi kiritgan ma'lumotlarni boshqaradi, u Model va View’ni yangilaydi. | View to'g'ridan-to'g'ri ViewModel bilan bog'lanadi. View’dagi o'zgarishlar avtomatik ravishda ViewModel’da aks ettiriladi va aksincha. || | Ajratish(Decoupling) | View odatda Controller bilan mustahkam bog'langan. | ViewModel alohida View’dan mustaqil bo'lgani uchun, yuqori darajada ajratish imkoniyatini beradi | | Foydalanuvchi interaktivligi | Controller tomonidan boshqariladi | ViewModel’dagi ma'lumot bog'lashlar va buyruqlar orqali boshqariladi. | | Platformaga moslik | Veb platformalariga mos (Ruby on Rails, Django, ASP.NET MVC kabilar). | Ma'lumot bog'lashni qo'llab-quvvatlovchi platformalar uchun mos (WPF, Xamarin kabilar). | Ushbu qisqa taqqoslashdan ko'rinib turibdiki, MVC va MVVM pattern’larining haqiqiy farqi birikish(coupling) va ma'lumotni bog'lash(bind) uslubida: Model va View o'rtasida Controller mavjud emasligi sababli, ma'lumotlarga egalik qilish foydalanuvchiga aniqroq va yaqinroq bo'ladi. React bu borada MVVM pattern’ini yanada yaxshilab, bir tomonlama ma'lumot oqimini ta'minlaydi, bu esa ma'lumotga egalik qilishni yanada aniqroq qiladi, shunday qilib, state faqat unga ehtiyoj sezadigan komponentlarga tegishli bo'ladi. Hozircha KnockoutJS’ga qaytaylik va uning React bilan qanday bog'liqligini ko'rib chiqaylik. Knockout’da \"Like\" button misoli KnockoutJS observable’lar va binding’lar bilan ishlash uchun API’lar eksport qilgan. Endi KnockoutJS’da \"Like\" tugmani qanday amalga oshirganimizni ko'rib chiqaylik. Bu bizga “Nega React kerak?” degan savolga yaxshiroq tushunishimizga yordam beradi. Bu yerda KnockoutJSd’agi button kodini ko'rib chiqamiz: KnockoutJSda \"view model\" JavaScript obyekti bo'lib, u o'zida bizning sahifamizdagi turli elementlarga bog'langan kalitlar va qiymatlarni saqlaydi, bunda atributidan foydalaniladi. KnockoutJS’da hech qanday \"komponentlar\" yoki \"shablonlar\" yo'q, faqat view model va uni brauzerda elementlarga bog'lash usuli mavjud. funksiyasi tahlili Bizning funksiyamiz KnockoutJS yordamida qanday qilib view model yaratishni ko'rsatadi. Shundan so'ng biz funksiyasidan foydalanib, view modelni host muhit(brauzer) bilan bog'laymiz. funksiyasi view modelni oladi va brauzerda atributiga ega bo'lgan barcha elementlarni topadi, shundan keyin Knockout ularni view model bilan bog'laydi. Brauzerimizdagi tugma quyidagi tarzda view model xususiyatlariga bog'lanadi: Shuni ta'kidlash kerakki, bu kod soddalashtirish maqsadida qisqartirilgan. Biz HTML elementini funksiyamiz bilan yaratgan \"view model\"imiz bilan bog'laymiz va sayt interaktiv holga keladi. Tasavvur qilganingizdek, kuzatilishi mumkin bo'lgan o'zgarishlariga aniq obuna bo'lish va keyin foydalanuvchi interfeysini bu o'zgarishlarga javoban yangilash katta mehnat talab qiladi. KnockoutJS o'z davrining ajoyib kutubxonasi bo'lgan, lekin vazifani bajarish uchun ko'p qo'shimcha kod(boilerplate) talab qilingan. Bundan tashqari, view modellari juda katta va murakkab bo'lib ketar edi, bu esa kodni refaktor qilish va optimizatsiya qilishda muammolarga olib kelgan. Oxir-oqibat, bu narsa testlash va tushunish qiyin bo'lgan juda uzun va monolit view modellariga olib keldi. Shunga qaramay, KnockoutJS o'z davrida juda ommabop va katta yutuqqa erishgan kutubxona edi. U izolyatsiya qilingan holatda testlash uchun ham nisbatan oson bo'lgan, bu katta ustunlik hisoblanardi. Qo'shimcha, KnockoutJS’da bu tugmani qanday test qilganimizni ko'rib chiqamiz:",
    "url": "/books/fluent-react/entry-level-stuff/knockout/page",
    "category": "books",
    "tags": [
      "fluent-react",
      "tutorial",
      "guide",
      "react",
      "javascript",
      "frontend",
      "view",
      "bog",
      "model",
      "mvvm",
      "knockoutjs",
      "uchun",
      "pattern",
      "viewmodel",
      "bilan",
      "foydalanuvchi",
      "lumot",
      "lgan",
      "mvc",
      "lumotlarni",
      "edi"
    ]
  },
  {
    "id": "book-fluent-react-entry-level-stuff-page",
    "title": "Nega React Paydo Bo'ldi? Veb-dasturlashning Tarixiy Muammolari",
    "content": "Nega React paydo bo'ldi? React'ning paydo bo'lishiga sabab bo'lgan asosiy omil – bu veb sahifalarning _yangilanishi_. Ilgari veb sahifalar asosan statik bo'lgan. Biz unda formalarni to'ldirardik, \"Yuborish\"(Submit) tugmasini bosardik, va butunlay yangi sahifani yuklardik. Bu usul ma'lum muddat yaxshi ishladi, lekin vaqt o'tishi bilan foydalanuvchilarning talablari o'zgarib, yangi imkoniyatlarni paydo bo'lishiga turtki bo'ldi. Paydo bo'lishiga asosiy sabablar Endilikda biz yangi sahifalarni darhol yangilanishini, yangi sahifani kutmasdan natijalarni ko'rishni, veb sahifalarni yanada \"jonli\" va tezkor bo'lishini xohlaymiz. Bu esa o'z navbatida User experience(UX, foydalanuvchi bilan ishlash qulayligi) va User interface(UI, foydalanuvchi interfeysi)’ni yanada takomillashtirilishga sabab bo'ldi. Biroq, bu tezkor yangilanishlarni birdaniga keng ko'lamda amalga oshirish bir necha sabablarga ko'ra oson emas edi: - Performance(Ishlash samaradorligi): Veb sahifalarini yangilash jarayonida ko'pincha ishlashda qiyinchilikka olib kelardi. Sababi, bizning o'zgarishlarimiz brauzerni sahifa layout(tartibi)’ini qayta hisoblash (reflow deb ataladigan jarayon) va qayta chizish(repaint)ga majbur qilardi, bu esa kechikishlarga olib kelardi. - Ishonchlilik: Katta va murakkab sahifalarda state'ni izchil saqlab qolish qiyin edi. Bir nechta joyda state'ni kuzatib borish va ularning barchasini sinxronlashtirish oson emas edi, ayniqsa, bir nechta dasturchilar bir kod bazasida ishlayotgan bo'lsalar. - Xavfsizlik: Sahifaga kiritilayotgan HTML va JavaScript kodlarini xavfsiz qilish, cross-site scripting(XSS) va cross-site request forgery(CSRF) kabi xavflarni oldini olish har doim dolzarb masala edi. React aynan mana shu muammolarni hal qilish uchun yaratilgan. Ushbu muammolarni yaxshiroq tushunish va React'ning qanday qilib ularni hal qilishini anglash uchun, React'ning paydo bo'lishi va uni yaratishga olib kelgan omillarni bilishimiz kerak. Keling, React paydo bo'lishidan oldingi jarayonni o'rganishga kirishamiz. React asoslari React'ga kirish va uning paydo bo'lish tarixi Bu bo'limda nima o'rganasiz Ushbu bo'limda React'ning paydo bo'lish tarixini, undan oldingi texnologiyalarni va React'ning qanday yechim ekanligini o'rganamiz. Mavzular: 1. Reactdan oldingi davr - Veb-rivojlantirishning qadimgi davrlari 2. jQuery - DOM manipulyatsiyasi uchun mashhur kutubxona 3. Backbone - Birinchi SPA freymvorklaridan biri 4. Knockout - Data binding kontsepsiyasi 5. Angular - Google'dan to'liq freymvork 6. Reactga kirish - Facebook'dan yangi yondashuv 7. React taklif qiladigan qiymati - React'ning afzalliklari 8. Reactning ommaga chiqishi - Open source bo'lishi 9. Flux arxitekturasi - Uni state management patterni 10. Xulosa - Bo'lim xulosasi Boshlash Chap tomondagi navigatsiyadan birinchi mavzuni tanlang yoki \"Keyingi\" tugmasini bosing. Eslatma: Bu bo'limni tushunish keyingi bo'limlar uchun muhim asos bo'ladi.",
    "url": "/books/fluent-react/entry-level-stuff/page",
    "category": "books",
    "tags": [
      "fluent-react",
      "tutorial",
      "guide",
      "react",
      "javascript",
      "frontend",
      "react",
      "paydo",
      "ning",
      "veb",
      "yangi",
      "ldi",
      "bir",
      "edi",
      "uchun",
      "lishiga",
      "olib",
      "state",
      "oldingi",
      "nega",
      "sabab"
    ]
  },
  {
    "id": "book-fluent-react-entry-level-stuff-react-value-proposition-page",
    "title": "React'ning Asosiy Qiymati: Deklarativ UI, Virtual DOM va Komponentlar",
    "content": "React taklif qiladigan qiymati Keling, endi tarixdan chetlashib haqiqiy React’ga kirib boramiz. Umid qilamizki, endi nima uchun React borligini tushunish uchun yetarlicha kontekstga ega bo'ldik. Katta miqyosdagi xavfsiz bo'lmagan, prognoz qilib bo'lmaydigan va samarasiz JavaScript kodiga tushib qolish oson bo'lganligi sababli, bizni \"_kutilmaganda g'alaba qozonish_\"ga yo'naltiradigan yechim kerak edi, ya'ni tasodifan muvaffaqiyatga erishadigan joy. Keling, React buni qanday amalga oshirishini batafsilroq muhokama qilaylik. Deklarativ va imperativ kod React DOM ustida deklarativ abstraksiyani taqdim etadi. Bu haqida keyingi bo'limlarda batafsilroq gaplashamiz, lekin asosan React bizga nimani ko'rishni xohlayotganimizni ifodalashimiz uchun bir usulni taklif qiladi, keyin esa qanday amalga oshishini React’ning o'zi hal qiladi. Bu orqali foydalanuvchi interfeysi xavfsiz, prognoz qilsa bo'ladigan va samarali tarzda yaratiladi va ishlaydi. Keling, ilgari yaratgan ro'yxat dasturimizni qayta ko'rib chiqaylik. React’da uni quyidagicha qayta yozishimiz mumkin: E'tibor bersangiz, ichida biz aniq HTML’ga o'xshash narsani yozamiz: biz ko'rmoqchi bo'lgan narsani yozamiz. Men bo'lgan quti va ro'yxatni ko'rmoqchiman. Tayyor. Qanday qilib u paydo bo'ladi? Buni React hal qiladi. Ro'yxat elementlarini bir martada qo'shamizmi? Ularni birma-bir qo'shamizmi? React buni qanday amalga oshirishni o'zi hal qiladi, biz esa faqat qanday natija chiqishini ta’riflaymiz. Keyingi bo'limlarda React buni qanday qilishi haqida batafsilroq o'rganamiz. HTML elementlariga murojaat qilish uchun class nomlaridan foydalanamizmi? JavaScript’da ishlatamizmi? Yo'q. React biz uchun “React elementlar”ni o'zi ichki mexanizmida yaratadi va ular yordamida o'zgarishlarni aniqlaydi va incremental (qismlarga bo'lib) yangilanishlarni amalga oshiradi, shuning uchun bizga foydalanuvchi kodidan class nomlari va ID’larini o'qishga hojat yo'q: haqiqiy ma'lumot manbai faqat React’dagi JavaScript bo'ladi. Biz komponentimizni React’ga eksport qilamiz va React biz uchun uni ekranga xavfsiz, prognoz qilinadigan va samarali tarzda chiqaradi. Komponentning vazifasi faqat foydalanuvchi interfeysining ushbu qismi qanday ko'rinishda bo'lishini ta’riflashdir. Bu virtual DOM (vDOM) orqali amalga oshiriladi, ya’ni foydalanuvchi interfeysining yengil va ixcham (lightweight) ko'rinishidier. React yangilanish sodir bo'lgandan so'ng virtual DOM’ni yangilanishdan oldingi holat bilan solishtiradi va real DOM’ni virtual DOM bilan moslashtirish uchun kichik va samarali yangilanishlar qiladi. Shu yo'l bilan React DOM’ni yangilaydi. Virtual DOM Virtual DOM real DOM’ni aks ettiruvchi, lekin JavaScript obyekti sifatida ishlaydigan dasturlash tushunchasidir. Agar hozircha bu biroz chalkash tuyulsa, xavotir olmang: keyingi bo'limlarda Virtual DOM’ga alohida bir bo'lim bag'ishlaganmiz va haqida batafsil gaplashamiz. Hozircha, shuni bilish muhimki, virtual DOM dasturchilarga real DOM’ni bevosita boshqarmasdan foydalanuvchi interfeysini yangilash imkonini beradi. React virtual DOM’dan komponentning o'zgarishlarini kuzatish va faqat kerak bo'lgan paytda uni qayta render qilish uchun foydalanadi. Bu yondashuv butun DOM daraxtini har safar o'zgarish bo'lganda yangilashdan ko'ra tezroq va samaraliroqdir. React’da virtual DOM real DOM daraxtining yengil va ixcham ko'rinishi hisoblanadi. U foydalanuvchi interfeysi elementlarining strukturasi va xususiyatlarini tavsiflaydigan oddiy JavaScript obyekti. React virtual DOM’ni real DOM daraxtiga mos ravishda yaratadi va yangilaydi, va virtual DOM’da amalga oshirilgan o'zgarishlar _reconciliation(moslashtirish)_ jarayoni orqali real DOM’ga qo'llaniladi. \"Like\" button misoli React talqinida Bitta alohida bob shu mavzuga, ya'ni reconciliation jarayonining qanday ishlashiga, bag'ishlangan, ammo hozirgi kontekstda kichik xulosani va ba'zi misollarni ko'rib chiqamiz. Virtual DOM qanday ishlashini tushunish uchun \"Like\" tugmasi misolimizni qayta ko'rib chiqamiz. Biz foydalanuvchi \"Like\" tugmasini bosganda like’lar soni bitta oshishi kerak bo'lgan React komponentini yaratamiz. Ushbu komponent kodi: Ushbu kodda biz hook’idan foydalanib, deb nomlangan state o'zgaruvchisini yaratdik, bu o'zgaruvchi \"like\"lar sonini saqlaydi. Hook’larga qisqacha ta'rif React haqida avval ba'zi tushunchalarni eslab olamiz: hook — bu funksional komponentlar ichida React’ning state va lifecycle(hayotiy sikli) metodlaridan foydalanish imkonini beruvchi maxsus funksiya. Hook’lar stateful (holatli) logikani qayta ishlatish imkonini beradi, bu esa komponent iyerarxiyasini o'zgartirmasdan hook’larni boshqa komponentlar bilan yoki hatto ochiq manbali paketlar sifatida hamjamiyat bilan baham ko'rishni osonlashtiradi. Virtual DOM qanday ishlashi Shuningdek, foydalanuvchi tugmani bosganda \"like\"lar sonini bittaga oshiradigan funksiyasini e'lon qildik. Nihoyat, JSX yordamida _Like_ tugmasi va \"like\"lar sonini render qildik. Endi bu misolda virtual DOM qanday ishlashini batafsilroq ko'rib chiqamiz. komponenti birinchi marta render qilinganda, React real DOM daraxtiga mos keladigan virtual DOM daraxtini yaratadi. Virtual DOM bitta elementini, u esa o'z navbatida va elementlarini o'z ichiga oladi: elementining children(farzandlar) xususiyati state o'zgaruvchisining qiymatini o'z ichiga oladi, bunda dastlabki holat nolga teng. Foydalanuvchi _Like_ tugmasini bosganda, funksiyasi chaqiriladi va bu \"like\"lar sonini yangilaydi. React keyin yangilangan state’ni aks ettiruvchi yangi virtual DOM daraxtini yaratadi: E'tibor bering, virtual DOM daraxti avvalgi elementlarni o'z ichiga oladi, lekin elementining xususiyati \"like\"larning yangi qiymatini aks ettirish uchun yangilangan, ya'ni 0 dan 1 gacha o'zgargan. Bu React’da reconciliation deb ataladigan jarayondir, bu jarayonda yangi virtual DOM eski virtual DOM bilan taqqoslanadi. Keling, bu jarayonni qisqacha muhokama qilamiz. Reconciliation jarayoni Yangi virtual DOM daraxtini hisoblagandan so'ng, React reconciliation jarayonini bajaradi, bu yangi daraxt bilan eski daraxt o'rtasidagi farqlarni tushunish uchun ishlatiladi. Reconciliation — eski virtual DOM daraxtini yangi virtual DOM daraxti bilan solishtirish va real DOM’ning qaysi qismlarini yangilash kerakligini aniqlash jarayoni. Bu mavzuga alohida bobda batafsil va chuqurroq to'xtalamiz. Hozir esa _Like_ tugmasini ko'rib chiqamiz. Bizning misolimizda, React eski virtual DOM daraxtini yangi virtual DOM daraxti bilan taqqoslaydi va elementi o'zgarganligini topadi: aniqrog'i, uning yoki yoki har ikkalasi ham o'zgargan. Bu React’ga komponentni “ifloslangan”(dirty) yoki “yangilanish kerak” deb belgilash imkonini beradi. React keyin real DOM’ga minimal samarali yangilanishlar to'plamini hisoblaydi va oxir-oqibat virtual DOM’da amalga oshirilgan o'zgarishlarni aks ettirish uchun real DOM’ni yangilaydi. React real DOM’ning faqat kerakli qismlarini yangilaydi, bu esa DOM manipulyatsiyalari sonini minimallashtiradi. Bu yondashuv har safar o'zgarish sodir bo'lganda butun DOM daraxtini yangilashdan ko'ra ancha tez va samaraliroqdir. Virtual DOM zamonaviy veb uchun kuchli va nufuzli ixtiro bo'lib, React’da sinovdan o'tgach, Preact va Inferno kabi yangi kutubxonalar ham uni qabul qilishdi. Komponent modeli React’da \"komponentlarcha fikrlash\" (thinking in components) ni kuchli qo'llab-quvvatlaydi: ya'ni, dasturingizni kichik qismlarga ajratib, ularni katta daraxtga qo'shish orqali dasturni tuzish. Komponent modeli React’ning asosiy tushunchalaridan biri bo'lib, React’ni shunchalik kuchli qiladigan ham aynan shu narsadir. Keling, nima uchun bunday ekanligini ko'rib chiqamiz: - U ilova kodining har xil joyida bir xil narsani qayta ishlatishni rag'batlantiradi, shunda biror narsa buzilsa, uni bir joyda tuzatasiz va bu o'sha narsani hamma joyda tuzatadi. Bu DRY (Don’t Repeat Yourself) deb nomlangan development tushunchasi bo'lib, dasturiy injineringning muhim tushunchasi hisoblanadi. Masalan, agar bizda komponenti bo'lsa, uni dasturimizning ko'p joylarida ishlatishimiz mumkin, va agar tugma stilini o'zgartirishimiz kerak bo'lsa, uni bir joyda o'zgartiramiz va u hamma joyda yangilanadi. - React komponentlarni kuzatishni osonlashtiradi va ushbu komponentlarni qayta-qayta aniqlab, vaqt o'tishi bilan o'zgarishlarni kuzatishi orqali memoizatsiya, guruhlash(batching) va boshqa optimizatsiyalarni amalga oshiradi. Bu keying (kalitlash) deb ataladi. Masalan, agar bizda komponenti bo'lsa, unga prop berishimiz mumkin va React vaqt o'tishi bilan komponentini kuzatib borishi va qachon uni yangilash kerakligini yoki yangilamasdan foydalanuvchi interfeysida minimal o'zgarishlarni amalga oshirish kerakligini \"biladi\". Ko'pgina komponentlar implicit (noaniq) kalitlarga ega, lekin agar xohlasak, ularga aniq kalitlarni ham berishimiz mumkin. - Bu bizga ma'suliyatlarni ajratib, foydalanuvchi interfeysining ma'lum qismlariga tegishli bo'lgan logikani o'sha qismlarga yaqin joylashtirishga yordam beradi. Masalan, agar bizda komponenti bo'lsa, tugma bosilganda nima sodir bo'lishini boshqaruvchi logikani komponenti bilan bitta faylda joylashtirishimiz mumkin, tugma bosilganda nima bo'lishini aniqlash uchun boshqa fayllarga o'tishning hojati bo'lmaydi. komponenti oddiyroq komponentini o'rab oladi va tugma bosilganda nima sodir bo'lishini boshqarish uchun mas'ul bo'ladi. Bu kompozitsiya(composition) deb ataladi. React’ning komponent modeli freymvorkning mashhurligi va muvaffaqiyatini ta'minlaydigan fundamental tushuncha hisoblanadi. Ushbu development yondashuvi ko'pgina afzalliklarga ega, jumladan modulni yaxshilash, xatolilarni osongina aniqlash(debugging) va kodni samarali qayta ishlatish. Holatning o'zgarmasligi (Immutable state) React dizayn filosofiyasi ilova holatini, ya'ni state’ni, o'zgarmas (immutable) qiymatlar to'plami sifatida tasvirlash paradigmasini e'tirof etadi. Har bir state yangilanishi yangi, alohida snapshot va xotira havolasi(memory reference) sifatida ko'riladi. Bu o'zgarmas yondashuv state’ni boshqarishning asosiy qismidir va kuchli, samarali va prognoz qilinadigan foydalanuvchi interfeyslarini ishlab chiqishda bir qancha afzalliklarga ega. O'zgarmaslikni ta'minlash orqali, React UI komponentlarini har qanday vaqtda aniq bir holatini aks ettirishini kafolatlaydi. State o'zgarganda, uni to'g'ridan-to'g'ri o'zgartirish o'rniga, yangi state’ni ifodalovchi yangi obyekt qaytariladi. Bu o'zgarishlarni kuzatishni, debug qilishni va ilovaning xatti-harakatlarini tushunishni osonlashtiradi. State o'zgarishlari diskret (ajralgan) bo'lib, bir-biriga xalaqit bermagani sababli, umumiy o'zgaruvchan(mutable) state tufayli yuzaga keladigan nozik xatoliklar imkoniyati sezilarli darajada kamayadi. Keyingi bo'limlarda React qanday qilib state yangilanishlarini guruhlashi(batching updates) va ularni asinxron tarzda optimallashtirish uchun ishlov berishini o'rganamiz. State’ni o'zgarmas tarzda boshqarish kerak bo'lgani uchun, bu “tranzaksiyalarni” xavfsiz tarzda yig'ish va qo'llash mumkin, bu esa bir yangilanish boshqa yangilanish uchun state’ni buzishi xavfini kamaytiradi. Bu yondashuv yanada prognoz qilinuvchan state menejmentga olib keladi va ayniqsa murakkab state o'zgarishlari paytida ilovaning ishlashini yaxshilaydi. O'zgarmas state’dan foydalanish dasturiy ta'minotni ishlab chiqishdagi eng yaxshi amaliyotlarni yana bir bor mustahkamlaydi. Bu dasturchilarni ma'lumot oqimlarini funksional tarzda o'ylashga undaydi, side effect’larni kamaytiradi va kodni osonroq tushunish imkonini beradi. O'zgarmas ma'lumot oqimining aniq bo'lishi ilovaning qanday ishlashini tushunish uchun mental(aqliy) modelni soddalashtiradi. O'zgarmaslik(Immutability) - dasturchilar uchun yanada kuchliroq vositalarini yaratishga imkon beradi, masalan, Replay.io kabi vositalar yordamida vaqt bo'ylab orqaga va oldinga qadam tashlab, ilovaning state o'zgarishlarini kuzatish va UI’ni har qanday vaqtda tekshirish mumkin. Bu faqat har bir state yangilanishi alohida va o'zgarmas snapshot sifatida saqlanganda mumkin bo'ladi. React’ning o'zgarmas state yangilanishlariga sodiqligi maqsadli tanlangan dizayn qaroridir va ko'plab afzalliklarni beradi. Bu zamonaviy funksional dasturlash tamoyillariga mos keladi, samarali UI yangilanishlariga imkon beradi, ishlashni optimallashtiradi, xatoliklar ehtimolini kamaytiradi va dasturchi bilan ishlash qulayligini yaxshilaydi. Ushbu yondashuv React’ning ko'plab takomillashgan funksiyalari asosida yotadi va React rivojlanishda davom etar ekan, asosiy tamoyillardan biri bo'lib qoladi.",
    "url": "/books/fluent-react/entry-level-stuff/react-value-proposition/page",
    "category": "books",
    "tags": [
      "fluent-react",
      "tutorial",
      "guide",
      "react",
      "javascript",
      "frontend",
      "react",
      "dom",
      "virtual",
      "uchun",
      "state",
      "qanday",
      "bir",
      "bilan",
      "foydalanuvchi",
      "real",
      "yangi",
      "amalga",
      "ning",
      "qayta",
      "uni"
    ]
  },
  {
    "id": "book-fluent-react-entry-level-stuff-recap-page",
    "title": "React'ga Kirish Xulosasi: Tarix, G'oyalar va Asosiy Konsepsiyalar",
    "content": "Bo'limni qisqacha takrorlash Ushbu bo'limda biz React tarixini, uning dastlabki taklif qiladigan qiymatini va keng miqyosdagi xavfsiz bo'lmagan, prognoz qilinishi mumkin bo'lmagan va samarali bo'lmagan foydalanuvchi interfeysi yangilanishlarini qanday hal qilishini ko'rib chiqdik. Shuningdek, biz komponent modeli va uning veb interfeyslari uchun nima uchun inqilobiy bo'lganini muhokama qildik. Bu bo'limdan so'ng, siz React’ning kelib chiqishi va uning asosiy kuchli tomonlari haqida ko'proq ma'lumotga ega bo'lishingiz kerak. Takrorlash uchun savollar Quyidagi savollarga javob berib, mavzularni yaxshiroq tushunganingizni tekshirib ko'ring: 1. _React’ni yaralishiga nima turtki bo'lgan?_ 2. _React qanday qilib MVC va MVVM kabi avvalgi pattern’larni yaxshiladi?_ 3. _Flux arxitekturasi nimasi bilan o'ziga xos?_ 4. _Deklarativ dasturlash abstraksiyalarining qanday afzalliklari bor?_ 5. _Virtual DOM qanday qilib samarali tarzda UI yangilanishlarini amalga oshiradi?_ Agar siz ushbu savollarga javob berishda qiyinchilikka duch kelsangiz, ushbu bobni yana bir bor o'qib chiqishingizni tavsiya etamiz. Agar undan bo'lmasa, keling, keyingi bobni o'rganishga kirishamiz. Keyingi bo'lim Kelgusi bobda biz JSX — HTML ko'rinishidagi til va uning React’da qanday ishlashini batafsilroq o'rganamiz. JSX dastlab React uchun ko'p muammo keltirgan edi, lekin keyinchalik u veb interfeyslarini ishlab chiqishda ideal yo'l ekanligini isbotladi va kelajakdagi foydalanuvchi interfeyslari kutubxonalariga katta ta'sir ko'rsatdi.",
    "url": "/books/fluent-react/entry-level-stuff/recap/page",
    "category": "books",
    "tags": [
      "fluent-react",
      "tutorial",
      "guide",
      "react",
      "javascript",
      "frontend",
      "react",
      "qanday",
      "uning",
      "uchun",
      "ushbu",
      "biz",
      "lmagan",
      "takrorlash",
      "samarali",
      "foydalanuvchi",
      "yangilanishlarini",
      "veb",
      "interfeyslari",
      "nima",
      "siz"
    ]
  },
  {
    "id": "book-fluent-react-entry-level-stuff-releasing-react-page",
    "title": "React'ning Ommaga Taqdim Etilishi: Tanqidlar, JSX va Muvaffaqiyat",
    "content": "React’ni ommaga taqdim qilinishi Bir tomonlama ma'lumot oqimi biz yillar davomida veb-ilovalar yaratib kelgan usuldan keskin farq qilar edi va bu g'oya skeptitsizm bilan qarshi olindi. Facebook katta kompaniya bo'lgani, ko'p resurslarga, foydalanuvchilarga va turli fikrlarga ega dasturchilarga ega bo'lgani sababli, React’ning ommalashish yo'li ancha qiyin bo'ldi. Juda ko'p tahlil va sinovlardan so'ng, React ichki muvaffaqiyatga erishdi. Facebook va undan keyin Instagram tomonidan qabul qilindi. Keyin 2013-yilda React ochiq manbali loyiha sifatida ommaga taqdim qilindi va ko'pgina negativ tanqidlar bilan qarshi olindi. Odamlar React’ni JSX ishlatgani uchun qattiq tanqid qilishdi, Facebook’ni “HTML’ni JavaScript ichiga qo'yganlikda” va \"serapation of concerns\"(ma'suliyatlarni ajratish) tamoyilini buzganlikda ayblashdi. Facebook “eng yaxshi amaliyotlarni qayta o'ylaydigan” va vebni buzadigan kompaniya sifatida tanildi. Oxir-oqibat, Netflix, Airbnb va The New York Times kabi kompaniyalar tomonidan sekin-asta qabul qilinishi bilan, React vebda foydalanuvchi interfeyslarini yaratish uchun yangi standartga aylandi. Bu tafsilotlarga batafsil to'xtalib o'tmaymiz, lekin React’ni yaratishga olib kelgan texnik muammolar tasnifini tushunish muhimdir. Agar siz React tarixi haqida ko'proq qiziqsangiz, YouTube’da Honeypot tomonidan tayyorlangan _\"React.js: The Documentary\"_ React’ning to'liq hujjatli filmini ko'rishingiz mumkin. Facebook keng ko'lamdagi muammolarni birinchi bo'lib kuzatganligi sababli, React foydalanuvchi interfeyslarini yaratishda ushbu va boshqa muammolarni hal qiladigan komponentga asoslangan yondashuvni ilgari surdi, unda har bir komponent kodning o'z-o'zini boshqaradigan birligi bo'lib, uni boshqa komponentlar bilan qayta ishlatish va yanada murakkab foydalanuvchi interfeyslarini yaratish uchun birlashtirish mumkin bo'ladi. React ochiq manbali dastur sifatida chiqarilganidan bir yil o'tib, Facebook React ilovalarida ma'lumot oqimini boshqarish pattern’i bo'lmish Flux’ni chiqardi. Flux katta ko'lamdagi ilovalarda ma'lumot oqimini boshqarishdagi muammolarga javob bo'lib, React ekotizimining muhim qismi edi. Keling, Flux va u React bilan qanday bog'liqligini ko'rib chiqamiz.",
    "url": "/books/fluent-react/entry-level-stuff/releasing-react/page",
    "category": "books",
    "tags": [
      "fluent-react",
      "tutorial",
      "guide",
      "react",
      "javascript",
      "frontend",
      "react",
      "facebook",
      "bilan",
      "ommaga",
      "taqdim",
      "bir",
      "lumot",
      "ning",
      "tomonidan",
      "sifatida",
      "uchun",
      "foydalanuvchi",
      "interfeyslarini",
      "lib",
      "flux"
    ]
  },
  {
    "id": "book-fluent-react-entry-level-stuff-world-before-react-page",
    "title": "React'dan Oldingi Davr: Veb-dasturlash Muammolari",
    "content": "React’dan oldingi davr React paydo bo'lishidan avval, biz veb-dasturlar yaratishda katta muammolarga duch kelardik. Dasturlarimizni qanday qilib tezkor va darhol javob beradigan qilib yaratish bilan birga, ularni millionlab foydalanuvchilar uchun ishonchli va xavfsiz ishlashini ham ta'minlashimiz kerak edi. Masalan, oddiygina tugma bosilish holatini ko'rib chiqaylik: foydalanuvchi tugmani bosganda, biz foydalanuvchi interfeysini(UI) shu tugma bosilganligini aks ettirish uchun yangilamoqchimiz. Buning uchun kamida to'rtta holatni hisobga olishimiz kerak: Tugma bosilish holatlari - Bosishdan oldingi holat: Tugma o'zining dastlabki holatida va hali bosilmagan. - Bosilgan, lekin natija kutilyapti: Tugma bosilgan, ammo tugma bosilganda bajarilishi kerak bo'lgan amal hali tugatilmagan. - Bosilgan va muvaffaqiyatli bajarilgan: Tugma bosilgan va bajarilishi kerak bo'lgan amal muvaffaqiyatli bajarilgan. Bu holatda, tugmani avvalgi holatiga qaytaramiz yoki muvaffaqiyat belgisi sifatida tugmaning rangini (yashil) o'zgartiramiz. - Bosilgan va muvaffaqiyatsiz bo'lgan: Tugma bosilgan, ammo bajarilishi kerak bo'lgan amal muvaffaqiyatsiz tugagan. Bu holatda, tugmani avvalgi holatiga qaytarishimiz yoki muvaffaqiyatsizlikni ko'rsatish uchun tugma rangini (qizil) o'zgartirishimiz mumkin. Interfeysni yangilash Bu holatlar mavjud bo'lgandan keyin, foydalanuvchi interfeysini bu holatlarga mos ravishda yangilash kerak bo'ladi. Buning uchun odatda quyidagi qadamlar talab qilinardi: 1. Tugmani brauzer kabi hos muhitda topish, buning uchun yoki kabi elementni joylashtirish API’laridan foydalanish. 2. Tugmaga bosish(click) event’larini tinglash uchun event listener’lar(voqea tinglovchilar)ni o'rnatish 3. Event’larga javoban holatni yangilash. 4. Tugma sahifadan o'chirilganda, event listener’larni olib tashlash va barcha holatlarni tozalash. Sodda misol: Like button Bu oddiy misol, lekin boshlash uchun yaxshi variant. Tasavvur qilaylik, bizda \"_Like_\" deb nomlangan tugma bor va foydalanuvchi uni bosganda, tugma tekstini \"_Liked_\" deb yangilashni xohlaymiz. Buni qanday amalga oshiramiz? Avvalo, bizda HTML elementi bo'ladi: Endi, ushbu tugmani JavaScript orqali boshqarishimiz uchun, unga atributi qo'shamiz: Interaktiv qilish Ajoyib! Endi tugmada mavjud, shuning uchun JavaScript orqali unga murojaat qilib, uni interaktiv qilishimiz mumkin. yordamida tugmaga murojaat qilamiz va tugmani bosish event’larini tinglash uchun event listener qo'shamiz: Endi bizda event listener mavjud, shuning uchun tugma bosilganda biror amalni bajara olamiz. Masalan, tugma bosilganda uning tekstini \"Liked\" deb yangilashni xohlaymiz. Buni tugmaning tekst kontentini yangilash orqali amalga oshirishimiz mumkin: Tugma holatini boshqarish Ajoyib! Endi bizda \"_Like_\" deb nomlangan tugma bor, va uni bosganda, kontenti _\"Liked\"_ deb o'zgaradi. Biroq, bu yerda muammo shundaki, biz tugmani yana \"_Unlike_\" holatiga qaytarish imkoniga ega emasmiz. Buni to'g'rilash va tugmani \"_Liked_\" holatida bo'lsa, yana \"_Like_\" holatiga o'tkazishni amalga oshirish uchun biz tugmaga qaysi holatda ekanligini kuzatib boradigan birorta holat(state) qo'shishimiz kerak. Buni tugmaga atributini qo'shish orqali amalga oshirishimiz mumkin: Endi bizda ushbu atribut mavjud bo'lganidan so'ng, tugma bosilgan yoki bosilmaganligini kuzatib borishimiz mumkin. Tugmaning kontentini ushbu atribut qiymatiga asoslanib yangilaymiz: Shoshmang, lekin biz faqat buttonning ini o'zgartiryapmiz, xolos! Biz aslida \"_Liked_\" holatini ma'lumotlar bazasi(database)da saqlamayapmiz. Buni qilish uchun odatda tarmoq(network) orqali muloqot qilishimiz kerak edi, masalan: Zamonaviy muammolar Albatta, biz bu yerda o'sha vaqtdagi davrga mos kelish uchun va dan foydalanmoqdamiz. React 2013 yilda \"_open source_\", ya'ni ochiq manbali, dastur sifatida chiqarilgan, esa 2015 yilda joriy etilgan. va o'rtasida jQuery kabi kutubxonalar murakkabliklarni kamaytirgan, masalan, , va boshqalar ishlatilgan. Agar bugungi kunda biz buni yozadigan bo'lsak, u quyidagicha bo'lardi: Xatolarni boshqarish Hozirgi kunda biz tarmoq orqali muloqot qilayapmiz, lekin agar tarmoq so'rovi muvaffaqiyatsiz(fail) bo'lsa nima bo'ladi? Bunday holda, tugmaning tekstini muvaffaqiyatsizlikni aks ettirish uchun yangilashimiz kerak bo'ladi. Buni amalga oshirish uchun tugmaga atributini qo'shishimiz mumkin: Endi biz tugmaning tekstini ushbu atribut qiymatiga asoslanib yangilashimiz mumkin: Takomillashtirilgan holat boshqaruvi Yana bir holatni ko'rib chiqish kerak: ayni paytda \"_like_\" qilish jarayoni. Ya’ni, kutish holati. Buni kodda modellashtirish uchun buttonga kutish holati uchun yana bir atributini qo'shishimiz kerak, quyidagicha: Endi biz tarmoq so'rovi(network request) davom etayotgan paytda tugmani disabled qilishimiz mumkin, shunda bir nechta bosishlar tarmoq so'rovlarini ketma-ket ishga tushirishga olib kelmaydi va bu holat serverning haddan tashqari yuklanishiga ham olib kelmaydi. Buni quyidagicha amalga oshirish mumkin: Debouncing va throttling texnikalari Shuningdek, foydalanuvchilarning takroriy va ortiqcha amallarni bajarishini oldini olish uchun debouncing va throttling kabi samarali texnikalarni qo'llashimiz mumkin. <Callout type=\"info\" emoji=\"ℹ️\"Debouncing texnikasi funksiyaning bajarilishini oxirgi event qo'zg'atilgan(event trigger)dan so'ng ma'lum vaqt o'tganidan keyin kechiktiradi (masalan, foydalanuvchi input’da yozish jarayonini to'xtashini kutish), throttling esa funksiyaning ma'lum vaqt intervalida faqat bir marta bajarilishiga imkon beradi, shunda u juda tez-tez bajarilmaydi (masalan, ma'lum vaqt intervalida scroll event’larini ishlatish). Har ikkala texnika funksiya bajarilish tezligini boshqarish orqali ishlash samaradorligini oshiradi. </CalloutMuammoli savollar Endi bizdagi tugma barqarorroq bo'lib, bir nechta holatlarni boshqarishi mumkin, lekin hali ham ba'zi savollar tug'iladi: - haqiqatdan ham zarurmi? Tugma disabled qilinganmi yoki yo'qligini shunchaki tekshirish bilan kifoyalana olmaymizmi? Ehtimol, yo'q, chunki disabled qilingan tugma boshqa sabablar, masalan, foydalanuvchining tizimga kirmaganligi yoki tugmani bosishga ruxsati yo'qligi sababli ham o'chirilgan bo'lishi mumkin. - Boshqa ko'plab data atributlarni ishlatish o'rniga, atributini qo'llab, holatlarni \"_pending_\"\", \"_liked_\" yoki \"_unliked_\" kabi qiymatlar bilan belgilash mantiqiyroq emasmi? Ehtimol, ha, lekin bu holda har bir holatni boshqarish uchun kattaroq switch/case yoki shunga o'xshash kod bloki qo'shishimiz kerak bo'ladi. Natijada, ikkala yondashuv ham o'ziga xos murakkablik va hajm talab qiladi. - Bu tugmani izolyatsiyalangan holda qanday test qilishimiz mumkin? Buni iloji bormi? - Nega dastlab tugmani HTML’da yozamiz va keyinroq u bilan JavaScript’da ishlaymiz? Tugmani shunchaki JavaScript’da (\"button\") yordamida yaratish va keyin (\"likeButton\") orqali qo'shish yaxshiroq emasmi? Bu test qilishni osonlashtiradi va kodni yanada mustaqil qiladi, lekin keyin uning ota(parent) elementini kuzatib borishimiz kerak bo'ladi, agar ota element bo'lmasa. Aslida, sahifadagi barcha ota elementlarni kuzatib borishimiz kerak bo'lishi mumkin. Ba'zi javoblar React bizga ushbu muammolarning ba'zilarini hal qilishda yordam beradi, lekin ularning hammasini ham emas: masalan, holatni alohida bayroq(flag)lar (masalan, \"_isPending_\", \"_hasFailed_\" va hokazo) bilan boshqarishmi yoki yagona holat o'zgaruvchisi (masalan, ) yordamida boshqarishmi - bu React biz uchun javob bermaydigan savollardan biri. Bu savolga biz o'zimiz javob topishimiz kerak bo'ladi. Shunga qaramay, React bizga kattaroq muammo ko'lamini hal qilishda yordam beradi: ko'plab interaktiv tugmalar yaratish va event’larga javoban foydalanuvchi interfeysini minimal va samarali tarzda yangilash, shuningdek, buni test qilish mumkin bo'lgan, takrorlanuvchi, deklarativ, samarali, prognozli va ishonchli tarzda amalga oshirishda yordam beradi. Bundan tashqari, React foydalanuvchi interfeysining holatini to'liq nazorat qilish orqali buni ancha barqaror qiladi va shu holatga asoslanib render qiladi. Bu holat brauzer tomonidan boshqariladigan holat bilan tubdan farq qiladi, chunki brauzer holati boshqa klient tomondan(client-side) ishlaydigan skriptlar, brauzer kengaytmalari, qurilma cheklovlari va boshqa ko'plab omillar kabi bir qator omillar tufayli juda ishonchsiz bo'lishi mumkin. Bizning \"_Like_\" tugma misolimiz juda sodda, lekin boshlash uchun yaxshi misol. Hozircha, JavaScript yordamida tugmani interaktiv qilish qanday amalga oshirilishini ko'rdik, lekin bu jarayonni _yaxshiroq_ bajarmoqchi bo'lsak, bu qo'lda bajaradigan juda ko'p ishni talab qiladi: tugmani brauzerda topishimiz, event listener qo'shishimiz, tugmaning tekstini yangilashimiz va turli xil murakkab holatlarni hisobga olishimiz kerak. Bu juda ko'p ish, va bu osonlikcha kengaytiriladigan narsa emas. Agar sahifada ko'plab tugmalar bo'lsa-chi? Agar bu ko'plab tugmalar interaktiv bo'lishi kerak bo'lsa-chi? Agar ko'p tugmalar interaktiv bo'lishi kerak bo'lsa va biz event’larga javoban foydalanuvchi interfeysini yangilashimiz kerak bo'lsa-chi? Bu holda biz _event delegation_ (yoki event bubling) ishlatsak bo'ladimi va yuqoriroqdagi ga event listener’ni qo'shishimiz(attach) kerakmi? Yoki har bir tugmaga event listener’larni qo'shishimiz kerakmi? Avvalroq atganimizdek, biz quyidagi bayonot haqida yetarlicha tushunchaga ega bo'lishimiz kerak: brauzerlar veb-sahifalarni render qiladi. Veb-sahifalar HTML dokumentlari bo'lib, ularga CSS tomonidan stillar beriladi va JavaScript yordamida interaktiv qilinadi. Bu bir necha o'nlab yillar davomida ajoyib ishladi va hali ham ishlaydi, lekin zamonaviy veb-dasturlarni yaratish, ularni millionlab foydalanuvchilar uchun ishonchli va xavfsiz ishlatish uchun sezilarli darajada abstraksiyaga ehtiyoj bor. Afsuski, biz ko'rib chiqqan \"_Like_\" tugma misoliga asoslanib aytganda, bizga bu jarayonda yordam kerak bo'ladi. Murakkabroq misol: Ro'yxat elementlari Keling, \"_Like_\" tugmasidan biroz murakkabroq bo'lgan boshqa bir misolni ko'rib chiqaylik. Oddiy misoldan boshlaymiz: elementlar ro'yxati. Aytaylik, bizda elementlar ro'yxati bor va biz ro'yxatga yangi element qo'shmoqchimiz. Buni quyidagi kabi HTML formasi yordamida amalga oshirishimiz mumkin: JavaScript bizga Dokument Obyekt Modeli(DOM) API’lariga kirish imkonini beradi. DOM haqida xabardor bo'lmaganlar uchun, DOM - bu veb-sahifaning dokument strukturasining xotiradagi modeli bo'lib, u sizning sahifangizdagi elementlarni ifodalovchi obyektlar daraxtidir va ularga JavaScript orqali murojaat qilish imkoniyatini beradi. Muammo shundaki, foydalanuvchi qurilmalaridagi DOM’lar begona sayyoraga o'xshaydi: biz ularning qanday brauzerlarni ishlatayotganini, qanday tarmoq sharoitlarida ekanligini va qaysi operatsion tizimlarda(OS) ishlashini bilmaymiz. Xo'sh, natija qanday? Biz barcha bu omillarga javob beradigan va chidamli kod yozishimiz kerak bo'ladi. Murakkabliklar va muammolar Hozirgina biz muhokama qilganimizdek, holatlarni boshqarish mexanizmisiz yangilangan holatlarni oldindan aytib, bashorat qilish qiyinlashadi. Ro'yxat misolini davom ettirib, ro'yxatga yangi element qo'shish uchun JavaScript kodini ko'rib chiqamiz: Ushbu kod qismini iloji boricha avvalgi veb-dasturlarga o'xshatib yozdik. Buni vaqt o'tishi bilan kengaytirish nimaga olib keladi? Asosan, vaqt o'tishi bilan bunday dasturlarni kengaytirish juda ko'p muammolarni keltirib chiqaradi, bu ularni quyidagicha qiladi: Kodimizdagi ba'zi muammolar Xatolarga moyil \"_addForm_\"’ning atributi sahifadagi boshqa klient tomonidagi JavaScript tomonidan osonlik bilan qayta yozilishi mumkin. Buning o'rniga dan foydalanishimiz mumkin, lekin bu ko'proq savollarni keltirib chiqaradi: - bilan qachon va qayerda tozalashimiz kerak? - Agar bunda e'tiborliroq va ehtiyotkor bo'lmasak, vaqt o'tishi bilan juda ko'p event listenerlar yig'ilib qoladimi? - Buning uchun qanday jazo to'lashimiz kerak? - Event delegation bu holatga qanchalik mos keladi? Prognoz qilinmagan Bizning ma'lumot manbalarimiz aralashgan: biz ro'yxat elementlarini JavaScript massividagi elementlar sifatida saqlayapmiz, lekin dasturimizni tugatish uchun DOM’da mavjud bo'lgan elementlarga tayanamiz (masalan, elementi). JavaScript va HTML o'rtasidagi bu o'zaro bog'liqliklar tufayli biz yana bir necha narsalarni hisobga olishimiz kerak: - Agar tasodifan bir xil ga ega bo'lgan bir nechta elementlar bo'lsa-chi? - Agar element umuman mavjud bo'lmasa-chi? - Agar bu element bo'lmasa-chi? Ro'yxat elementlarini ( elementlarini) boshqa ota elementlariga qo'sha olamizmi? - Agar lar o'rniga larni ishlatsak nima bo'ladi? Bizning ma'lumot manbalarimiz JavaScript va HTML o'rtasida aralashgan bo'lib, bu ularni ishonchsiz qiladi. Bizga yagona ishonch manbasi ko'proq foyda keltiradi. Bundan tashqari, klient tomonidagi JavaScript elementlarni DOM’dan qo'shish va olib tashlashni doimiy ravishda amalga oshiradi. Agar biz ushbu o'ziga xos elementlarning mavjudligiga tayanadigan bo'lsak, UI yangilanayotganda, dasturimizning ishonchli ishlashiga hech qanday kafolatlar yo'q. Bu holda, bizning dasturimiz \"_side effectlar_\" bilan to'lgan bo'lib, uning muvaffaqiyati yoki muvaffaqiyatsiz bo'lishi foydalanuvchi muammosiga bog'liq. React buni funksional dasturlashdan ilhomlangan modelni targ'ib qilish orqali hal qildi, bu yerda \"_side effectlar\"_ ataylab belgilangan va izolyatsiya qilingan. Samarasiz elementlarni ekranga ketma-ket joylashtiradi. DOM’ning har bir o'zgarishi hisoblash nuqtai nazaridan qimmatga tushishi mumkin, ayniqsa, layout shift va reflow’ga duch kelganimizda. Biz begona sayyorada (noma'lum hisoblash quvvatiga ega muhitda) bo'lganimiz uchun, bu katta ro'yxatlar holatida ishlash nuqtai nazaridan xavfli bo'lishi mumkin. Eslatib o'tamiz, bizning keng miqyosli veb-dasturimiz butun dunyo bo'ylab millionlab foydalanuvchilar, jumladan, oxirgi va eng so'nggi Apple M3 Max protsessorlaridan foydalanish imkoni bo'lmagan jamiyatdan, past quvvatli qurilmalarga ega foydalanuvchilar tomonidan ishlatilishi uchun mo'ljallangan. Ushbu holatda, alohida ro'yxat elementlarini ketma-ket yangilash o'rniga, ushbu amallarni qandaydir tarzda guruhlash va ularning barchasini bir vaqtning o'zida DOM’ga qo'llash maqsadga muvofiq bo'lishi mumkin. Lekin, ehtimol biz injenerlar sifatida buni qilishimizning hojati yo'q, chunki brauzerlar oxir-oqibat DOM’ni tez yangilanish bilan ishlash usullarini yangilab, biz uchun bu narsalarni avtomatik ravishda guruhlab yangilashi(batch update) mumkin. React va boshqa yechimlar Bu React va boshqa abstraksiyalar paydo bo'lishidan oldin veb-dasturchilarni yillar davomida qiynagan ba'zi muammolar. Keng miqyosda maintain qilinadigan, qayta ishlatiladigan va prognozli tarzda paketli kod yaratish muammosi industriyada ko'p standartlashtirilgan kelishuvga ega emas edi. Shu paytgacha, ishonchli va kengaytirish mumkin bo'lgan foydalanuvchi interfeyslarini yaratish qiyinchiliklarini ko'plab veb-kompaniyalar boshdan kechirgan edi. Shu paytga kelib, biz JavaScript asosidagi bir nechta yechimlarning mashhurlashayotganini ko'rdik: Backbone, KnockoutJS, AngularJS va jQuery. Keling, ushbu yechimlarni birma-bir ko'rib chiqaylik va ular bu muammoni qanday hal qilganini ko'rib chiqaylik. Bu bizga React qanday qilib boshqa yechimlardan farq qilishini va hatto ulardan ustun bo'lishi mumkinligini tushunishga yordam beradi.",
    "url": "/books/fluent-react/entry-level-stuff/world-before-react/page",
    "category": "books",
    "tags": [
      "fluent-react",
      "tutorial",
      "guide",
      "react",
      "javascript",
      "frontend",
      "uchun",
      "biz",
      "kerak",
      "mumkin",
      "tugma",
      "event",
      "bir",
      "buni",
      "tugmani",
      "javascript",
      "lekin",
      "bilan",
      "react",
      "yoki",
      "agar"
    ]
  },
  {
    "id": "book-fluent-react-frameworks-benefits-of-using-framework-page",
    "title": "Nega Freymvork Ishlatish Kerak? Tuzilma, Optimallashtirish va Boshqalar",
    "content": "Freymvork’dan foydalanishning afzalliklari Freymvorklardan foydalanishning afzalliklari quyidagilardan iborat: Tuzilma va izchillik Freymvorklar kodni tashkil qilish uchun ma'lum bir struktura va pattern’ni ta'minlaydi. Bu izchillikka olib keladi, bu esa yangi dasturchilarga ilovaning oqimini tushunishni osonlashtiradi. Shu bilan birga, kod tuzilmasi haqida qayg'urmasdan, mahsulot va funksiyalarimizga e'tibor qaratish imkoniyatini beradi. Eng yaxshi amaliyotlar Freymvorklar odatda ichki o'rnatilgan eng yaxshi amaliyotlarni o'z ichiga oladi va dasturchilarni ularga rioya qilishga undaydi. Bu kod sifatini yaxshilaydi va xatolarni kamaytiradi. Masalan, freymvorklar odatda ma'lumotlarni erta, ya'ni serverda olishni rag'batlantiradi, bu esa klient tomoni ma'lumotni olishini kutishdan ko'ra yaxshiroq ishlash samaradorligi va foydalanuvchi bilan ishlash qulayligini ta'minlaydi. Abstraksiyalar Freymvorklar routing, ma'lumotlarni olish, serverda render qilish va shunga o'xshash umumiy vazifalarni bajarish uchun yuqori darajali abstraksiyalarni taqdim etadi. Bu kodingizni toza, tushunarli va oson boshqariladigan qiladi. Keng hamjamiyatning mavjudligi esa bu abstraksiyalarning sifatini ta'minlashga yordam beradi. Masalan, Next.js tomonidan taqdim etilgan hook’ini olaylik, bu komponentlaringizda router’larga oson kirish imkoniyatini beradi. Ishlash samaradorligi optimizatsiyalari Ko'plab freymvorklar kodlarni bo'lib yuklash, serverda render qilish va statik sayt yaratish kabi oldindan optimizatsiyalangan funksiyalarga ega. Bu ilovangizning ish faoliyatini sezilarli darajada yaxshilaydi. Masalan, Next.js ilovangizni avtomatik ravishda kodini bo'lib yuklaydi va foydalanuvchi havola ustiga kursorni olib borganida keyingi sahifaning kodini oldindan yuklab qo'yadi, bu esa sahifalararo o'tishni tezlashtiradi. Hamjamiyat va ekotizim Ommabop freymvorklar katta hamjamiyatga va boy plaginlar va kutubxonalar ekotizimiga ega. Bu shuni anglatadiki, muammoga duch kelsangiz, tezroq yechim topish yoki yordam olish imkoniyati mavjud bo'ladi.",
    "url": "/books/fluent-react/frameworks/benefits-of-using-framework/page",
    "category": "books",
    "tags": [
      "fluent-react",
      "tutorial",
      "guide",
      "react",
      "javascript",
      "frontend",
      "freymvorklar",
      "esa",
      "qilish",
      "beradi",
      "masalan",
      "serverda",
      "ishlash",
      "freymvork",
      "foydalanishning",
      "afzalliklari",
      "tuzilma",
      "uchun",
      "minlaydi",
      "olib",
      "bilan"
    ]
  },
  {
    "id": "book-fluent-react-frameworks-choosing-framework-page",
    "title": "React Freymvork Tanlash: Next.js vs Remix",
    "content": "Freymvork tanlash Loyihangiz uchun qaysi React freymvorkidan foydalanishni tanlash qiyin bo'lishi mumkin, chunki har bir freymvork o'ziga xos xususiyatlar, afzalliklar va kamchiliklarni taqdim etadi. Ushbu mavzuda mashhur React freymvorklarini dasturchilar uchun jozibador qiladigan omillarni ko'rib chiqamiz va o'rganish murakkabligi, moslashuvchanlik, va samaradorlik kabi tanlovingizga ta'sir qilishi mumkin bo'lgan omillarni muhokama qilamiz. Bu orqali loyihangiz uchun eng mos freymvorkni tanlashda yo'nalish topishingiz mumkin. Shuni ta'kidlab o'tish kerakki, bir freymvorkni boshqasidan yaxshiroq yoki yomonroq deb bo'lmaydi. Har bir freymvork o'z kuchli va zaif tomonlariga ega, va loyihangiz uchun eng yaxshi tanlov sizning maxsus talab va afzalliklaringizga bog'liq bo'ladi. Loyihangiz talablarini tushunish Har bir freymvorkni ko'rib chiqishdan oldin, loyihangizning aniq ehtiyojlarini tushunish muhimdir. Bu yerda e'tibor qilishingiz kerak bo'lgan bir nechta muhim savollar mavjud: - Loyihangiz qamrovi qanday? Bu kichik shaxsiy loyiha, bir nechta funksiyalarga ega o'rta kattalikdagi dastur yoki keng ko'lamdagi, murakkab dasturmi? - Loyihangizga qanday asosiy funksiyalar va imkoniyatlarni kiritishni xohlaysiz? - Server tomonda render qilish (SSR), statik sayt yaratish (SSG) yoki ikkisining kombinatsiyasi kerakmi? - SEO samaradorligi uchun kontentga boy sayt, masalan, blog yoki elektron tijorat sayti yaratmoqdamisiz? - Loyihangizda real vaqt ma'lumotlari yoki juda dinamik kontent muhim rol o'ynaydimi? - Qurish jarayonida sozlash va nazorat qilish nuqtai nazaridan sizga qanchalik moslashuvchanlik kerak? - Dasturning ishlash tezligi va samaradorligi qanchalik ahamiyatli? - React va umumiy veb-dasturlash tushunchalari bo'yicha qanchalik tajribaga egasiz? - Maqsadli foydalanuvchilaringiz kimlar? Tez internetga ega korporativ ofis xodimlarimi yoki turli xil qurilmalar va internet tezliklariga ega bo'lgan keng jamoatchilikmi? Ushbu savollarga javob berish sizga freymvorkdan nimani kutayotganingiz haqida aniqroq tasavvur beradi. Next.js qiyosida Keling, yuqoridagi parametrlarni Next.js nuqtai nazaridan o'rganamiz O'rganish murakkabligi Next.js o'z ichida React’ning eng so'nggi imkoniyatlarini qo'llaydi va ko'pincha React’ning yangi eksperimental versiyalarini ham ishlatadi. Bu Next.js’ni dolzarb texnologiyaga ega qilish bilan birga o'rganishni bir oz qiyinlashtirishi mumkin. Biroq, Next.js jamoasi freymvork uchun keng qamrovli dokumentatsiyalar va turli xususiyatlarga oid aniq yo'riqnomalar taqdim etadi, bu esa sizga tezda boshlashingizga yordam beradi. Moslashuvchanlik Next.js statik va serverda render qilinadigan kontent o'rtasida moslashuvchanlikni ta'minlash uchun yaratilgan. Shuningdek, to'liq klient tomoni (client-side) ilovalarini qo'llab-quvvatlaydi, lekin bu uning asosiy maqsadi emas. Next.js ko'plab plaginlar va integratsiyalarni o'z ichiga olgan boy ekotizimni taqdim etadi, bu esa ishlab chiqish jarayonini sezilarli darajada tezlashtirishi mumkin. Ishlash samaradorligi Next.js agressiv ravishda ishlash samaradorligini birinchi o'ringa qo'yadi, ayniqsa statik sayt yaratish va serverda render qilish, shuningdek, keshlash orqali. Next.js hozirgi vaqtda to'rtta alohida maqsadga mo'ljallangan keshlash tizimi bilan birga keladi, bu esa turli foydalanish holatlari uchun eng yaxshi samaradorlikni ta'minlashga qaratilgan. Ammo, bu samaradorlik klient/server o'rtasidagi chegaralar va qaysi vaqtda qay biridan foydalanish kerakligi to'g'risidagi qaror qabul qilishda murakkablikni keltirib chiqarishi mumkin. Bundan tashqari, Next.js ishlab chiqilgan Vercel kompaniyasida React jamoasi a'zolari ham ishlaydi, bu esa Next.js va React o'rtasidagi juda yaqin aloqada rivojlanish jarayonini bildiradi. Remix Next.js bilan taqqoslaganda, Remix yangi kirib kelgan freymvork bo'lib, taxminan 10 yil avval React Router yaratuvchilari tomonidan yaratilgan. Remix vebning asosiy tamoyillariga asoslangan bo'lib, kamroq farazlar bilan ko'p moslashuvchanlikni taqdim etadi: O'rganish murakkabligi Remix’ni o'rganish Next.js’ga nisbatan biroz osonroq bo'lishi mumkin, chunki u vebning asosiy tamoyillariga ko'proq tayanadi va React’ni server komponentlariga qaratilgan yangicha yondashuvdan oldingi usulda ishlatadi. Intuitivlik Remix ko'pincha platformaning asosiy imkoniyatlarini ko'rsatishga imkon beradi. Bu yondashuvning ikki tomonlama ta'siri bor: bir tomondan bu intuitiv va tanish ko'rinadi, boshqa tomondan esa ba'zida boshqa freymvorklardagi kabi \"sehrli\" yechimlar yo'qligi sababli hafsalani pir qilishi mumkin. Ishlash samaradorligi Remix’ning routing va ma'lumot yuklash bo'yicha noyob yondashuvi uni samarali va tezkor qiladi. Ma'lumotlarni olish routing’ga bog'liq bo'lib, faqat kerakli routing uchun kerakli ma'lumotlar olinadi, bu esa umumiy ma'lumot hajmini kamaytiradi. Shuningdek, Remix’da optimistik UI yangilanishlari va bosqichma-bosqich yaxshilanish strategiyalari foydalanuvchi bilan ishlash qulayligini oshiradi. Ijobiy va salbiy jihatlari Freymvork tanlash o'zining ijobiy va salbiy jihatlarisiz bo'lmaydi va bularning asosiy qismi qulaylik va boshqaruv o'rtasidagi tanlovni qamrab oladi. Freymvorklar ko'p narsalarni odatiy qilib o'zgartirib, bizning dasturlarimiz bo'yicha ko'plab qarorlarni qabul qilish jarayonini soddalashtiradi. Misol uchun, freymvorklar odatda quyidagi savollarga javob beradi: - Routing’ni qanday amalga oshiramiz? - Statik fayllarni qayerga qo'yamiz? - Server tomonida render qilishimiz kerakmi? - Ma'lumotlarni qayerda olishimiz kerak? Freymvorklar bu mavzularga va boshqa ko'plab mavzularga javob bergani sababli, bu biz — dasturchilardan nazoratni olib qo'yadi. Buning evaziga, dasturimizning asosiy jihatlariga, masalan, biznes logikaga e'tibor qaratish imkonini beradigan qulaylikka ega bo'lamiz. Ko'pgina ijobiy va salbiy jihatlar qulaylik va boshqaruv o'rtasidagi tanlov bilan bog'liq. To'g'ri freymvork tanlash To'g'ri freymvorkni tanlash loyihangiz ehtiyojlari va shaxsiy afzalliklarga bog'liq: - Agar to'liq stackli (fullstack) loyiha bilan ishlash imkoniyatini beruvchi va bir oz moslashuvchan freymvork kerak bo'lsa, Next.js siz uchun qulayroq bo'lishi mumkin, chunki u statik, server tarafidagi yoki faqat klient tomonli dastur yaratishga imkon beradi. - Agar veb tamoyillariga kuchli rioya qilgan holda serverga asoslangan va asta-sekin yaxshilangan yondashuvni xohlasangiz, Remix eng yaxshi tanlov bo'lishi mumkin. Ikkala holatda ham, biror kichik loyiha yoki dasturingizning bir qismi uchun ularni sinab ko'rish yaxshi g'oya bo'ladi. Shu orqali ularning qanday ishlashini va qaysi biri bilan ishlash qulayroq ekanini yaxshiroq tushunasiz. Dasturchi bilan ishlash qulayligi (DX) Ikkala freymvork ham yuqori darajadagi dasturchi bilan ishlash qulayligini taklif qiladi, ular unumdorlik va foydalanish qulayligiga e'tibor qaratadi. Ularning har ikkisi dasturchilarni sifatli dasturlar yaratishga yordam beruvchi boy funksiyalar va vositalar to'plamini taqdim etadi, buni biz ilgari ushbu bobda ko'rib chiqdik. Loyihaning murakkabligi va hajmi oshgani sayin, qurilish samaradorligi (build performance) ham muhim ahamiyat kasb etadi. Next.js va Remix qurilish vaqtini yaxshilash uchun bir qator optimizatsiyalarni amalga oshirgan. Next.js default holatda statik generatsiyani qo'llaydi, ya’ni sahifalar qurilish vaqtida oldindan render qilinadi. Bu sahifalarning tezroq yuklanishiga olib kelishi mumkin, lekin ayni paytda ko'p sonli sahifalarga ega saytlar uchun qurilish vaqtini uzaytirishi ham mumkin. Bu muammoni hal qilish uchun, Next.js Incremental Static Regeneration(ISR)’ni joriy etdi. Bu funksiya dasturchilarga sahifalarni to'liq qayta qurishsiz yangilash imkonini beradi. ISR katta, dinamik saytlarda qurilish vaqtini sezilarli darajada yaxshilashi mumkin. Remix esa qurilish tezligi bo'yicha o'ziga xos yondashuvga ega. U _server-first_ arxitekturasini tanlagan, ya'ni sahifalar server tomonidan talabga binoan render qilinadi va HTML klientga yuboriladi. Runtime ishlash samaradorligi (Runtime performance) Ikkala Next.js va Remix ham ish faoliyatini ko'zda tutgan holda ishlab chiqilgan va tez, javob beruvchi ilovalarni taqdim etish uchun bir qator optimizatsiyalarni taklif etadi. Next.js’da samaradorlik Next.js bir nechta ichki o'rnatilgan ishlash samaradorligi optimizatsiyalari bilan birga keladi. U avtomatik kodlarni bo'lib yuklashni qo'llab-quvvatlaydi, bu har bir sahifa uchun zarur bo'lgan kodning faqat kerakli qismini yuklanishini ta'minlaydi. Shuningdek, u rasm yuklanishini yaxshilash uchun ichki _Image_ komponentiga ega. Next.js’dagi gibrid SSG/SSR modeli dasturchilarga har bir sahifa uchun eng optimal ma'lumotlarni yuklash strategiyasini tanlash imkonini beradi, bu esa ishlash samaradorligi va yangilanishni muvozanatlashtiradi. Yangilangan ma'lumotlar talab qilinmaydigan sahifalar qurilish vaqtida oldindan render qilinadi, bu esa sahifalarning tezroq yuklanishiga olib keladi. Yangilangan ma'lumotlar talab qilinadigan sahifalar uchun esa server tomonidan renderlash yoki ISR ishlatilishi mumkin. Next.js shuningdek, ma'lumotlar talablarini bloklamasdan sahifalar uchun avtomatik statik optimizatsiyani taqdim etadi, bu esa sahifalarning statik HTML fayllari sifatida taqdim etilishini ta'minlaydi va birinchi baytga qadar vaqtni (TTFB) tezlashtiradi. Nihoyat, Next.js mumkin bo'lganda React Server Component’laridan to'liq foydalanadi, bu esa klientga kamroq JavaScript jo'natishga imkon beradi va sahifalarning va boshqa yuklamalarning tezroq yuklanishiga va olib keladi. Remix’da samaradorlik Remix ishlash samaradorligida biroz boshqacha yondashuvni tanlaydi. U sahifalarni oldindan render qilish o'rniga, server tomonda renderlashni tanlaydi va faqat klientga zarur bo'lgan HTML’ni uzatadi. Bu dinamik kontent uchun TTFB’ni tezlashtirishi mumkin. Remixning muhim xususiyatlaridan biri uning kuchli keshlash strategiyasidir. U brauzerning native fetch va kesh API’laridan foydalanadi, bu esa dasturchilarga turli resurslar uchun kesh strategiyalarini belgilash imkonini beradi. Bu esa sahifalarning tezroq yuklanishiga va ilovani yanada mustahkamroq qiladi. Next.js va Remix Ikkala Next.js va Remix ham katta hajmdagi, murakkab loyihalar uchun jozibador afzalliklarni taklif etadi. Ular har ikkalasi ham dasturchi bilan ishlash qulayligi, qurilish ish samaradorligi va runtime bo'yicha yuqori natijalarga erishadilar. Agar siz kengaytirilgan resurslar va plaginlarga ega yetuk ekotizimni, gibrid SSG/SSR modelini va ISR kabi innovatsion xususiyatlarni afzal ko'rsangiz, Next.js yaxshiroq tanlov bo'lishi mumkin. Aksincha, agar siz server tomonda render qilishga, darhol joylashuvlarga, brauzer platformasi xususiyatlariga (fetch va kesh API’lar) va Suspense hamda Server Component’lar kabi takomillashgan React konseptlariga katta e'tibor qaratishni afzal ko'rsangiz, Remix sizga mos kelishi mumkin. Sizning alohida loyihangizga eng mos keluvchi freymvork, oxir-oqibat, jamoangizning tajribasiga, loyiha talablariga va ma'lum arxitektura pattern’lariga bo'lgan afzalliklaringizga bog'liq bo'ladi. Tanlovdan qat'i nazar, Next.js va Remix ikkalasi ham yuqori sifatli va samarali React ilovalarini yaratish uchun mustahkam asosdir.",
    "url": "/books/fluent-react/frameworks/choosing-framework/page",
    "category": "books",
    "tags": [
      "fluent-react",
      "tutorial",
      "guide",
      "react",
      "javascript",
      "frontend",
      "next",
      "uchun",
      "mumkin",
      "remix",
      "bir",
      "ishlash",
      "esa",
      "react",
      "bilan",
      "freymvork",
      "server",
      "ega",
      "ham",
      "etadi",
      "yoki"
    ]
  },
  {
    "id": "book-fluent-react-frameworks-next-js-page",
    "title": "Next.js Tahlili: App Router, Server Components va Actions",
    "content": "Next.js freymvorki haqida Next.js, Vercel tomonidan ishlab chiqilgan mashhur React freymvork'i bo'lib, server tomonidan render qilinadigan (SSR) va statik veb-saytlar yaratishda keng imkoniyatlar va soddalikni taqdim etishi bilan tanilgan. Bu \"sozlamalar o'rniga konvensiya\" (convention over configuration) tamoyiliga amal qiladi, ya'ni loyihani boshlash uchun zarur bo'lgan ortiqcha sozlamalar va qarorlar qilishni kamaytiradi. Next.js 13 chiqarilishi bilan muhim yangiliklardan biri Next.js App Router funksiyasining qo'shilishi bo'ldi. Asosiy Next.js ilovasi Yangi Next.js ilovasini yaratishni tushunish uchun, quyidagi buyruqni bajarish orqali boshlaymiz: Bu bizga bir nechta savollar beradi, lekin yakunda asosiy Next.js loyihasiga ega bo'lamiz. Atrofga nazar solib, ichidagi tarkibni ko'rib chiqamiz. Loyihani ko'rib, _app_ kategoriyasida _page.tsx_, _layout.tsx_, _error.tsx_ va _loading.tsx_ fayllari borligini sezamiz. Bir narsani darhol payqashimiz mumkinki, Next.js Remix singari server konfiguratsiyalarini oshkor etmaydi, aksincha, ko'plab murakkabliklarni yashiradi va bu orqali dasturchilarni o'z ilovalarini yaxshiroq yaratishga e'tibor qaratishga yo'naltiradi. Bu turli xil freymvork'larning bir xil muammolarni turli yondashuvlar va falsafalar orqali hal qilishini ko'rsatuvchi yaxshi misol hisoblanadi. Endi Next.js’ni uch asosiy xususiyat — _server rendering_, _routing_ va _data fetching_ nuqtayi nazaridan ko'rib chiqamiz. Server rendering Next.js server tomonidan render qilish imkoniyatini taqdim etish bilan birga, _server-first_ tamoyiliga ham amal qiladi. Next.js’dagi har bir sahifa va komponent server komponenti hisoblanadi. Server komponentlariga keyingi bobda batafsilroq to'xtalamiz, lekin hozircha ularni faqat serverda render qilinadigan komponentlar deb tushunish kifoya. Bu tushunish darajasi hozircha yaxshi, chunki asosiy e'tibor server komponentlariga emas, Next.js’ga qaratilgan. Next.js’da bu kontekst nimani anglatadi? Aslini olganda, biz yozgan kodimizning barcha qismi faqat serverda bajarilishini hisobga olishimiz kerak. Buni o'zgartirish uchun faqat kerakli route yoki komponent ustiga direktivasini qo'shish kerak bo'ladi. Bu direktiva bo'lmasa, barcha kod server kodi deb qabul qilinadi. Biroq, Next.js ham _static-first_ yondashuvini qo'llaydi: qurish(build) vaqtida barcha server komponentlari imkon qadar statik kontentga aylantiriladi va keyin serverga joylanadi (deploy). Bu _server-first_ va _static-first_ kombinatsiyasi Next.js’ni juda kuchli qiladi va ishlash samaradorligini sezilarli darajada ustun bo'lishini ta'minlaydi, chunki statik kontent eng tez yetib boradigan kontent turi hisoblanadi - unda runtime yoki server tomoni jarayoni talab qilinmaydi, faqat HTML tekstini o'z ichiga oladi. Statikdan keyingi bosqich esa serverda render qilingan kontent bo'lib, uni optimizatsiya qilish va keshlash mumkin, lekin baribir serverdan foydalangan holda render qilishni talab qiladi. Oxirgi bosqich esa sahifaning interaktiv qismlarini hidratsiya qilish orqali klient tomoni orqali render qilinadi. Bu yondashuv bilan Next.js foydalanuvchilarga kichikroq JavaScript to'plam paketlarini yuborishga imkon beradi, bunda kontentning asosiy qismi statik va serverda render qilingan bir markup’larning aralashmasidan iborat bo'ladi. Faqat sahifalar emas, balki komponentlar ham serverda render qilinishi imkoniyati mavjudligi Next.js’ning kuchli tomonlaridan biri hisoblanadi, bu esa ma'lumotlarni olish va render qilish uchun kuchli imkoniyatlar yaratadi. Keyingi bosqichlarda ushbu imkoniyatlardan qanday foydalanish mumkinligini ko'rib chiqishdan oldin, Next.js qanday qilib route’larni boshqarishini o'rganamiz. Routing Yangi Next.js loyihamizda biz _app_ katalogini ko'ramiz, unda _layout.tsx_ va _page.tsx_ mavjud. Next.js quyidagi pattern’ga amal qiladi: foydalanuvchilar brauzerlarida ko'radigan yo'l - ya'ni sahifa URL’i - katalog nomiga mos keladi, bunda _app_ ildiz yo'li (/) bilan tenglashtiriladi, va uning ostidagi har bir katalog subyo'lga aylanadi. Buni yaxshiroq tushunish uchun _cheese_ nomli katalog yaratib, unga _page.tsx_ faylini qo'shamiz. Agar _./app_ ostidagi katalogda _page.tsx_ fayli bo'lsa, u katalog route’iga aylanadi. Keling, _./app/cheese/page.tsx_’ga kontent qo'shamiz: Endi, agar ishlab chiqish serverini ishga tushirsak va _/cheese_ yo'liga o'tsak, qiziq sarlavha bilan sahifani ko'ramiz. Shuni ta'kidlash joizki, Next.js ham Remix singari umumiy layout’lar tushunchasiga ega. Masalan, _./app/layout.tsx_ faylida layout komponentini belgilab, uni har bir sahifada render qilishimiz mumkin. Keyin, _./app/cheese/layout.tsx_ fayli esa _/cheese_ route’iga tegishli har bir sahifada render qilinadi. Layout’lar odatda bir nechta sahifalar orasida umumiy bo'lgan qismlarni, masalan, header yoki footer’lar kabi, ko'p ishlatiladigan elementlarni ifodalaydi. Demak, Next.js route’larni mana shunday boshqaradi. Bu Remix va fayl tizimi asosidagi route’lashning o'zimiz yaratgan usulimizga o'xshaydi, ammo kichik farqlari bor: bitta fayl emas, balki butun katalog sahifa bo'ladi va sahifaning o'zi doim _page.tsx_ deb atalishi kerak. Bundan tashqari, uslub juda o'xshash. Endi esa ma'lumotlarni olish haqida gaplashamiz. Ma'lumotlarni olish (data fetching) Next.js’da har bir komponent server komponent bo'lgani uchun, har bir komponent asinxron bo'lib, ma'lumotlarni orqali olish imkoniyatiga ega. Oldingi Remix misolimizdagi kabi pishloqlarni Next.js’da olishni sinab ko'ramiz: Buni ko'rib hayratlangan bo'lsangiz ajab emas. Ha, React muhandislari yillar davomida orzu qilgan sintaksis bu – ma'lumotlarni olish va ulardan foydalanishning o'ziga xos va tabiiy usuli. Bu server komponent bo'lgani uchun buning iloji bor: u klient tomonida yuklanmaydi, balki serverda render qilinadi. Bu esa bizga ma'lumotlarni orqali olish va ularni to'g'ridan-to'g'ri sahifada ko'rsatish imkonini beradi. Barcha komponentlar server komponent bo'lganligi sababli, ma'lumotlarni sahifa darajasida olish o'rniga, agar istasak, komponent darajasida ham olish imkoniyatiga egamiz. Misol uchun, bu sahifani kichikroq komponentlarga ajratib, nomli qayta foydalanish mumkin bo'lgan komponent sifatida yaratib, uni bu sahifada ishlatishimiz va boshqa joylarda ham ishlatishimiz mumkin. Sahifaning ko'rinishi Bizning sahifamiz quyidagicha ko'rinishga ega bo'ladi: komponenti esa quyidagicha bo'ladi: Bu yondashuvning haqiqiy kuchi shundaki, biz ma'lumotlarni sahifa emas, balki komponent darajasida olishimiz va ularni sahifaga render qilishimiz mumkin. Endi sahifa darajasida , , , kabi funksiyalarni eksport qilishning hojati yo'q. Shunchaki ma'lumotlarni komponent darajasida olamiz va sahifaga render qilamiz. Ma'lumotlar qanday ishlatiladi Next.js bu ma'lumotlardan bizning sahifamizni dastlab statik holatda yuklash uchun foydalanadi va keyingi yuklashlarda serverda render qiladi. Shuningdek, Next.js turli keshlash va deduplikatsiya (takrorlanishni bartaraf qilish) mexanizmlariga ega bo'lib, bu ma'lumotlar yaxlitligi va sahifa samaradorligini ta'minlaydi. Oxirgi qadam sifatida, Next.js qanday qilib ma'lumotlar o'zgarishini (mutatsiyalarini) boshqarishini ko'rib chiqamiz. Ma'lumotlarni mutatsiya qilish (mutating data) Next.js serverda ishlaydigan _server actions_ (server harakatlari) tushunchasiga ega. Bu funksiyalar serverda ishlaydi va ular forma yuborilganda, foydalanuvchi tugmani bosganda yoki sahifaga o'tganda chaqiriladi. Bu funksiyalar klient to'plam paketiga kiritilmagan va faqat serverda ishlaydi. Server harakatlari (server actions) Keling, Remix misolidagidek, ro'yxatga pishloq qo'shishni ko'rib chiqaylik. Buning uchun sahifamizga forma qo'shamiz: Bu yerda Remi’xga o'xshash standart HTML shakldan foydalanmoqdamiz, faqat bu safar atributi funksiya sifatida ishlamoqda. Bu funksiya _server action_ bo'lib, forma yuborilganda chaqiriladi. Bu funksiya klient to'plam paketi(client bundle)ga kiritilmagan va uning o'rniga serverda ishlaydi. Bu yuqoridagi direktivasi orqali belgilanadi. Bu funksiyani istalgan joyga ko'chirishimiz mumkin, jumladan uni server komponenti tanasiga ham joylashimiz mumkin, quyidagi kabi: yoki hattoki alohida modulga ham ko'chirishimiz mumkin, quyidagi kabi: Bu holda, o'z faylida quyidagi tarzda ko'rinadi: Interaktivlik muammosi Bu yerda o'ziga xos bir muammo bor, chunki barcha komponentlari klient komponentlari bo'lgan Remix’dan farqli o'laroq, server komponentlari umuman interaktivlikni qo'llab-quvvatlamaydi, chunki ular klient to'plam paketiga kiritilmaydi va brauzer tomonidan yuklanmaydi; shuning uchun ishlov beruvchilar uni hech qachon foydalanuvchilarga yetkaza olmaydi. Ushbu muammoni hal qilish uchun, Next.js klient komponentlari tushunchasini yaratgan, bu komponentlar klient to'plam paketiga kiritiladi va brauzer tomonidan yuklanadi. Bu komponentlar server komponentlari emas va shu sababli asinxron bo'lishi yoki server harakatlariga ega bo'la olmaydi. Klient komponenti sifatida ishlatish Pishloq qo'shishni kiritamiz, lekin bu safar server va klient komponentlarini aralashtirgan holda. Bu, shuningdek, formani yuborishga javoban darhol _spinner_ yoki shunga o'xshash narsalar bilan javob qaytarishga yordam beradi. Buning uchun biz yangi komponent, ./app/AddCheeseForm.tsxni yaratamiz: useFormStatus hook Endi bu klient komponentiga aylanganligi sababli, biz interaktiv narsalarni bajara olamiz — masalan, forma holatidagi o'zgarishlarga javob berish. ni bunga mos ravishda yangilaymiz: bizning klient komponentimiz bo'lgani uchun, biz dan foydalanib, forma statusini olishimiz mumkin. Bu React tomonidan taqdim etilgan hook hisoblanadi. Ushbu hook xususiyatiga ega bo'lgan obyektni qaytaradi, bu forma yuborilayotganida , va yuborilmayotganida qiymatini qaytaradi. Biz buni formani yuborilayotganda o'chirish va yuklanish indikatorini ko'rsatish uchun ishlatishimiz mumkin. Endi biz ushbu formani o'z sahifamizda, server komponenti sifatida ishlatishimiz mumkin, quyidagicha: Server va klient komponentlarini birga ishlatish Natijada biz server va klient komponentlarini aralashtirdik. va server komponentlari, va klient komponentidir. Ikkala komponent ham qayta foydalanishga yaroqli va dasturimizning boshqa joylarida ham ishlatilishi mumkin. Klient va server komponentlari bilan bog'liq ba'zi qoida va mulohazalar mavjud, lekin biz bularni keyingi bobda o'rganamiz. Hozircha, agar keng ko'lamda qarasak, Next.js Remix va fayl tizimiga asoslangan route’lash, ma'lumotlarni olish va ma'lumotlarni mutatsiya qilishni o'zimiz implementatsiya qilish kabi muammolarni hal qilishini ko'ramiz. Bu biroz boshqacha usulda amalga oshiriladi, ammo asosiy mexanizmlar bir-biriga o'xshashdir. Ideal holda, ushbu ikkala freymvorkni o'rganish orqali biz nima uchun freymvorklarga murojaat qilishimiz kerakligini, ularning qanday muammolarni hal qilishini va bizning foydamiz uchun qanday yechim berishini tushunishimiz mumkin. Kelin, freymvorkni qanday tanlash haqida gapirish bilan bo'limni yakunlaymiz.",
    "url": "/books/fluent-react/frameworks/next-js/page",
    "category": "books",
    "tags": [
      "fluent-react",
      "tutorial",
      "guide",
      "react",
      "javascript",
      "frontend",
      "next",
      "server",
      "uchun",
      "klient",
      "render",
      "bir",
      "komponent",
      "mumkin",
      "tsx_",
      "lumotlarni",
      "serverda",
      "biz",
      "ham",
      "bilan",
      "orqali"
    ]
  },
  {
    "id": "book-fluent-react-frameworks-page",
    "title": "React Freymvorklari: Nega Ular Kerak va Qanday Ishlaydi?",
    "content": "Freymvorklar Bizning React orqali sayohatimiz davomida uning kuchi va ko'p qirraliligiga hissa qo'shadigan keng qamrovli xususiyatlar va tamoyillarni ochib berdik. Oldingi bobda asinxron React’ning qiziqarli olamiga kirib bordik, bu esa bizga juda tezkor va foydalanuvchilar uchun qulay interfeyslarni yaratish uchun va kabi vositalarni taqdim etadi. Ushbu vositalar React’ning murakkab rejalashtirish va ustuvorlik mexanizmlaridan qanday foydalanishini o'rgandik, bu esa Fiber reconciler’i yordamida optimal ishlashni ta'minlaydi. Ushbu asinxron pattern’larni tushunish, biz ushbu bobda React freymvorklariga kirayotganimizda muhimdir. React o'z-o'zidan juda kuchli, ammo ilovalar murakkablikda o'sgan sari, biz tez-tez o'xshash pattern’larni takrorlash yoki umumiy muammolar uchun yanada qulay yechimlar zaruriyatiga duch kelamiz. Bu yerda freymvorklar muhim ahamiyatga ega. React freymvorklari — bu React ustiga qurilgan dasturiy ta'minot kutubxonalari yoki vositalar to'plamlari bo'lib, umumiy vazifalarni samaraliroq hal qilish va eng yaxshi amaliyotlarni ta'minlash uchun qo'shimcha abstraksiyalarni taqdim etadi.",
    "url": "/books/fluent-react/frameworks/page",
    "category": "books",
    "tags": [
      "fluent-react",
      "tutorial",
      "guide",
      "react",
      "javascript",
      "frontend",
      "react",
      "uchun",
      "ushbu",
      "freymvorklar",
      "bobda",
      "asinxron",
      "ning",
      "esa",
      "juda",
      "qulay",
      "taqdim",
      "etadi",
      "vositalar",
      "qanday",
      "pattern"
    ]
  },
  {
    "id": "book-fluent-react-frameworks-recap-page",
    "title": "React Freymvorklari Xulosasi: Next.js, Remix va Asosiy Konsepsiyalar",
    "content": "Bo'limni qisqacha takrorlash Ushbu bo'lim davomida biz React freymvorklari kontseptsiyasini chuqur o'rganib chiqdik. Bu bo'lim bizga asosiy tamoyillarni, sabablarini va freymvorklardan foydalanishning amaliy oqibatlarini o'rganish imkonini berdi. Muhokamalar concurrent React va uning samarali renderlash va foydalanuvchi interaktivligi uchun ta'siri haqida takrorlash bilan boshlandi. So'ngra, biz React freymvorklarining “nima uchun” va “nima” ekanini o'rganishga o'tdik: ular nima uchun zarur, qanday foydalar taklif etadi va qanday ijobiy va salbiy jihatlar keltirib chiqaradi. Biz o'zimizning asosiy freymvorkimizni amalga oshirish orqali React freymvorklarining asosiy mexanizmlari va kontseptlarini tushunishga erishdik. Shuningdek, ko'pchilik React freymvorklarida keng tarqalgan xususiyat bo'lgan _filesystem-based routing_ kontseptsiyasini o'rganib chiqdik. Biz ma'lumotlarni olish va uni freymvorkda qanday amalga oshirish mumkinligini ko'rib chiqdik. Keyin, biz turli freymvorklarni taqqoslashga kirishdik, asosan Next.js va Remix’ga e'tibor qaratdik. Har bir freymvork o'zining noyob xususiyatlari va afzalliklarini taklif etadi, va tanlov ko'pincha loyihaning aniq talablariga bog'liq bo'ladi. Biz bu freymvorklar _server rendering_, _routing_, _data fetching_ va _mutating data_ muammolarini qanday hal qilganini o'rganib chiqdik va bu xususiyatlarni o'zimizning implementatsiyamiz bilan taqqosladik. Ushbu jarayonda biz o'zimizning implementatsiyamiz va freymvorklar o'rtasidagi umumiyliklarni tushunishga yordam beradigan mexanizmni o'rganib chiqdik. Shuningdek, freymvorklardan foydalanish bilan bog'liq ijobiy va salbiy jihatlarni o'rganib chiqdik va ularni asosiy mexanizmlarni tushunish orqali qanday yengillashtirish mumkinligini ko'rib chiqdik. Yakunida, freymvork tanlashni muhokama qildik va bu qarorda ishtirok etadigan ijobiy va salbiy jihatlarni o'rganib chiqdik. Shuningdek, freymvorklarning dasturchi bilan ishlash qulayligi va _runtime performance_ ko'rsatkichlarini ko'rib chiqdik va loyihalarimiz uchun eng yaxshi variantlar nima ekanligini ko'rib chiqdik. Takrorlash uchun savollar Ushbu bo'limni yakunlayotganda, qamrab olingan kontseptlarni qayta ko'rib chiqishga yordam beradigan bir necha savollar: 1. _Nima uchun Next.js yoki Remix kabi React freymvorklarini ishlatishning asosiy sabablari mavjud va ular qanday foydalar taklif etadi?_ 2. _React freymvorkidan foydalanish bilan bog'liq qanday ijobiy va salbiy jihatlar yoki kamchiliklar mavjud?_ 3. _Freymvorklar tomonidan hal qilinadigan ba'zi umumiy muammolar nimalardan iborat?_ 4. _Ushbu freymvorklar bu muammolarni qanday hal qiladi?_ Keyingi bo'lim Ushbu bo'limda biz React Server Components haqida qisqacha ma'lumot berdik va ular haqida yuzaki ma'lumotga ega bo'ldik. Keyingi bo'limda, React Server Components’ga e'tiborni kuchaytiramiz va ularning qiymat taklifini va qanday ishlashini tushunish uchun minimal server yozamiz, bu server React Server Components’ni render qilib beradi va taqdim etadi. Shuningdek, React Server Components yangi avlod qurilish vositalari, masalan, bundler’lar, router’lar va boshqalarni talab qilishining sabablari ham ko'rib chiqamiz. Natijada, biz React Server Components va ularning asosiy mexanizmi haqida yaxshiroq tushunchaga ega bo'lamiz, bu esa bizni ma'lumot beruvchi va ta'lim beruvchi chuqur tahlilga olib keladi.",
    "url": "/books/fluent-react/frameworks/recap/page",
    "category": "books",
    "tags": [
      "fluent-react",
      "tutorial",
      "guide",
      "react",
      "javascript",
      "frontend",
      "react",
      "chiqdik",
      "biz",
      "qanday",
      "asosiy",
      "uchun",
      "server",
      "rganib",
      "rib",
      "bilan",
      "components",
      "ushbu",
      "lim",
      "haqida",
      "nima"
    ]
  },
  {
    "id": "book-fluent-react-frameworks-remix-page",
    "title": "Remix Freymvorki Tahlili: Veb Asoslariga Tayangan Yondashuv",
    "content": "Remix freymvorki Remix — bu zamonaviy va kuchli bo'lgan veb freymvorki bo'lib, React va veb platformasining imkoniyatlaridan foydalanadi. Keling, qanday ishlashini tushunish uchun amaliy misollar bilan tanishamiz. Asosiy Remix ilovasi Avval biz asosiy Remix ilovasini o'rnatamiz. Remix’ni yordamida o'rnatishingiz mumkin: Bu sizning joriy katalogingizda yangi Remix loyihasini yaratadi. Keling, ichiga nazar solamiz. Avvalambor, bizda _app_ katalogi mavjud bo'lib, unda _entry.client.tsx_ va _entry.server.tsx_ fayllari bor. Shuningdek, ushbu katalogda _root.tsx_ ham mavjud. Darhol ko'rinib turibdiki, Remix dastlabki holatda klient va server kirish nuqtalarini qo'llab-quvvatlaydi. Bundan tashqari, _root.tsx_ fayli har bir sahifada render qilinadigan umumiy layout komponentini o'z ichiga oladi. Bu, Remix’ning sizga tezda boshlashishingizga yordam beradigan oldindan belgilangan strukturani taqdim etishining ajoyib namunasidir. Server rendering Remix _entry.server.tsx_ orqali serverda render qilish texnikasini standart holatda taqdim etadi. Fayl biz uchun avtomatik ravishda yaratilgan, lekin uning qanday ishlashini bir oz tushunishga harakat qilamiz. Mana bu yerda, uning ko'rinishi keltirilgan: Kodni tushunib chiqish Remix haqida juda yaxshi narsa shundaki, ushbu fayl ichki foydalanish uchun mo'ljallangan, lekin biz uni sozlash uchun bu yerda ochiq holda taqdim etilgan. Agar biz ushbu faylni o'chirsak, Remix ushbu faylning ichki standart implementatsiyasiga murojaat qiladi. Bu, agar kerak bo'lsa, _server rendering_ xatti-harakatini sozlashimizga imkon beruvchi yaxshi chiqish yo'li. Shunday qilib, bizni freymvorkning \"sehri\"ga bog'lab qo'ymaydi. Ushbu fayl HTTP javoblari qanday yaratilishi va boshqarilishi kerakligini belgilaydi, xususan, botlar va oddiy brauzerlar uchun so'rovlar qanday boshqarilishini ta'riflaydi. Remix — bu zamonaviy React ilovalarini qurish uchun mo'ljallangan freymvork va ushbu fayl Remix ilovasining server tomoni logikasining bir qismidir. Dastlab, fayl kerakli modullar va tiplarni turli kutubxonalar, masalan, , , , va dan import qiladi. U 5,000 millisekund qiymatiga ega o'zgaruvchisini belgilaydi, bu esa renderlash operatsiyalari uchun timeout muddati sifatida ishlatiladi. Fayl bir nechta argumentlarni qabul qiluvchi funksiyasini eksport qiladi, ularga HTTP so'rovi, javob status kodi, javob sarlavha(header)lari va Remix va ilovaning yuklash jarayonlari uchun kontekstlar kiradi. ichida, kelayotgan so'rovning user-agent'ini tekshirib, kutubxonasidan foydalanib, bu botdan kelayotganini yoki yo'qligini aniqlaydi. So'rov botdan yoki brauzerdan kelishiga qarab, uni mos ravishda yoki funksiyalariga yo'naltiradi. SEO va ishlash samaradorligiga yordam Bu SEO va ishlash samaradorligiga yordam beradi. Masalan, agar so'rov botdan kelsa, javobda sahifaning render qilingan HTML kontenti bo'lishi muhim, bu esa funksiyasining vazifasidir. Aksincha, agar so'rov oddiy brauzerdan kelsa, sahifaning render qilingan HTML kontenti va sahifani hidratsiya qilish uchun zarur JavaScript kodini o'z ichiga olishi muhim, bu esa funksiyasining vazifasidir. Remix biz uchun buni avtomatik ravishda bajarishi juda ajoyib. va funksiyalari tuzilish jihatidan deyarli o'xshash, ammo render qobiq tayyor bo'lganida yoki xatoga duch kelganda har xil ishlov beruvchi, ya'ni _handler_’larga, ega. Ular HTTP javobiga ega bo'lgan promise qaytaradi. Ular yordamida o'tkaziluvchan oqim(pipeable stream)ga render operatsiyasini boshlaydi, so'rovdan olingan zarur kontekst va URL bilan birga komponentini uzatadi. Ular dan ko'proq vaqt oladigan renderlash operatsiyasini bekor qilish uchun timeout belgilaydi. Renderlash operatsiyasi uchun event handler’larida stream’ini va undan olingan o'qiladigan stream’ni yaratadi. Ular javob uchun sarlavhasini sifatida o'rnatadi. Ular promise’ni yangi obyekti bilan hal qiladi, bu esa stream, javob sarlavhalari va status kodini o'z ichiga oladi. Renderlash davomida xatolar yuzaga kelsa, ular promise’ni rad qiladi yoki xatoni konsolga yozadi, xato qaysi renderlash bosqichida yuz berganiga qarab. Ushbu fayl asosan HTTP javoblarining to'g'ri yaratilishini va qaytarilishini ta'minlaydi, botdan yoki oddiy brauzerdan kelayotgan so'rovga qarab turli renderlash logikasini qo'llaydi, bu esa zamonaviy veb-ilovalarda SEO va ishlash samaradorligiga oid masalalar uchun juda muhimdir. Agar bizda hech qanday sozlashlar bo'lmasa, biz ushbu faylni o'chirib tashlaymiz, va Remix biz uchun server tomonda renderlashni hal qiladi. Hozircha uni saqlaymiz va Remix qanday qilib router’larni boshqarishini ko'rib chiqamiz. Routing Remix’da har bir routing _routes_ katalogida joylashgan fayl bilan ifodalanadi. Agar biz _./routes/cheese.tsx_ faylini yaratib, uning default eksportini quyidagicha qilsak: va keyin lokal ishlab chiqish serverini buyrug'i bilan ishga tushirsak, biz qiziqarli sarlavhaga ega sahifani ko'ramiz. Yana bir bor, Remix bizga tezda boshlashga yordam beradigan oldindan belgilangan strukturani taqdim etishini ko'ramiz va bu konvensiyada default eksportlarning qiymati bizning avvalgi fayl tizimi asosidagi routing qilishimizga o'xshashdir. Bu _./app/root.tsx_ ichidagi umumiy layout komponenti va server va klient kirish nuqtalari bilan birlashganda, bu ko'pchilik veb-saytlarining asosini tashkil etadi. Biroq, biz zamonaviy veb-ilovalar uchun bir muhim komponentdan mahrummiz: ma'lumotlarni olish. Keling, Remix buni qanday hal qilishini ko'raylik. Ma'lumotlarni olish (data fetching) Remix’da ma'lumotlarni olish jarayoni yozilish vaqtida _loader_’lar, ya'ni _yuklovchilar_, deb nomlangan funksiyalarni ishlatishni o'z ichiga oladi. Agar siz deb nomlangan va ma'lum bir qiymat qaytaruvchi asinxron funksiyani eksport qilsangiz, bu qiymat sizning sahifa komponentingizda hook’i orqali mavjud bo'ladi. Keling, bu qanday ishlashini misol bilan ko'raylik. Oldingi pishloq sahifasiga misolimizga qaytamiz, aytaylik, biz API’dan pishloqlar ro'yxatini olishni va ularni sahifada ko'rsatishni xohlaymiz. Buni faylidan funksiyasini eksport qilish orqali amalga oshirishimiz mumkin: Ma'lumotlarni olish jarayonidagi takrorlanish Bu bilan biz o'zimizning avvalgi ma'lumotlarni olish jarayonimizda takrorlanishni ko'ramiz. Remix funksiyasi bizning funksiyamizga o'xshashligini ko'rishimiz mumkin. Shuningdek, hook’i bizning prop’imizga o'xshashligini ham ko'ramiz. Ideal holatda, hozirda biz freymvorklar ushbu xususiyatlarni qanday amalga oshirishini aks ettiruvchi umumiy pattern’lar va asosiy mexanizmlarni o'rganish imkoniyatiga egamiz. Hozirga qadar biz bularni ko'rib chiqdik: - Server rendering - Routing - Data fetching Biroq, biz hali to'xtab o'tmagan yana bir Remix xususiyati bor: formalar va server action’lar yoki mutatsiyalar — ya'ni, serverda ma'lumotlarni mutatsiya qilish, masalan, yaratish, yangilash yoki o'chirish. Keling, buni ko'rib chiqamiz. Ma'lumotlarni mutatsiya qilish (mutating data) Remix vebni uning asoslariga qaytarishga mas'ul bo'lib, native veb platformasi konvensiyalari va xatti-harakatlariga kuchli tayanadi. Buning eng yaxshi tomoni ma'lumotlarni mutatsiya qilishda va Remix’ning formalarni ishlatishida ko'rinadi. Keling, avvalgi pishloq misolimizni kengaytirib, pishloq ro'yxatini o'zgartiriladigan qilib qo'yamiz. Buni amalga oshirish uchun, _./routes/cheese.tsx_ faylini yangilaymiz: E'tiboringizni jalb qiladigan jihat shundaki, biz sahifaga yangi elementi qo'shdik. Ushbu forma harakati va metodiga ega. Bu standart HTML formasi bo'lib, route’ga POST so'rovini yuboradi. Bundan tashqari, elementi atributiga ega va yoki ishlov beruvchisiga ega emas: Remix brauzerga forma holatini va xatti-harakatlarini boshqarishiga imkon beradi. Bu Remix qanday qilib veb platformasidan foydalanib, ajoyib bo'lgan dasturchi bilan ishlash qulayligini taqdim etishi va g'ildirakni qaytadan kashf etishni o'rniga va React’ni har narsani boshqarishga majburlamasligi uchun ajoyib bir misoldir. Forma orqali ma'lumotlarni yuborish Forma uchun harakat(action) qiymati ga teng va biz allaqachon _./routes/cheese.tsx_ faylida joylashganmiz, shuning uchun forma xuddi shu route’ga yuborilishini taxmin qilishimiz mumkin. Ushbu route’ga metodi bilan kirilganida, forma yuborilganini bilamiz. Standart bo'yicha metodi bilan kirilganda esa, formani yuborish hali amalga oshirilmaganligini bilamiz va dastlabki foydalanuvchi interfeysini ko'rsatamiz. Keling, _./routes/cheese.tsx_ faylini yangilab, bu jarayonni boshqarishni qo'shamiz: Diqqat qiling, biz va argumentlarini qabul qiladigan yangi funksiyasini qo'shdik. argumenti route’ning parametrlarini o'z ichiga olgan obyekt, argumenti esa so'rov obyektini o'z ichiga oladi. Biz bu obyekt yordamida formadagi ma'lumotlarni olishimiz va yangi pishloq qo'shish uchun o'z API’mizga so'rov yuborishimiz mumkin. Yangi ma'lumotlar yuklanishi Keyin biz xuddi shu route’ga, ammo bu safar metodi bilan qayta yo'naltirishni amalga oshiramiz. Bu esa sahifaning qayta yuklanishiga sabab bo'ladi va funksiyasi qayta chaqiriladi, natijada yangilangan pishloqlar ro'yxati olinadi. Remix JavaScript faqat kerak bo'lgan joyda ishlatilishini ta'minlash va qolgan qismini brauzer boshqarishiga ruxsat berish orqali to'liq veb platformasiga tayanadi. Agar ushbu sahifa JavaScript’siz ochilgan bo'lsa, baribir ishlaydi, chunki bu veb platformasiga tayanadi. Agar sahifa JavaScript’dan foydalansa, Remix interaktivlikni va yaxshiroq foydalanuvchi bilan ishlash qulayligini qo'shib, qulaylikni progressiv ravishda yaxshilaydi. Remix umumiy ishlash prinsipi - Server tomonidan render qilishni ta'minlaydi - Route’larni boshqaradi - Ma'lumotlarni olishni (fetch) boshqaradi - Ma'lumotlarni o'zgartirishni (ya'ni mutatsiya) boshqaradi Hozirda biz o'zimiz amalga oshirgan ushbu funksiyalar va Remix’ning ularni amalga oshirish usullari o'rtasidagi kuchli o'xshashliklarni ko'rgan bo'lishimiz kerak. Bu bizning freymvorklarda ushbu funksiyalarning qanday amalga oshirilishi mexanizmlarini tushunayotganimizni ko'rsatuvchi yaxshi belgi hisoblanadi. Endi keling Next.js’ni ko'rib chiqaylik va u ushbu xususiyatlarni qanday qilib izolyatsiya qilish orqali amalga oshirayotganini ko'rib chiqamiz.",
    "url": "/books/fluent-react/frameworks/remix/page",
    "category": "books",
    "tags": [
      "fluent-react",
      "tutorial",
      "guide",
      "react",
      "javascript",
      "frontend",
      "remix",
      "uchun",
      "biz",
      "ushbu",
      "bilan",
      "qanday",
      "lumotlarni",
      "veb",
      "tsx_",
      "server",
      "bir",
      "fayl",
      "agar",
      "yoki",
      "amalga"
    ]
  },
  {
    "id": "book-fluent-react-frameworks-trade-offs-of-using-framework-page",
    "title": "React Freymvorklari: Ijobiy va Salbiy Jihatlar (Trade-offs)",
    "content": "Freymvork ishlatishning ijobiy va salbiy jihatlari Freymvorklar ko'plab afzalliklarga ega bo'lsa-da, ular ba'zi ijobiy va salbiy jihatlardan holi emas. Ushbu jihatlarni tushunish sizga freymvorkdan foydalanish va qaysi birini tanlash haqida qaror qabul qilishga yordam beradi: O'rganish murakkabligi Har bir freymvork o'ziga xos tushunchalar, API’lar va konvensiyalarga ega bo'lib, ularni o'rganish talab etiladi. Agar siz React’da yangi bo'lsangiz, freymvorkni bir vaqtda o'rganish murakkab bo'lishi mumkin, ammo baribir tavsiya etiladi. Agar siz allaqachon React bilan tanish bo'lsangiz, freymvorkning o'ziga xos xususiyatlari va API’larini o'rganish uchun vaqt sarflashingiz kerak bo'ladi. Moslashuvchanlik va konvensiyalar o'rtasidagi farq Freymvorkning qat'iy struktura va konvensiyalari foydali bo'lishi mumkin, ammo ba'zida cheklovlarga olib kelishi ham mumkin. Agar ilovangiz freymvorkning modeliga mos kelmaydigan o'ziga xos talablarga ega bo'lsa, freymvork sizga yordam berish o'rniga, unga qarshi _kurashayotganingizni_ ko'rishingiz mumkin. Masalan, ba'zi holatlarda siz tezkor internet va zamonaviy brauzerga ega foydalanuvchilar uchun dastur qurayotgan bo'lsangiz, serverda render qilish yoki ma'umot olish talab qilinmasligi mumkin. Bunday holatlarda freymvorkdan foydalanish ortiqcha bo'lishi mumkin. Qaramlik va majburiyat Freymvorkni tanlash — bu majburiyatdir. Ilovangizni freymvorkning kelajagiga bog'lashni anglatadi. Agar freymvork qo'llab-quvvatlanmay qolsa yoki sizning ehtiyojlaringizga mos kelmaydigan yo'nalishga o'tsa, boshqa freymvorkga o'tish yoki mavjud freymvork kodini o'zingiz qo'llab-quvvatlashingiz haqida qiyin qarorlar qabul qilishingizga to'g'ri kelishi mumkin. Abstraksiya yuklovi Abstraksiyalar murakkablikni yashirish orqali ishlab chiqishni soddalashtirishi mumkin bo'lsa-da, ular o'ziga xos \"sehr\" yaratishi mumkin, bu esa ichki ishlash mexanizmlarini tushunishni qiyinlashtiradi. Bu debugging va ish faoliyatini optimallashtirishni qiyinlashtirishi mumkin. Bundan tashqari, har bir abstraksiya ishlash samaradorligiga ta'sir qilishi mumkin bo'lgan qo'shimcha xarajatlar bilan keladi. Masalan, Next.js’dagi _server actions_ misol bo'la oladi, bunda direktivasi qandaydir tarzda amalni serverda bajaradi. Bu ajoyib abstraksiya, lekin uning qanday ishlashini tushunish qiyin bo'lishi mumkin. Mashhur React freymvorklari Freymvorklardan nima uchun foydalanish kerakligi va ularning afzalliklari hamda kamchiliklarini tushungan holda, endi React ekotizimidagi maxsus freymvorklarga murojaat qilishimiz mumkin. Ushbu bobning keyingi qismlarida Next.js va Remix kabi mashhur tanlovlarni o'rganamiz. Har bir freymvork o'ziga xos xususiyatlar va afzalliklarga ega bo'lib, ularni tushunish sizga o'z ehtiyojlaringiz uchun to'g'ri vositani tanlashda yordam beradi. Endi keling, ba'zi mashhur React frameworklarini o'rganamiz va ularning xususiyatlari, afzalliklari hamda ularning ijobiy va salbiy jihatlari haqida gaplashamiz. Har bir freymvork haqida qisqacha umumiy ma'lumotdan boshlaymiz, so'ngra ularning xususiyatlari va samaradorligini batafsil taqqoslaymiz. Shuningdek, loyiha uchun freymvork tanlashda e'tiborga olish kerak bo'lgan ba'zi omillarni ham muhokama qilamiz.",
    "url": "/books/fluent-react/frameworks/trade-offs-of-using-framework/page",
    "category": "books",
    "tags": [
      "fluent-react",
      "tutorial",
      "guide",
      "react",
      "javascript",
      "frontend",
      "mumkin",
      "freymvork",
      "react",
      "ega",
      "bir",
      "ziga",
      "xos",
      "uchun",
      "ijobiy",
      "salbiy",
      "haqida",
      "rganish",
      "har",
      "agar",
      "lishi"
    ]
  },
  {
    "id": "book-fluent-react-frameworks-why-we-need-framework-page",
    "title": "Nega React Freymvorklari Kerak? O'z Freymvorkimizni Yaratamiz",
    "content": "Nega bizga freymvork kerak React interaktiv foydalanuvchi interfeyslarini yaratish uchun asosiy elementlarni taqdim etsa-da, u ko'plab muhim arxitektura qarorlarini dasturchilarga qoldiradi. React bu borada fikrga ega emas, bu esa dasturchilarga ilovalarini o'zlari xohlagan tarzda tuzish uchun moslashuvchanlik beradi. Biroq, ilovalar kengaygan sari, bu erkinlik ortiqcha yukka aylanishi mumkin. Siz doimiy ravishda takroriy muammolarni hal qilish, masalan, routing, ma'lumotlarni olish va serverda render qilish kabi muammolarni hal qilishda o'z-o'zidan qaytalanish xavfiga duch kelishingiz mumkin. Bu yerda React freymvorklari yordamga keladi. Ular oldindan belgilangan strukturani va umumiy muammolar uchun yechimlarni taqdim etadi, bu esa dasturchilarga o'z ilovasining o'ziga xos tomonlariga e'tibor qaratishga imkon beradi, shuning uchun qaytariluvchan kod bilan shug'ullanish shart emas. Bu ishlab chiqish jarayonini sezilarli darajada tezlashtirishi va freymvork tomonidan ta'minlangan eng yaxshi amaliyotlarga rioya qilish orqali kod bazasining sifatini yaxshilashi mumkin. Buni to'liq tushunish uchun, keling, o'zimizning minimal freymvorkimizni yozib ko'rishga harakat qilaylik. Buni amalga oshirish uchun, biz freymvorklardan osonlik bilan ololmaydigan bir nechta asosiy xususiyatlarni aniqlashimiz kerak. Qisqa qilib aytganda, biz freymvorklardan oladigan uchta asosiy xususiyatni aniqlaymiz. Freymvorklar ko'p narsalarni bajaradi, lekin bu kichik guruh bizni ajoyib muhokama qilish uchun asos yaratadi: - Serverda render qilish - Routing - Ma'lumotlarni olish (Data fetching) Sodda freymvorkimizni tuzish Keling, mavjud bo'lgan tasavvuriy React ilovasini olib, bu xususiyatlarni bosqichma-bosqich qo'shamiz, shunda freymvorklar biz uchun nima qilishini tushunamiz. Biz \"freymvork sifatida\" qabul qilayotgan React ilovasining quyidagi strukturasi bor: - - - - - Mana, har bir fayl qanday ko'rinishga ega: Duch keladigan ba'zi muammolar Bu muammolar barcha faqat-klient tomonda render qilinadigan React ilovalariga ta'sir qiladi: Foydalanuvchiga bo'sh sahifa jo'natamiz Biz foydalanuvchiga faqat yuklash uchun kodni jo'natamiz, keyin esa JavaScript’ni tahlil qilib, bajarishimiz kerak. JavaScript ishga tushguncha, foydalanuvchi bo'sh sahifani ko'radi va keyin ular bizning ilovamizni ko'radilar. Agar foydalanuvchi qidiruv tizimi bo'lsa, ular hech narsani ko'rmaydilar. Agar qidiruv tizimi boti JavaScript’ni qo'llab-quvvatlamasa, qidiruv tizimi bizning veb-saytimizni indekslamaydi. Biz ma'lumotlarni juda kech olishni boshlaymiz Ilovamiz foydalanuvchi bilan ishlash qulayligiga ta'sir etadigan _network waterfall_(tarmoq sharsharasi) deb ataladigan bir muammoga duch keladi: bu g'aroyib hodisa, tarmoq so'rovlarining ketma-ket amalga oshirilishi natijasida yuzaga keladi va ilovalarni sekinlashtiradi. Ilovamiz asosiy funksionallik uchun serverga bir nechta so'rovlar yuborishi kerak. Masalan, ishga tushirish jarayoni quyidagicha amalga oshadi: - JavaScript’ni yuklab olish, tahlil qilish va bajarish. - React komponentlarini render qilish va tatbiq qilish. - ma'lumotlarni yuklay boshlaydi. - Spinner’lar va boshqalarni render qilish va tatbiq qilish. - ma'lumotlarni yuklashni tugatadi. - Ma'lumotlarni render qilish va tatbiq qilish. Bularning barchasini, agar biz brauzerga bevosita ma'lumotlar bilan sahifa jo'natadigan bo'lsak, oldini olishimiz mumkin: agar biz HTML markup’ini jo'natsak, xuddi 7-bobda server tomonidagi React’da muhokama qilinganidek. Router’imiz faqat klient tomonida ishlashga asoslangan Agar brauzer https://our-app.com/detail?thingId=24 manzilini so'rasa, server 404 sahifasini qaytaradi, chunki serverda bunday fayl yo'q. Bu muammoni hal qilish uchun ishlatiladigan keng tarqalgan hiyla — 404 topilganda HTML faylini render qilish va JavaScript yuklashini ta'minlaydigan sahifa yaratishdir va shunda klient tomonidagi router ishga tushadi. Bu hiyla qidiruv tizimlari yoki JavaScript qo'llab-quvvatlanishi cheklangan muhitlar uchun ishlamaydi. Freymvorklar bu muammolarni va boshqalarni hal qilishda yordam beradi. Keling, ular buni qanday qilib amalga oshirayotganini o'rganamiz. Server tomonda renderlash Odatda, freymvorklar bizga serverda render qilish imkonini o'zi bilan taqdim qiladi. Ushbu ilovaga serverda render qilishni qo'shish uchun bizga server kerak. Biz buni Express.js kabi paket yordamida o'zimiz yozishimiz mumkin. Keyin ushbu serverni joylashtiramiz va ishlaymiz. Keling, bunday serverni boshqaradigan kodni ko'rib chiqamiz. Diqqat qiling, bu yerda funksiyasidan faqat soddalik uchun foydalanamiz va freymvorklar ushbu funksiyalarni qanday amalga oshirishini tushuntirish uchun qo'shdik. Haqiqiy foydalanish holatida, serverda render qilish uchun kabi kuchliroq asinxron API’lardan foydalanish afzal, bu 6-bobda batafsil yoritilgan. Keling, buni amalga oshiramiz: Ushbu kod ilovamizga serverda render qilishni qo'shish uchun yetarli. E'tibor bering, klient tomoni uchun o'zining klient router’iga ega, va biz asosan server uchun yana bitta router qo'shdik. Freymvorklar _izomorf router’lar_ birga keladi, ya'ni klient va serverda ishlaydigan router’lar. Routing Bu server yaxshi ishlayotgan bo'lsa-da, kengaytirishda qiyinchilik tug'diradi: har bir qo'shimcha router uchun o'zimiz chaqiruvlarini qo'shishimiz kerak bo'ladi. Keling, buni biroz kengaytirish mumkinligini ko'rib chiqaylik. Bunga konfiguratsiya obyekti orqali router’larni komponentlarga bog'lash yoki fayl tizimiga asoslangan router’lash kabi bir nechta usullarda erishishimiz mumkin. Ta'lim maqsadida (va, albatta, qiziqish uchun), _fayl tizimiga asoslangan_ router’lashni o'rganamiz. Bu Next.js kabi freymvorklar tomonidan kiritilgan konvensiya va fikrlarning sababi va mexanizmini aniqroq tushunishga yordam beradi. Agar biz barcha sahifalar _./pages_ katalogida joylashishi va ushbu katalogdagi barcha fayl nomlari router yo'llariga aylanishi kerak degan qoidani qo'llasak, serverimiz bu qoidaga asoslanib ishlaydi va kengaytirish imkoniyati oshadi. Katalog strukturasini kengaytirish Buni misol yordamida ko'rsatamiz. Avval katalog tuzilmasini yangilaymiz. Yangi katalog tuzilmasi quyidagicha ko'rinadi: - - - - <br /- - Endi katalogidagi har bir narsa route’ga aylanadi, va serverimizni ushbu tuzilmaga moslashtirishimiz mumkin. Kengaytirilgan strukturaning afzalliklari Endi serverimiz _./pages_ katalogidagi konvensiya tufayli ancha kengaytirilgan! Bu yaxshi! Biroq, endi har bir sahifa komponentini default eksport qilishimiz kerak bo'ladi, chunki bizning yondashuvimiz umumiyroq bo'lib qoladi va import qilish uchun nomni oldindan bilishning imkoni bo'lmaydi. Bu freymvorklar bilan ishlashning ba'zi ijobiy va salbiy jihatlaridan biridir, ammo bu holatda, ushbu jihatlar foydali ko'rinmoqda. Ma'lumotlarni olish (data fetching) Ajoyib! Biz serverda render qilish va fayl tizimiga asoslangan route’lashni qo'shdik, lekin hali ham tarmoqda yuzaga kelayotgan \"tarmoq sharsharalari\"ga duch kelyapmiz. Keling, ma'lumot olish jarayonini yaxshilaylik. Avvalo, komponentlarimizni dastlabki ma'lumotlarni props orqali olishga moslashtiramiz. Soddalashtirish uchun faqat komponenti bilan shug'ullanamiz va komponentini sizga uyga vazifa sifatida qoldiramiz: Endi biz dastlabki prop qo'shganimiz uchun, bu sahifa uchun kerakli ma'lumotlarni serverda olish va renderlashdan oldin komponentga uzatish usulini izlashimiz kerak. Ideal holda, quyidagi tarzda harakat qilamiz: Bu shuni anglatadiki, biz ma'lumotlarga muhtoj bo'lgan har qanday sahifa komponentlaridan deb nomlangan oluvchi funksiyani eksport qilishimiz kerak bo'ladi! Buning uchun ro'yxatni sozlaymiz: Yakuniy Natija Tayyor! Endi biz: - Har bir route uchun serverda imkon qadar tezroq ma'lumotlarni olishni boshlaymiz - Butun sahifani HTML satri ko'rinishida render qilamiz - Ushbu HTML’ni klientga yuboramiz Biz turli xil freymvorklardan uchta xususiyatni o'z ilovamizga muvaffaqiyatli qo'shdik va ularning asosiy versiyalarini implementatsiya qildik. Shu orqali freymvorklarning qanday ishlashini va ularning asosiy mexanizmlarini o'rgandik. Xususan, quyidagilarni bilib oldik: - Freymvorklar bizga serverda render qilish imkonini beradi - Fayl tizimiga asoslangan izomorf router’lashdan foydalanadi - Ma'lumotlarni eksport qilingan funksiyalar orqali olish imkonini beradi Agar siz ilgari Next.js ning 13-versiyasidan avvalgi versiyalaridan foydalangan bo'lsangiz, undagi quyidagi ko'rinishlarning sabablari yanada ravshan bo'ladi: - _./pages_ katalogi - Barcha sahifa eksportlari default eksportlar bo'lishi - va funksiyalari Endi freymvorklarning kod darajasidagi mexanizmlarini va ba'zi konvensiyalarining sabablarini tushunib oldik. Keling, freymvorkdan foydalanishning umumiy afzalliklarini qisqacha ko'rib chiqamiz.",
    "url": "/books/fluent-react/frameworks/why-we-need-framework/page",
    "category": "books",
    "tags": [
      "fluent-react",
      "tutorial",
      "guide",
      "react",
      "javascript",
      "frontend",
      "uchun",
      "qilish",
      "biz",
      "render",
      "serverda",
      "router",
      "kerak",
      "lumotlarni",
      "react",
      "bir",
      "freymvorklar",
      "keling",
      "ushbu",
      "mumkin",
      "olish"
    ]
  },
  {
    "id": "book-fluent-react-inside-reconciliation-batching-updates-page",
    "title": "React'da Yangilanishlarni Guruhlash (Batching Updates)",
    "content": "Batching updates (Yangilanishlarni guruhlash) 3-bobda biz brauzerlardagi document fragmentlarini DOM’ning o'zida mavjud bo'lgan API qismlaridan biri sifatida muhokama qildik: bu yengil konteynerlar bo'lib, ular DOM tugunlarining to'plamlarini saqlaydi va vaqtinchalik DOM uchun tayyorlash maydoni vazifasini bajaradi, unda bir nechta o'zgarishlarni amalga oshirish mumkin, asosiy DOM’ga ta’sir qilmasdan. Nihoyat, document fragmenti DOM’ga qo'shilganda, bitta reflow va repaint jarayoni ishga tushadi. Xuddi shunga o'xshash tarzda, React reconciliation jarayonida real DOM’ga yangilanishlarni guruhlaydi, bir nechta vDOM yangilanishlarini bitta DOM yangilanishiga birlashtiradi. Bu real DOM’ni yangilashlar sonini kamaytiradi va shuning uchun veb-ilovalarning samaradorligini yaxshilaydi. Yangilanishlarni guruhlash va unga misol Buni tushunish uchun state’ni bir necha marotaba yangilaydigan komponentni ko'rib chiqaylik: Ushbu misolda, funksiyasi funksiyasini ketma-ket uzluksiz uch marta chaqiradi. Agar \"batching\"(yangilanishlarni guruhlash) bo'lmaganida, React real DOM’ni uch marta yangilagan bo'lardi, garchi qiymati faqat bir marta o'zgargan bo'lsa ham. Bu samarasiz va sekin bo'lardi. Biroq, React yangilanishlarni to'plab guruhlaganligi, ya'ni \"batching\" qilganligi, sababli, har safar bilan uchta yangilanish o'rniga, u DOM’ga faqat bitta yangilanishni qiymat bilan amalga oshiradi. DOM’ga eng samarali guruhlangan yangilanishni hisoblash uchun React hozirgi vDOM daraxtining yangi nusxasini yaratadi, bu yerda qiymati ga teng bo'ladi. Bu daraxt brauzerdagi mavjud bo'lgan holat bilan moslashishi (_reconciled bo'lishi_) kerak, bu esa ni ga aylantirishni anglatadi. React yangi vDOM qiymati dan foydalangan holda DOM’ga faqat bitta yangilanish talab qilinishini hisoblab chiqadi, DOM’ni qo'lda uch marta yangilash o'rniga. Bu \"batching\"ni qanday ishlashini tushuntiradi va bu biz chuqurroq o'rganishga kirishayotgan kengroq mavzuning bir qismi: reconciliation, yoki kelasi kutilayotgan DOM holatini hozirgi DOM bilan moslashtirish jarayoni. React’ning eski \"stack\" reconciler’i Hozirgi zamonaviy Reactning qanday ishlashini tushunishdan oldin, React 16-versiyasidan oldin, eski \"stack\" reconciliation mexanizmi bilan qanday qilib moslanganini ko'rib chiqamiz. Bu bizga bugungi kunda mashhur bo'lgan _\"Fiber reconciler\"_ ga bo'lgan ehtiyojni tushunishga yordam beradi. <Callout type=\"info\"Bu nuqtada, biz muhokama qiladigan barcha mavzular React’da amalga oshirilgan tafsilotlar ekanligini, vaqt o'tishi bilan o'zgarishi mumkin va ehtimol o'zgarishini qayd etish joiz. Bu yerda biz React’ning ishlash mexanizmini uning amaliy qo'llanishidan ajratmoqdamiz. Maqsad — React’ning ichki mexanizmlarini tushunish orqali React’dan ilovalarda samarali foydalanish haqida yaxshiroq tushunchaga ega bo'lishdir. </Callout",
    "url": "/books/fluent-react/inside-reconciliation/batching-updates/page",
    "category": "books",
    "tags": [
      "fluent-react",
      "tutorial",
      "guide",
      "react",
      "javascript",
      "frontend",
      "dom",
      "react",
      "yangilanishlarni",
      "bilan",
      "batching",
      "bir",
      "guruhlash",
      "biz",
      "ning",
      "lgan",
      "uchun",
      "bitta",
      "marta",
      "amalga",
      "reconciliation"
    ]
  },
  {
    "id": "book-fluent-react-inside-reconciliation-double-buffering-page",
    "title": "React'da Ikki Marta Buferlash (Double Buffering) va Fiber",
    "content": "Ikki marta buferlash (Double buffering) Ikki marta buferlash — bu kompyuter grafikalari va video ishlov berishda miltillashni kamaytirish va sezilarli ishlashni yaxshilash uchun qo'llaniladigan usul. Ushbu texnika tasvirlar yoki kadrlarni saqlash uchun ikkita bufer (yoki xotira maydoni) yaratishni va ularni muntazam intervallarda almashtirishni o'z ichiga oladi, bu orqali yakuniy tasvir yoki video namoyish etiladi. Ikki marta buferlashning ishlash jarayoni Amaliyotda ikki marta buferlash quyidagicha ishlaydi: 1. Birinchi bufer dastlabki tasvir yoki kadr bilan to'ldiriladi. 2. Birinchi bufer namoyish etilayotgan paytda, ikkinchi bufer yangi ma'lumot yoki tasvirlar bilan yangilanadi. 3. Ikkinchi bufer tayyor bo'lganda, u birinchi bufer bilan almashtiriladi va ekranga chiqariladi. 4. Ushbu jarayon davom ettiriladi, birinchi va ikkinchi buferlar muntazam intervallarda almashtiriladi va yakuniy tasvir yoki video namoyish etiladi. Ikki marta buferlashdan foydalanish orqali, miltillash va boshqa vizual ishlanmalar(artifacts) kamaytirilishi mumkin, chunki yakuniy tasvir yoki video uzilishlarsiz yoki kechikishlarsiz namoyish etiladi. Fiber reconciliation’da \"double buffering\" Fiber reconciliation ham ikki marta buferlashga o'xshash bo'lib, yangilanishlar sodir bo'lganda, joriy Fiber daraxti tarmoqlanib, foydalanuvchi interfeysining yangi holatini aks ettirish uchun yangilanadi. Ushbu jarayon _rendering_ deb ataladi. So'ng, muqobil daraxt tayyor bo'lib, foydalanuvchi ko'rishni kutgan holatni aniq aks ettirganda, u ikki marta buferlashda video buferlar almashtirilgandek joriy daraxt bilan almashtiriladi. Bu reconciliation’nning _tatbiq qilish bosqichi(commit phase)_ yoki _tatbiq qilish(commit)_ deb ataladi. Tugallanmagan, ya'ni hali ish jarayonida bo'lgan, daraxtdan foydalanish orqali Fiber reconciler bir qancha afzalliklarni taqdim etadi: - Bu real DOM’ga keraksiz yangilanishlarni kiritishni oldini olib, performance yaxshilashi va miltillashni kamaytirishi mumkin. - Agar yuqori ustuvorlikdagi yangilanish amalga oshirilishi kerak bo'lsa, UI’ning yangi holatini ekrandan tashqarida hisoblash va undan voz kechishi mumkin. - Reconciliation ekrandan tashqarida sodir bo'lganligi sababli, u hatto pauza qilishi va davom ettirishi mumkin, bu foydalanuvchi hozirda ko'rayotgan narsaga ta'sir qilmaydi. Fiber reconciler yordamida foydalanuvchi tomonidan belgilangan JSX elementlari daraxtidan ikkita daraxt hosil qilinadi: biri \"joriy\" Fiber’larni o'z ichiga oladi, va ikkinchisi hali tugallanmagan, ya'ni hali ish jarayonida bo'lgan, Fiber’larni o'z ichiga oladi. Keling, ushbu daraxtlarni biroz batafsilroq o'rganamiz.",
    "url": "/books/fluent-react/inside-reconciliation/double-buffering/page",
    "category": "books",
    "tags": [
      "fluent-react",
      "tutorial",
      "guide",
      "react",
      "javascript",
      "frontend",
      "yoki",
      "ikki",
      "marta",
      "fiber",
      "bufer",
      "video",
      "buferlash",
      "ushbu",
      "tasvir",
      "namoyish",
      "birinchi",
      "bilan",
      "mumkin",
      "reconciliation",
      "foydalanuvchi"
    ]
  },
  {
    "id": "book-fluent-react-inside-reconciliation-fiber-reconciler-page",
    "title": "React Fiber Reconciler: Ish Birligi va Ma'lumotlar Strukturasi",
    "content": "Fiber Reconciler Fiber reconciler “Fiber” deb nomlanuvchi boshqa bir ma'lumotlar strukturasidan foydalanadi, bu reconciler uchun bir ish birligi(unit)ni ifodalaydi. Fiber’lar biz 3-bobda ko'rib chiqqan React elementlaridan yaratiladi, asosiy farq shundaki, stateful(holatli) va uzoq muddatli, React elementlari esa qisqa muddatli va stateless(holatsiz)dir. Redux maintainer’i va taniqli React eksperti Mark Erikson Fiber’larni “belgilangan biror vaqt nuqtasida haqiqiy komponent daraxtini ifodalaydigan React’ning ichki ma'lumotlar strukturasidir\" deb ta'riflaydi. Darhaqiqat, bu Fiber’lar haqida yaxshi fikrdir va buni Mark o'z vaqtida aytib o'tgan, chunki u Replay bilan React ilovalarini vaqt sayohati bo'ylab debug qilish bo'yicha to'liq ishlaydi: bu ilovaning holatini qayta ko'rib chiqish va takrorlash imkonini beruvchi vosita. Agar hali ko'rmagan bo'lsangiz, Replay.io saytiga kirib ko'rishingiz mumkin. VDOM elementlar daraxti bo'lganidek, React reconciler Fiber daraxtidan foydalanadi, nomidan ko'rinib turganidek, bu VDOM asosida bevosita modellashtirilgan Fiber’lar daraxtidir. Fiber’ning ma'lumotlar strukturasi sifatida ko'rinishi React’dagi Fiber ma'lumotlar strukturasi - bu Fiber reconciler’ning asosiy komponenti hisoblanadi. Fiber reconciler yangilanishlarni ustuvorliklarga ajratib, ularga bir vaqtning o'zida ishlash imkonini beradi, bu esa React ilovalari samaradorligi va javob qaytarish qobiliyatini oshiradi. Keling, Fiber ma'lumotlar strukturasini batafsilroq ko'rib chiqamiz. Negizida, Fiber ma'lumotlar strukturasining asosiy vazifasi - bu React ilovasidagi komponent nusxasi va uning holatini ifodalashdir. Fiber ma'lumotlar strukturasi o'zgaruvchan bo'lib, reconciliation jarayonida yangilanadi va qayta tartiblanishi mumkin. Har bir Fiber tuguni nusxasida u ifodalayotgan komponent haqida ma'lumotlar, jumladan uning props, state va bola komponentlari haqida ma'lumotlar mavjud bo'ladi. Shuningdek, Fiber tuguni komponent daraxtidagi joylashuvi va yangilanishlarni ustuvorlik asosida bajarishga yordam beradigan metadata bilan ham ta'minlangan. Fiber tuguniga misol Bu yerda Fiber tuguniga oddiy misol berilgan: Ushbu misolda, bizda deb nomlangan ni ifodalovchi Fiber tuguni mavjud. Fiber tuguni komponentning quyidagi ma'lumotlarini o'z ichiga oladi: - tag: Bu yerda qiymatiga ega bo'lib, React uni class komponentligini aniqlash uchun ishlatadi. Har bir komponent turi (class komponentlari, funksiya komponentlari, Suspense va Error boundary, fragmentlar va boshqalar) Fiber sifatida o'ziga xos raqamli ID’ga ega. - type: Bu yerda ushbu Fiber ifodalaydigan funksional yoki class komponentiga ishora qiladi. - props: komponentga berilgan input props’larini yoki funksiya argumentlarini ifodalaydi. - stateNode: Bu Fiber’ni ifodalovchi komponentining nusxasidir. Uning komponent daraxtidagi o'rni: , , va maydonlari Fiber reconciler'ga daraxt bo'ylab \"yurib chiqish\" imkoniyatini beradi, ya'ni ota, bola, birodar va Fiber indeksini aniqlash imkonini beradi. Fiber’lar reconciliation’da Fiber reconciliation esa, hozirgi Fiber daraxtini keyingi Fiber daraxti bilan solishtirib, qaysi tugunlarni yangilash, qo'shish yoki olib tashlash kerakligini aniqlashni o'z ichiga oladi. Reconciliation jarayonida, Fiber reconciler virtual DOM’dagi har bir React elementi uchun Fiber tugun yaratadi. Bu jarayonni deb nomlangan funksiya amalga oshiradi. \"Type va props\"ni boshqacha qilib aytganda, React elementlari deb atash ham mumkin. React elementi quyidagi shaklda bo'ladi: type va props: Ushbu funksiya elementlardan olingan Fiber’ni qaytaradi. Fiber tugunlari yaratilgach, Fiber reconciler _ish sikli(work loop)_ ni ishlatib, foydalanuvchi interfeysini yangilaydi. \"Work loop\" ildiz Fiber tugunidan boshlanib, komponent daraxti bo'ylab pastga qarab harakat qiladi va har bir Fiber tugunni agar yangilanishi kerak bo'lsa, \"ifloslangan\"(dirty) deb belgilaydi. Daraxtning oxiriga yetgach, u qayta yuqoriga ko'tarilib, xotirada brauzerdan ajratilgan yangi DOM daraxtini yaratadi, u oxir-oqibat ekranga chiqariladi(flushed). Bu jarayon ikki funksiya tomonidan amalga oshiriladi: pastga qarab yuradi va komponentlarni \"yangilanishi kerak\" deb belgilaydi, esa qayta yuqoriga ko'tarilib, brauzer bilan bog'lanmagan real DOM elementlar daraxtini yaratadi. Bu ekran tashqarisida bo'ladigan rendering qilish jarayoni istalgan vaqtda to'xtatilishi yoki bekor qilinishi mumkin, chunki foydalanuvchi buni ko'rmaydi. Fiber arxitekturasi o'yin dunyosidagi \"ikki marta buferlash\" (double buffering) deb ataladigan tushunchadan ilhom olgan, bu yerda navbatdagi ekran ekran tashqarisida tayyor bo'ladi va keyin \"flushed\" holatida joriy ekranga chiqariladi. Fiber arxitekturasini yaxshiroq tushunish uchun, bu tushunchani batafsilroq ko'rib chiqamiz.",
    "url": "/books/fluent-react/inside-reconciliation/fiber-reconciler/page",
    "category": "books",
    "tags": [
      "fluent-react",
      "tutorial",
      "guide",
      "react",
      "javascript",
      "frontend",
      "fiber",
      "react",
      "reconciler",
      "lumotlar",
      "deb",
      "bir",
      "komponent",
      "props",
      "funksiya",
      "uchun",
      "lar",
      "rib",
      "esa",
      "daraxtini",
      "bilan"
    ]
  },
  {
    "id": "book-fluent-react-inside-reconciliation-fiber-reconciliation-page",
    "title": "Fiber Reconciliation: React'da Render va Commit Bosqichlari",
    "content": "Fiber reconciliation Fiber reconciliation ikki bosqichda amalga oshiriladi: render(tayyorlash) bosqichi va _commit(o'zgarishlarni tatbiq qilish) bosqichi_. Ushbu ikki bosqichli yondashuv (rasmda ko'rsatilgan) React’ga, DOM’ga qo'shilishdan va foydalanuvchilarga yangi holatni ko'rsatishdan oldin har qanday vaqtda bekor qilinishi mumkin bo'lgan renderlash ishini bajarish imkonini beradi: bu renderlashni to'xtatib qo'yadigan qiladi. Biroz batafsilroq aytadigan bo'lsak, renderlashni to'xtatib qo'yadigan narsa bu React rejalashtiruvchisi(scheduler) tomonidan har 5 msda bajarishni asosiy thread(main thread)ga qaytarishning g'ayrioddiy yondashuvi bo'lib, bu hatto 120 fps (kadr/sekund) tezlikdagi qurilmalarda ham bitta kadrlashdan kichikroqdir. !Fiber reconciler’da reconciliation oqimi Biz kelgusi boblarda React’ning concurrent(bir vaqtda ishlashlik) xususiyatlarini o'rganayotganda scheduler’ning tafsilotlariga chuqurroq kiramiz. Ammo hozircha, reconciliation’ning ushbu bosqichlarini ko'rib chiqamiz. Render bosqichi (render phase) _Render bosqichi_ joriy daraxtda state o'zgarishi hodisasi sodir bo'lganda boshlanadi. React o'zgarishlarni alternativ daraxtda, ekrandan tashqarida, har bir Fiber’ni rekursiv ravishda bosqichma-bosqich ko'rib chiqish va yangilanishlar kutilayotganligini bildiruvchi bayroqlarni o'rnatish orqali amalga oshiradi (rasmga qarang). Yuqorida aytib o'tilganidek, bu jarayon React ichida deb nomlangan funksiyada sodir bo'ladi. !Render bosqichining chaqiruv tartibi hali ish jarayonida bo'lgan(in-progress) daraxtdagi Fiber tugunlarida ular yangilanishi kerakmi yoki yo'qligini bildiruvchi bayroqlarni o'rnatish uchun javobgardir. Bu bir nechta bayroqlarni o'rnatadi va keyin navbatdagi Fiber tugunga o'tib, daraxtning oxiriga yetguncha shu ishni davom ettiradi. Bu tugagandan so'ng, Fiber tugunlarida funksiyasi chaqirila boshlanadi va yuqoriga qarab harakat qilinadi. funksiyasining ko'rinishi quyidagicha: haqida keyinroq batafsil ma'lumot beriladi. Hozircha, funksiyasini ko'rib chiqamiz. Uning ko'rinishida quyidagi argumentlar mavjud: Joriy daraxtdagi hali ish jarayonida bo'lgan tugunga mos keladigan Fiber tuguniga havola. Bu daraxtning avvalgi va yangi versiyasi o'rtasida qanday o'zgarishlar bo'lganligini aniqlash va nimalarni yangilash kerakligini belgilash uchun ishlatiladi. Bu hech qachon o'zgartirilmaydi va faqat taqqoslash uchun ishlatiladi Hali ish jarayonida bo'lgan yangilanayotgan Fiber tuguni. Bu tugun yangilangan taqdirda \"ifloslangan\" deb belgilanadi va funksiya tomonidan qaytariladi. Render lanes(render yo'llari) — bu React’ning Fiber reconciler’ida yangi tushuncha bo'lib, eski ni o'rnini egallaydi. Bu eski tushunchasiga nisbatan biroz murakkabroq, ammo React’ga yangilanishlarni yaxshiroq ustuvorlashtirish va yangilanish jarayonini samaraliroq qilish imkonini beradi. eskirganligi sababli, biz bu bobda ga e'tibor qaratamiz. Render yo'l(lane)lari asosan yangilanishlar ishlov berilayotgan \"yo'l(lane)lar\"ni ifodalovchi bitmask’dir. _Yo'llar_ yangilanishlarni ularning ustuvorligi va boshqa omillar asosida tasniflashning bir usulidir. React komponentida o'zgarish amalga oshirilganda, bu o'zgarish uning ustuvorligi va boshqa xususiyatlariga qarab bir yo'lga tayinlanadi. O'zgarishning ustuvorligi yuqori bo'lsa unga yuqori yo'l, ya'ni _lane_, beriladi. Yangilanishlar to'g'ri tartibda ishlanishini ta'minlash uchun qiymati funksiyasiga uzatiladi. Yuqori ustuvorlikka ega yo'llarga tayinlangan yangilanishlar, past ustuvorlikka ega yo'llarga tayinlangan yangilanishlardan avval ishlov beriladi. Bu, foydalanuvchi bilan interaktivlik yoki foydalanish imkoniyati qulayligi(accessibility) kabi yuqori ustuvorlikdagi yangilanishlarning iloji boricha tezroq ishlov berilishini ta'minlaydi. Yangilanishlarni ustuvorlashtirishdan tashqari, React’ga konkurentlikni, ya'ni bir vatda ishlashni, yaxshiroq boshqarishga ham yordam beradi. React uzun davom etadigan yangilanishlarni kichik, boshqarish oson bo'lgan bo'laklarga ajratish uchun \"vaqtni bo'lish\"(time slicing) deb ataladigan texnikadan foydalanadi. bu jarayonda muhim rol o'ynaydi, chunki bu React’ga qaysi yangilanishlar birinchi bo'lib ishlov berilishi kerakligini va qaysi yangilanishlar keyinroqqa kechiktirilishi mumkinligini aniqlash imkonini beradi. _Render bosqichi_ tugagach, funksiyasi render bosqichida qachondir kechiktirilgan yangilanishlar yaratilganligini aniqlash uchun chaqiriladi. Agar kechiktirilgan yangilanishlar bo'lsa, funksiyasi yangi ish siklini boshlaydi, va dan foydalanib, yangilanishlarni ishlov berish va ularni yo'llariga ko'ra ustuvorlashtirish uchun. Biz _\"Render Lane\"_’lar haqida kelgusi bobda yanada chuqurroq o'rganamiz. Hozircha, Fiber reconciler oqimini davom ettiraylik. funksiyasi hali tugallanmagan bo'lgan Fiber tuguniga yangilanishlarni qo'llaydi va ilovaning yangilangan holatini ifodalovchi yangi real DOM daraxtini yaratadi. Ushbu daraxt brauzer ko'rinishidan tashqarida, DOM bilan bog'lanmagan holda quriladi. Agar asosiy muhit brauzer bo'lsa, bu yoki kabi ishlarni bajarishni anglatadi. Yodda tuting, ushbu elementlar daraxti hali brauzerdagi dokument bilan bog'lanmagan: React shunchaki UI’ning navbatdagi versiyasini ekran tashqarisida yaratmoqda. Bu ishni ekran tashqarisida bajarish uni to'xtatiluvchan qiladi: React hisoblayotgan navbatdagi holat hali ekranga chizilmagan, shuning uchun yuqori ustuvorlikka ega yangilanish rejalashtirilsa, uni bekor qilish mumkin. Bu Fiber reconciler’ning asosiy maqsadi. funksiyasining tuzilishi quyidagicha: Bu yerda, bilan bir xil tuzilish mavjud. funksiyasi funksiyasiga yaqin bo'lib, Fiber tugunidagi “yangilanish kerakmi” holati haqida bayroqlarni o'rnatish uchun javobgar bo'lsa, yangi daraxtni yaratib, uni asosiy host muhitga kiritish uchun javobgardir. yuqoriga yetib, yangi DOM daraxtini yaratgandan so'ng, “render bosqichi tugallandi” deb aytiladi. Endi React commit bosqichiga o'tadi. Commit bosqichi (commit phase) _Commit(tatbiq qilish) bosqichi_ (rasmga qarang) real DOM’ni render bosqichida virtual DOM’ga kiritilgan o'zgarishlar bilan yangilash uchun javobgardir. _Commit bosqichi_ davomida yangi virtual DOM daraxti asosiy host muhitga kiritiladi va hali tugallanmagan daraxt joriy daraxt bilan almashtiriladi. Shu bosqichda barcha effektlar ham bajariladi. _Commit bosqichi_ ikki qismga bo'linadi: _mutatsiya bosqichi_ va _layout bosqichi_. !FiberRootNode bilan commit bosqichi Mutatsiya bosqichi (mutation phase) _Mutatsiya bosqichi_ — bu commit, ya'ni tatbiq qilish, qo'llash, bosqichining birinchi qismi bo'lib, virtual DOM’ga kiritilgan o'zgarishlarni real DOM’ga yangilash uchun javobgardir. Ushbu bosqichda React yangilanishlar kerakligini aniqlaydi va deb nomlangan maxsus funksiyani chaqiradi. Bu funksiya render bosqichida alternativ daraxtdagi Fiber tugunlariga kiritilgan o'zgarishlarni real DOM’ga qo'llaydi. Bu yerda, qanday amalga oshirilishi mumkinligini to'liq psevdokod misolida ko'rsatamiz: _Mutatsiya bosqichi_ davomida React shuningdek, va kabi maxsus funksiyalarni ham chaqiradi, bu funksiyalar DOM’dan endi kerak bo'lmagan tugun(node)larni olib tashlash uchun ishlatiladi. Layout bosqichi (layout phase) _Layout(joylashuv) bosqichi_ — commit bosqichining ikkinchi qismi bo'lib, DOM’dagi yangilangan tugunlarning yangi joylashuvlarini hisoblash uchun mas'uldir. Ushbu bosqichda React deb nomlangan maxsus funksiyani chaqiradi. Bu funksiya DOM’dagi yangilangan tugunlarning yangi joylashuvlarini hisoblab chiqadi. kabi, ham turli tugunlar yangilanishiga qarab har xil funksiyalarni chaqiradigan katta \"switch statement\"ga ega. _Layout bosqichi_ yakunlangandan so'ng, React real DOM’ni render bosqichida virtual DOM’ga kiritilgan o'zgarishlarga mos ravishda muvaffaqiyatli yangilaydi. Commit bosqichini ikki qismga — mutatsiya va layout’larga ajratish orqali React DOM’ga yangilanishlarni samarali tarzda qo'llaydi. Reconciler’dagi boshqa asosiy funksiyalar bilan hamkorlikda ishlash orqali _commit bosqichi_ React ilovalari murakkablashib, katta miqdordagi ma'lumotlarni qayta ishlashiga qaramay, tez, javob beruvchan va ishonchli bo'lishini ta'minlaydi. Effektlar (effects) React’ning reconciliation jarayonining commit bosqichida \"side effect\"lar o'ziga xos tartibda, effektning turiga qarab bajariladi. Commit bosqichida sodir bo'lishi mumkin bo'lgan bir nechta effektlar mavjud: - Joylashtirish effektlari (Placement effects): Bu effektlar yangi komponent DOM’ga qo'shilganda yuz beradi. Masalan, agar forma ichiga yangi tugma(button) qo'shilsa, tugmani DOM’ga qo'shish uchun ushbu joylashtirish effekti sodir bo'ladi. - Yangilash effektlari (Update effects): Bu effektlar komponent yangi props yoki state bilan yangilanganda yuz beradi. Masalan, agar tugmaning teksti o'zgarsa, tekstni DOM’da yangilash uchun yangilash effekti sodir bo'ladi. - O'chirish effektlari (Deletion effects): Bu effektlar komponent DOM’dan o'chirilganda yuz beradi. Masalan, agar forma ichidagi tugma olib tashlansa, tugmani DOM’dan olib tashlash uchun o'chirish effekti sodir bo'ladi. - Layout(joylashuv) effektlari (Layout effects): Bu effektlar brauzer ekranga chizish imkoniyatiga ega bo'lmasdan oldin sodir bo'ladi va sahifaning joylashuvi, ya'ni layout’ini, yangilash uchun ishlatiladi. Layout effektlari funksional komponentlarda hook’i va class komponentlarda lifecycle metodi orqali boshqariladi. Commit bosqichidagi ushbu effektlardan farqli o'laroq, passiv effektlar ham mavjud. Passiv effektlar — bu foydalanuvchi tomonidan belgilanadigan effektlar bo'lib, brauzer ekranga chizish imkoniyatiga ega bo'lgandan keyin bajariladi. Passiv effektlar hook'i orqali boshqariladi. Passiv effektlar sahifaning dastlabki chizilishida muhim bo'lmagan harakatlarni amalga oshirish uchun foydalidir, masalan, API’dan ma'lumot olish yoki analitika kuzatuvini amalga oshirish. Passiv effektlar render bosqichida bajarilmaganligi sababli, foydalanuvchi interfeysini dasturchi istagan holatga olib kelish uchun minimal yangilanishlar to'plamini hisoblash vaqtiga ta'sir qilmaydi. Hamma narsani ekranga chiqarish React ikkita daraxtdan biriga ishora qiluvchi deb nomlangan yuqori darajadagi tugunni boshqaradi: bu yoki daraxtlari bo'lishi mumkin. — reconciliation jarayonining commit bosqichini boshqarish uchun javob beradigan muhim ma'lumotlar strukturasi hisoblanadi. Virtual DOM’ga o'zgarishlar kiritilganda, React daraxtini yangilaydi, lekin daraxtini o'zgarishsiz qoldiradi. Bu React’ga virtual DOM’ni render qilish va yangilashni davom ettirish imkonini beradi, shu bilan birga dastur holatining hozirgi holatini saqlaydi. Render jarayoni tugagach, React deb nomlangan funksiyani chaqiradi, bu funksiya daraxtida amalga oshirilgan o'zgarishlarni real DOM’ga kiritish uchun javobgardir. funksiyasi ko'rsatkich ishorasi(pointer)ni joriy daraxtdan daraxtiga o'zgartiradi, natijada daraxti yangi joriy daraxt bo'lib qoladi. Shundan so'ng, kelgusidagi barcha yangilanishlar yangi joriy daraxtga asoslanadi. Bu jarayon dastur holatining izchil qolishini va o'zgarishlarning to'g'ri va samarali tarzda qo'llanilishini ta'minlaydi. Bularning barchasi brauzerda deyarli darhol sodir bo'lgandek tuyuladi. Bu — \"reconciliation jarayoni\"ning natijasidir.",
    "url": "/books/fluent-react/inside-reconciliation/fiber-reconciliation/page",
    "category": "books",
    "tags": [
      "fluent-react",
      "tutorial",
      "guide",
      "react",
      "javascript",
      "frontend",
      "react",
      "dom",
      "uchun",
      "render",
      "fiber",
      "yangi",
      "bosqichi_",
      "effektlar",
      "commit",
      "yangilanishlar",
      "bilan",
      "reconciliation",
      "ushbu",
      "beradi",
      "lib"
    ]
  },
  {
    "id": "book-fluent-react-inside-reconciliation-page",
    "title": "Reconciliation Ichki Mexanizmi: React Qanday Ishlaydi?",
    "content": "Reconciliation’ning ichki ishlash mexanizmi React'ni to'liq tushunish uchun uning funksiyalari nima ish qilishini bilishimiz kerak. Shu vaqtgacha biz JSX va haqida tushunchaga ega bo'ldik. Shuningdek, virtual DOM haqida ham ma'lum darajada batafsil tushundik. Endi, ushbu bobda uning React’da amaliy qo'llanilishlarini o'rganamiz va nima ish qilishini tushunib olamiz. Aniqroq aytganda, biz React virtual DOM’ni qanday qurishi va real DOM’ni yangilashi jarayonini, ya'ni reconciliation (moslashtirish) deb ataladigan jarayonni o'rganamiz.",
    "url": "/books/fluent-react/inside-reconciliation/page",
    "category": "books",
    "tags": [
      "fluent-react",
      "tutorial",
      "guide",
      "react",
      "javascript",
      "frontend",
      "react",
      "reconciliation",
      "dom",
      "ichki",
      "mexanizmi",
      "uning",
      "nima",
      "ish",
      "qilishini",
      "biz",
      "haqida",
      "virtual",
      "rganamiz",
      "qanday",
      "ning"
    ]
  },
  {
    "id": "book-fluent-react-inside-reconciliation-recap-page",
    "title": "React Reconciliation Xulosasi: Fiber, Render va Commit Bosqichlari",
    "content": "Bo'limni qisqacha takrorlash Ushbu bobda biz React’dagi reconciliation tushunchasini o'rgandik va Fiber reconciler haqida ma'lumot oldik. Yana biz, Fiber’lar haqida ham o'rgandik, ular kuchli rejalashtiruvchi(scheduler) bilan birgalikda samarali va to'xtatiluvchan(interruptible) qilinishi mumkin bo'lgan render qilish imkoniyatini taqdim etadi. Shuningdek, reconciliation jarayonining ikki asosiy bosqichi — render bosqichi va commit bosqichi haqida ma'lumot oldik. Nihoyat, reconciliation jarayonining commit bosqichini boshqarishga javobgar bo'lgan asosiy ma'lumotlar strukturasi bo'lmish — haqida o'rgandik. Takrorlash uchun savollar Quyidagi savollarga javob berib, ushbu bobdagi tushunchalarimizni sinab ko'ramiz: 1. _React reconciliation nima?_ 2. _Fiber ma'lumotlar strukturasining roli qanday?_ 3. _Nima uchun bizga ikkita daraxt kerak?_ 4. _Dastur yangilanganda nima sodir bo'ladi?_ Agar ushbu savollarga javob bera olsak, React’dagi Fiber reconciler va reconciliation jarayonini tushunishda yaxshi yo'ldamiz. Keyingi bo'lim 5-bobda biz React’dagi keng tarqalgan va ko'p duch kelinadigan savollarni ko'rib chiqamiz va ba'zi takomillashgan pattern’larni o'rganamiz. ni qanchalik va qaysi holatlarda ishlatish kerakligi va dan qachon foydalanish haqida savollarga javob beramiz. Shuningdek, va yordamida React ilovalarida state’ni boshqarishni o'rganamiz.",
    "url": "/books/fluent-react/inside-reconciliation/recap/page",
    "category": "books",
    "tags": [
      "fluent-react",
      "tutorial",
      "guide",
      "react",
      "javascript",
      "frontend",
      "reconciliation",
      "react",
      "haqida",
      "fiber",
      "ushbu",
      "biz",
      "dagi",
      "rgandik",
      "render",
      "bosqichi",
      "commit",
      "savollarga",
      "javob",
      "takrorlash",
      "bobda"
    ]
  },
  {
    "id": "book-fluent-react-inside-reconciliation-stack-reconciler-page",
    "title": "React'ning Eskirgan Stack Reconciler'i va uning Muammolari",
    "content": "Stack Reconciler (eskirgan) Ilgari, React rendering uchun stack(stek) ma'lumotlar strukturasi(data structure)dan foydalangan. Biz bir xil tushunchani tasavvur qilayotganimizga ishonch hosil qilish uchun, stack ma'lumotlar strukturasini qisqacha muhokama qilamiz Stack o'zi nima Computer science’da stack — bu oxirgi kirgan birinchi chiqadi (LIFO) tamoyiliga amal qiladigan chiziqli ma'lumotlar strukturasi(linear data structure). Bu shuni anglatadiki, stack’ga qo'shilgan oxirgi element birinchi bo'lib olib tashlanadi. Stack’da ikkita asosiy amal mavjud: push va pop, ular orqali elementlarni mos ravishda stack’ning yuqori qismiga qo'shish va undan olib tashlash mumkin. Stack’ni vertikal joylashtirilgan elementlar to'plami sifatida tasavvur qilish mumkin, bunda eng yuqori element eng oxirgi qo'shilgan element hisoblanadi. Bu yerda stack’ning uchta elementi bilan ASCII illyustratsiyasini ko'rishingiz mumkin: pop va push amali Ushbu misolda, eng oxirgi qo'shilgan element — , stack’ning yuqorisida joylashgan. Birinchi qo'shilgan element — esa stack’ning pastki qismida joylashgan. Ushbu stack’da push amali elementni stack’ning yuqorisiga qo'shadi. Kodda bu JavaScript’da array va metodidan foydalanib bajarilishi mumkin, quyidagicha: Pop amali esa stackning yuqori elementini olib tashlaydi. Kodda bu JavaScript’da array va metodidan foydalanib bajarilishi mumkin, quyidagicha: Ushbu misolda, pop metodi stack’ning yuqori elementini (3) olib tashlaydi va uni qaytaradi. Stack massivi hozirda qolgan elementlarni (1 va 2) o'z ichiga oladi. React’da stack reconciler va uning muammolari React’ning dastlabki \"reconciler\" algoritmi stack asosida ishlaydigan algoritm bo'lib, u eski va yangi virtual daraxtlarni taqqoslash hamda DOM’ni tegishli ravishda yangilash uchun ishlatilgan. \"Stack reconciler\" oddiy holatlarda yaxshi ishlagan bo'lsa-da, ilovalar o'lchami va murakkabligi ortishi bilan bir qator qiyinchiliklarni keltirib chiqardi. Form misoli Keling, nega bu holat yuz berganini tezkorlik bilan ko'rib chiqamiz. Buning uchun quyidagi misolni ko'rib chiqamiz, bunda bizda yangilanishlar ro'yxati bor: 1. Keraksiz va hisoblash jihatdan og'ir komponent CPU’ni ishlatadi va render qilinadi. 2. Foydalanuvchi elementiga ma'lumot yozadi. 3. Agar kiritilgan ma'lumot yaroqli(valid) bo'lsa, yoqiladi. 4. Ichida bo'lgan komponenti state’ni saqlaydi, shuning uchun u qayta render qilinadi. Kodda biz buni quyidagicha ifodalaymiz: Misoldan kelib chiqadigan muammolar Bu holda, stack reconciler’i bo'lganda ketma-ket ravishda yangilanishlarni render qilardi, ishni to'xtatish yoki kechiktirish imkoni bo'lmasdi. Agar hisoblash jihatdan og'ir komponent renderlashni blok qilsa, foydalanuvchi da kiritgan ma'lumotlar ekranda kechikish bilan paydo bo'ladi. Bu yomon foydalanuvchi bilan ishlash qulayligiga olib keladi, chunki tekst maydoni javobsiz bo'lib qoladi. Aksincha, agar hisoblash jihatdan og'ir komponentni render qilishini kechiktirgan holda va ushbu og'ir komponentni render qilishdan ko'ra, foydalanuvchi kiritishini yuqoriroq ustuvorlikka ega yangilanish sifatida tan olish va ekranni yangilash, ko'proq qulay bo'lar edi. Stack reconciler’dan kelib chiqadigan muammolar Mavjud renderlash ishidan voz kechish zarurati bor edi, agar u yuqori ustuvorlikdagi renderlash ishi, masalan, foydalanuvchi kiritishi bilan to'xtatilsa. Buning uchun React ba'zi renderlash operatsiyalari boshqa operatsiyalardan ustunroq bo'lgan ustuvorlikka ega bo'lishi kerak edi. Yangilanishlarni ustuvorlikka(priority) ajratmasligi Stack reconciler yangilanishlarni ustuvorlikka ajratmagan, bu esa kamroq ahamiyatga ega bo'lgan yangilanishlar ko'proq ahamiyatga ega bo'lgan yangilanishlarni blok qilib qo'yishi mumkinligini anglatardi. Masalan, past ustuvorlikdagi \"tooltip\" yangilanishi yuqori ustuvorlikdagi matn kiritish yangilanishini to'sib qo'yishi mumkin edi. Virtual daraxtdagi yangilanishlar stack’da qanday qabul qilingan bo'lsa, shunday tartibda amalga oshirilar edi. React ilovasida virtual daraxtdagi yangilanishlar turli darajadagi ahamiyatlarga ega bo'lishi mumkin. Masalan, formaga input’dagi yangilanish, foydalanuvchi to'g'ridan-to'g'ri input bilan o'zaro aloqada bo'lib, uning javob berishini kutayotgani uchun, postdagi \"like\"lar sonini ko'rsatadigan indikator yangilanishidan ko'ra muhimroq bo'lishi mumkin. Stack’da tartib bo'yicha yangilanishi Stack reconciler’da yangilanishlar qabul qilingan tartibda bajarilar edi, bu kamroq ahamiyatga ega yangilanishlar ko'proq ahamiyatga ega yangilanishlarni blok qilishi mumkinligini anglatardi. Masalan, agar input yangilanishidan oldin \"like\"lar sonini hisoblash yangilanishi qabul qilinsa, \"like\"lar sonini hisoblash yangilanishi birinchi bo'lib bajariladi va form input yangilanishini blok qilishi mumkin. Agar \"like\"lar sonini hisoblash yangilanishi uzoq vaqt talab qilsa (masalan, og'ir hisoblash ishlari tufayli), bu foydalanuvchi interfeysida sezilarli kechikish yoki buzilish(jank)ga olib kelishi mumkin, ayniqsa foydalanuvchi yangilanish davomida ilova bilan o'zaro aloqada bo'lsa. Yangilanishni to'xtatish yoki bekor qila olmasligi Stack reconciler’dagi yana bir muammo shundaki, yangilanishlarni to'xtatish yoki bekor qilish mumkin emas edi. Bu shuni anglatadiki, hatto stack reconciler yangilanish ustuvorligini bilsa ham, u yuqori ustuvorlikdagi yangilanish rejalashtirilganda ahamiyatsiz ishni to'xtatish orqali turli ustuvorliklar bilan yaxshi ishlashiga kafolat yo'q edi. Har qanday veb-ilovada barcha yangilanishlar teng darajada muhim emas: tasodifiy kutilmagan bildirishnoma chiqishi tugmani bosilishiga javobichalik muhim emas, chunki tugmani bosishni foydalanuvchi xohlab qiladi, va bu darhol javob berishni talab qiladi, holbuki bildirishnoma esa hatto kutilmagan va istalmagan bo'lishi mumkin. Stack reconciler’da yangilanishlarni to'xtatish yoki bekor qilish mumkin emas edi, bu shuni anglatadiki, keraksiz yangilanishlar, masalan \"toast\" ko'rsatish kabi, ba’zan foydalanuvchining interaktivligi evaziga amalga oshirilgan. Bu virtual daraxt va DOM’da keraksiz ishlar bajarilishiga olib kelishi mumkin edi, bu esa ilovaning performance’iga salbiy ta'sir ko'rsatardi. Stack reconciler ilovalar kattalashgani va murakkablashgani sari ko'plab qiyinchiliklarni yuzaga keltirdi. Asosiy qiyinchiliklar interfeysning kechikishi va foydalanuvchi interfeyslarining sekin javob berishi bilan bog'liq edi. Bu qiyinchiliklarni bartaraf etish uchun React jamoasi boshqa ma'lumotlar strukturasiga asoslangan \"Fiber reconciler\" deb nomlanuvchi yangi reconciler ishlab chiqdilar. Keyingi bo'limda ushbu ma'lumotlar strukturasini o'rganamiz.",
    "url": "/books/fluent-react/inside-reconciliation/stack-reconciler/page",
    "category": "books",
    "tags": [
      "fluent-react",
      "tutorial",
      "guide",
      "react",
      "javascript",
      "frontend",
      "stack",
      "reconciler",
      "mumkin",
      "edi",
      "bilan",
      "foydalanuvchi",
      "uchun",
      "ning",
      "yangilanishlar",
      "react",
      "olib",
      "yuqori",
      "hisoblash",
      "yangilanishlarni",
      "ega"
    ]
  },
  {
    "id": "book-fluent-react-inside-reconciliation-understanding-reconciliation-page",
    "title": "React Reconciliation Jarayoni: Virtual DOM'dan Haqiqiy DOM'gacha",
    "content": "Reconciliation’ni yaxshiroq tushunish Tezda ko'z yugurtirib chiqadigan bo'lsak, React’ning virtual DOM’i bizning kerakli UI holatimizning chizmasidir. React bu chizma yordamida, _reconciliation(moslashtirish)_ deb ataladigan jarayon orqali, uni berilgan muhitda; odatda veb-brauzerda, lekin boshqa muhitlarda, masalan, terminal, iOS va Android kabi native platformalarda ham amalga oshiradi. Quyidagi kodni ko'rib chiqamiz: Ushbu kod qismi UI holatini qanday bo'lishini deklarativ tavsifini o'z ichiga oladi: elementlar daraxti. Bizning hamkasblarimiz va React bu kodni o'qib, biz hisoblagich(counter) ilovasini yaratmoqchi ekanligimizni tushunishlari mumkin. Reconciliation’ni yaxshiroq tushunish uchun, bunday komponentga duch kelganda React ichida nimalar sodir bo'lishini tushunishimiz kerak. Birinchidan, JSX React elementlari daraxtiga aylanadi. Bu biz Virtual Dom bobida ko'rgan narsalarimizdir. Ushbu component chaqirilganda, komponenti o'z bolalari yana boshqa React elementlari bo'lgan React elementini qaytaradi. React elementlari o'zgarmasdir(biz uchun) va UI’ning kerakli holatini ifodalaydi. Ular haqiqiy UI holati emas. React elementlari yoki JSX belgisi orqali yaratiladi, shuning uchun bu quyidagi ko'rinishga transpilatsiya qilinadi: Bu bizga ushbu tarzda yaratilgan React elementlari daraxtini quyidagicha beradi: Ushbu kod qismi bizning komponentimizdan keladigan virtual DOM’ni ifodalaydi. Bu birinchi render bo'lgani uchun, ushbu daraxt endi imperativ DOM API'lariga minimal darajada chaqiruvlar yordamida brauzerga yuklanadi. React imperativ DOM API’lariga minimal chaqiruvlar qilishni qanday ta'minlaydi? Bu vDOM yangilanishlarini bitta real DOM yangilanishiga to'plash(batching) orqali amalga oshiriladi va oldingi boblarda muhokama qilingan sabablarga ko'ra DOM’ga iloji boricha kamroq tegadi. Buni tushunish uchun, biz buni yanada chuqurroq ko'rib chiqamiz va batching’ni to'liq tushunamiz.",
    "url": "/books/fluent-react/inside-reconciliation/understanding-reconciliation/page",
    "category": "books",
    "tags": [
      "fluent-react",
      "tutorial",
      "guide",
      "react",
      "javascript",
      "frontend",
      "react",
      "dom",
      "ushbu",
      "uchun",
      "elementlari",
      "virtual",
      "biz",
      "reconciliation",
      "tushunish",
      "bizning",
      "orqali",
      "yaxshiroq",
      "ning",
      "kerakli",
      "yordamida"
    ]
  },
  {
    "id": "book-fluent-react-jsx-extending-javascript-syntax-with-jsx-page",
    "title": "JSX Qanday Ishlaydi? Transpilyatsiya Jarayoni Tahlili",
    "content": "JavaScript sintaksisini JSX bilan kengaytirish Endi biz JavaScript sintaksisini qanday kengaytirishni tushunganimizdan so'ng, JSX qanday ishlashini ko'rib chiqamiz. JSX qanday ishlaydi? Biz buni qanday amalga oshiramiz? JavaScript sintaksisini kengaytirish uchun, bizga yangi sintaksisimizni tushunadigan boshqa dvigatel kerak bo'ladi yoki bu sintaksisni dvigatelga yetib bormasdan oldin ishlov berishimiz kerak bo'ladi. JSX’ni kengaytirish uchun variantlar tahlili Birinchi variantni amalga oshirish deyarli imkonsiz, chunki dvigatellarni yaratish va ularni davom ettirish juda keng miqyosda o'ylashni talab qiladi, chunki ular keng qo'llaniladi. Agar biz shu variantni tanlasak, kengaytirilgan sintaksisimizdan foydalanish uchun bir necha yillar, xattoki o'nlab yillar kerak bo'ladi! Shunda biz o'zimizning \"o'ziga xos maxsus dvigatelimiz\" hamma joyda ishlatilishini ta'minlashimiz kerak bo'ladi. Brauzer ishlab chiqaruvchilarini va boshqa manfaatdor tomonlarni bizning mashhurligi past bo'lgan \"yangi narsamiz\"ga o'tishga qanday ko'ndirardik? Bu ish bermas edi. Ikkinchi variant tezroq: yangi sintaksisimizni dvigatelga yetib bormasdan oldin qanday ishlov berishni o'rganamiz. Buning uchun biz o'z lexer va parser’imizni yaratishimiz kerak bo'ladi, u kengaytirilgan tilimizni tushunadi, ya'ni kodning tekst satrini olib, uni tushunib chiqadi. So'ngra, an'anaviy tarzda mashina kodini yaratish o'rniga, biz bu sintaksis daraxtidan foydalanib, uni hozirgi dvigatellar tushunadigan oddiy JavaScript’ga aylantirishimiz mumkin. JavaScript ekotizimida Babel va boshqa TypeScript, Traceur va swc kabi vositalar aynan shunday qiladi (rasmga qarang). !JSX dvigatelini yaratish va JS preprotsessori bilan ishlash Transpilyatsiya jarayoni Shuning uchun JSX brauzerda to'g'ridan-to'g'ri ishlatilmaydi, balki “build step”ni talab qiladi, bu yerda maxsus parser uni sintaksis daraxtiga kompilyatsiya qiladi. Bu kod so'ngra oddiy JavaScript’ga aylantiriladi va oxirgi distributsiya qilinadigan to'plam paketi(bundle)ga aylantiriladi. Bu jarayon _transpilyatsiya_ deb ataladi: kod o'zgartiriladi va so'ng kompilyatsiya qilinadi. Aniq qilib aytganda, transpilyatsiya bir tilda yozilgan manba kodini shunga o'xshash abstraksiya darajasiga ega boshqa tilda o'zgartirish jarayonidir. Shuning uchun bu atama _manbadan-manbaga kompilyatsiya (source-to-source compilation)_ deb ham ataladi. Rasmiy nuqtai nazardan, bu tarjimonning bir turi hisoblanadi. Bu umumiy atama _kompilyator_, _assembler_ yoki _interpretator’ni_ anglatishi mumkin. Kontseptual jihatdan bu kompilyatsiyaga juda o'xshash, faqat maqsad qilingan tili manba tiliga o'xshash abstraksiya darajasiga ega bo'ladi. Masalan, TypeScript yuqori darajadagi tildir, u transpilyatsiya qilinganda JavaScript’ga (yana bir yuqori darajadagi til) aylantiriladi. Babel’ning ES6 JavaScript kodini ES5 JavaScript’ga transpilyatsiya qilish jarayoni yana bir misoldir. Endi biz JavaScript’ning o'z kengaytirilgan versiyasini qanday yaratishni tushunganimizdan so'ng, JSX bilan nimalar qilishimiz mumkinligini ko'rib chiqamiz.",
    "url": "/books/fluent-react/jsx/extending-javascript-syntax-with-jsx/page",
    "category": "books",
    "tags": [
      "fluent-react",
      "tutorial",
      "guide",
      "react",
      "javascript",
      "frontend",
      "javascript",
      "jsx",
      "qanday",
      "biz",
      "uchun",
      "ladi",
      "kerak",
      "bir",
      "transpilyatsiya",
      "boshqa",
      "qiladi",
      "sintaksisini",
      "bilan",
      "kengaytirish",
      "yangi"
    ]
  },
  {
    "id": "book-fluent-react-jsx-javascript-xml-page",
    "title": "JSX Nima? JavaScript Sintaksis Kengaytmasi Tahlili",
    "content": "JSX - bu JavaScript XML(mi)? Agar siz veb-dunyosida uzoq vaqtdan beri bo'lsangiz, AJAX atamasini eslashingiz mumkin. AJAX (_Asynchronous JavaScript and XML_) 2000-yillarda interaktiv veb-sahifalarni yaratish uchun ishlatilgan texnologiyalarning yangi atamasi edi. Ushbu texnologiyalar yordamida sahifa holati o'zgarganda butun sahifani qayta yuklash o'rniga, sahifa asinxron tarzda yangilanardi. kabi vositalar yordamida brauzerda asinxron (ya'ni, bloklanmaydigan) HTTP (HyperText Transfer Protocol) so'rovi yuborilar edi. Ushbu so'rovning javobi odatda XML formatida bo'lar edi. Bugungi kunda biz ko'proq JSON (JavaScript Object Notation) formatida javob olamiz, shuning uchun metodi dan ustun keldi, chunki da XML so'zi bor. JSX’ning ishlatilishi JSX — bu JavaScript uchun sintaksis kengaytmasi bo'lib, dasturchilarga JavaScript kodining ichida HTML’ga o'xshash kod yozish imkonini beradi. Dastlab Meta (avvalgi Facebook) tomonidan React bilan birga ishlatish uchun ishlab chiqilgan, ammo keyinchalik boshqa kutubxonalar va freymvorklar ham uni qabul qila boshladi. JSX o'zi alohida til emas, aksincha kompilyator yoki transpilyator yordamida oddiy JavaScript kodiga aylantiriladigan sintaksis kengaytmasi hisoblanadi. JSX kodini kompilyatsiya qilganda, u oddiy JavaScript kodiga aylanadi. Bu jarayonga keyinroq batafsil to'xtalamiz. JSX sintaksisi HTML’ga o'xshash bo'lsa-da, ayrim farqlar mavjud. Masalan, JSX’da HTML’ga o'xshash kod ichida JavaScript ifodalarini jingalak qavslar yordamida joylashtirish mumkin. Bundan tashqari, JSX atributlari _camelCase_ formatida yoziladi, HTML’da esa atributlar kichik harflarda yoziladi: masalan, HTML’da JSX’da esa bo'ladi. HTML elementlari kichik harflarda yoziladi, JSX’dagi komponentlar esa katta harflarda boshlanadi: masalan, bu HTML elementi, lekin esa React komponentidir. JSX bilan va JSX’siz komponent yozish Bundan tashqari, React ilovalarini JSX’siz yaratish ham mumkin, lekin kodni o'qish, tushunish va uni maintain qilish qiyinlashadi. Shunga qaramay, agar xohlasangiz, JSX’siz ham yozish mumkin. Keling, JSX bilan yozilgan va JSX’siz yozilgan React komponentlarini ko'rib chiqamiz. Bu yerda JSX bilan ishlatilinishiga misol: Bu esa JSX’siz ishlatilinishiga misol: Tushunarli bo'lishi uchun, biz bu yerda yuqoridagi JSX transformatsiyasini ishlatdik, ya'ni JSX kodni qanday qilib oddiy JavaScript’ga aylantirishini ko'rsatish uchun eski usulda yozdik. Ushbu transformatsiya jarayonlarini keyinroq batafsilroq o'rganamiz, lekin hozircha A sintaksisni B sintaksisga o'zgartirish jarayonini transformatsiya deb atashimizni bilib olamiz. Yangi JSX transformatsiyasi Bugungi kunda React 17 versiyasida joriy qilingan yangi JSX transformatsiyasi bilan, u xuddi shu ishni bajarish uchun ba'zi maxsus funksiyalarni avtomatik ravishda import qiladi. Bu katta sxemadagi narsalardan kichik bir tafsilot xolos, ammo yangi transformator bilan biz JSX’siz ro'yxatni quyidagicha ifodalaymiz: Bu holda ham JSX va JSX’siz yozilgan kodlarning farqini ko'ryapsizmi? JSX bilan yozilgan birinchi misol ancha tushunarli va o'qish oson, JSX’siz yozilgan kod esa murakkabroq va ancha uzun bo'lib ketadi. JSX yordamida yozilgan kod o'qilishi osonroq va uni maintain qilish qulayroq. Keling, bu usullarning afzallik va kamchiliklarini ko'rib chiqamiz. JSX’ning afzalliklari Veb dasturlashda JSX’dan foydalanishning bir necha afzalliklari mavjud: - O'qish va yozish qulayligi: HTML bilan tanish bo'lgan dasturchilar uchun JSX sintaksisini o'qish va yozish ancha oson. - Yaxshilangan xavfsizlik: JSX kodi xavfsiz JavaScript kodiga kompilyatsiya qilinadi, bu esa HTML satrlarida xavfli belgilar sanaladigan belgilardan tozalaydi (masalan va dan). Bu belgilar yangi elementlar yaratishi mumkin, ammo bu jarayonda bunday HTML satrlari ushbu belgilar o'rniga shunchaki kichikroq(less-than) va kattaroq(greater-than) belgilarga almashtiriladi. Bu jarayon _sanitizatsiya(sanitization)_ deb ataladi. - Kuchli tiplash: JSX kuchli tiplash imkoniyatini beradi, bu esa xatolarni sodir bo'lishidan oldin aniqlashga yordam beradi. JSX’ni TypeScript bilan ifodalash mumkin, ammo TypeScript’dan foydalanilmasa ham, JSDoc-style’dagi sharhlar va dan foydalanish orqali yaxshilangan tip xavfsizligidan foydalanish mumkin. - Komponentga asoslangan arxitekturani rag'batlantirish: JSX komponentga asoslangan arxitekturani rag'batlantiradi, bu esa kodni yanada modulli va uni maintain qilishni qulaylashtiradi. - Keng qo'llanilish: JSX React hamjamiyati tomonidan keng qo'llaniladi va boshqa kutubxonalar va freymvorklar tomonidan ham qo'llab-quvvatlanadi. JSXning kamchiliklari JSX’dan foydalanishning ba'zi kamchiliklari ham mavjud: - O'rganish qiyinchiligi: JSX bilan tanish bo'lmagan dasturchilarga uni o'rganish qiyinroq bo'lishi mumkin. - Qo'shimcha vositalarni talab qiladi: JSX kodi oddiy JavaScript kodiga kompilyatsiya qilinishi kerak, bu esa development jarayoniga qo'shimcha bosqich qo'shadi. Masalan, Vue.js kabi boshqa alternativlar oddiygina tegini sahifaga qo'shish orqali brauzerda darhol ishlay oladi. - Ma'suliyatlarning aralashib ketishi(Mixing of concerns): Ba'zi dasturchilar JSX HTML’ga o'xshash kodni JavaScript bilan birlashtirgani uchun HTML va JavaScript’dagi ayrim ma'suliyatlar aralashib ketishini aytishadi, bu esa UI va logikani ajratishni qiyinlashtirishi mumkin. - JavaScript bilan to'liq mos kelmaslik: JSX inline ifoda(expression)larni qo'llab-quvvatlaydi, lekin inline bloklarni emas. Ya'ni, JSX elementlari daraxti ichida biz inline ifodalarni qo'sha olamiz, lekin yoki bloklarini emas. Bu JSX bilan endigina ishlay boshlagan dasturchilar uchun tushunish biroz murakkabroq bo'lishi mumkin. JSX’ning ommalashishi va keng qo'llanilishi JSX’ning kamchiliklariga qaramasdan, u veb-dasturchilar, ayniqsa React bilan ishlayotganlar orasida mashhur tanlovga aylandi. JSX komponentlar yaratish va foydalanuvchi interfeyslarini qurishning kuchli va moslashuvchan usulini taklif qiladi. Bundan tashqari, JSX katta va faol hamjamiyat tomonidan qo'llab-quvvatlanadi. JSX faqat React’da ishlatilish bilan cheklanib qolmay, Vue.js, Solid, Qwik va boshqa kutubxonalar va freymvorklar tomonidan ham qabul qilindi. Bu JSX’ning faqat React va veb-ekotizimi bilan bog'liq emasligini va kelajakda uning ommalashishi davom etishini ko'rsatadi. JSX hatto iOS’da SwiftUI kabi boshqa tizimlarga ham o'z ta'sirini o'tkazmoqda. Umuman olganda, JSX kuchli va moslashuvchan vosita bo'lib, dinamik va responsiv foydalanuvchi interfeyslarini yaratishda yordam beradi. JSX bir maqsadda yaratilgan: React komponentlari uchun kodni yozish, ifodalash va maintain qilishni oddiylashtirish va shu bilan birga iteratsiya, hisoblash va inline bajarish imkoniyatlarini saqlab qolish. JSX brauzerda ishlashidan oldin oddiy JavaScript’ga aylanadi. Bu qanday amalga oshadi? Endi bu ichki ishlash jarayoni mexanizmini chuqurroq ko'rib chiqamiz!",
    "url": "/books/fluent-react/jsx/javascript-xml/page",
    "category": "books",
    "tags": [
      "fluent-react",
      "tutorial",
      "guide",
      "react",
      "javascript",
      "frontend",
      "jsx",
      "bilan",
      "javascript",
      "html",
      "uchun",
      "esa",
      "mumkin",
      "react",
      "siz",
      "ham",
      "dan",
      "yozish",
      "yozilgan",
      "veb",
      "yangi"
    ]
  },
  {
    "id": "book-fluent-react-jsx-jsx-expressions-page",
    "title": "JSX Ifodalari (Expressions): JSX Ichida JavaScript Ishlatish",
    "content": "JSX ifodalari (Expressions) JSX’ning eng kuchli xususiyatlaridan biri bu elementlar daraxti ichida kodni bajarish imkoniyatidir. JSX’ning ichki mexanizmi bobida aytib o'tganimizdek, ro'yxat bo'ylab iteratsiya qilish uchun metodi bilan, jingalak qavslar ichiga bajariladigan kodni qo'yishimiz mumkin. Agar JSX’da ikki sonning yig'indisini ko'rsatmoqchi bo'lsak, buni quyidagicha qilamiz: Sodda JSX ifodasi Bu kod natijasini chiqaradi, chunki jingalak qavslar ichidagi narsa ifoda(expression) sifatida bajariladi. JSX ifodalari yordamida biz ro'yxatlar bo'ylab iteratsiya qilishimiz va ternary amallar, satrni almashtirish va boshqalarni qo'llagan holda turli ifodalarni bajarishimiz mumkin. Ternary operatori bilan JSX ifodasi Mana bu yerda, ternary operatori bilan shartni tekshirish misoli: Bu kod natijasini chiqaradi, chunki bu solishtirish ifoda sifatida bajariladi. Shu yerda ta'kidlash joizki, JSX ifodalari aniq shunday — ifodalardir. JSX elementlari daraxti ichida bayonot(statement)larni bajarish mumkin emas. Quyidagi kod ishlamaydi: U ishlamaydi, chunki bayonotlar hech narsa qaytarmaydi va ular side effect’lar deb hisoblanadi: ular holatni o'zgartiradi, lekin hech qanday qiymat bermaydi. Bayonotlar va hisoblashlardan keyin qanday qilib qiymatni satr ichida chop qilish mumkin? 6-qatorda biz shunchaki raqamini joylashtirdik. Renderlovchi biz raqamini chop qilishni mo'ljallaganimizni qanday bilishi kerak? Shuning uchun ifodalar bajariladi, ammo bayonotlar bajarilmaydi.",
    "url": "/books/fluent-react/jsx/jsx-expressions/page",
    "category": "books",
    "tags": [
      "fluent-react",
      "tutorial",
      "guide",
      "react",
      "javascript",
      "frontend",
      "jsx",
      "ifodalari",
      "ichida",
      "mumkin",
      "bilan",
      "kod",
      "chunki",
      "bajariladi",
      "biz",
      "ternary",
      "bayonotlar",
      "qanday",
      "expressions",
      "ning",
      "daraxti"
    ]
  },
  {
    "id": "book-fluent-react-jsx-jsx-pragma-page",
    "title": "JSX Pragma: JSX Sintaksisining Funksiya Chaqiruviga Aylanishi",
    "content": "JSX Pragma Hamma narsa bilan boshlanadi, bu o'z-o'zidan JavaScript’da taqqoslash amallaridan tashqarida ishlatilganda tanib bo'lmaydigan belgi hisoblanadi. JavaScript dvigateli bunga duch kelganda, xatosini chiqaradi. JSX'da esa bu \"JSX pragma\" funksiya chaqiruviga transpilyatsiya qilinadi. Pragma ma'nosi Pragma - kompilyatorga qo'shimcha ma'lumot berish uchun qo'llaniladigan kompilyator direktivasi bo'lib, odatda tilning o'zida ifodalangan narsalardan tashqari ma'lumot beradi. Masalan, kompilyatorga faylning ba'zi tarkibiga qanday ishlov berish kerakligini ko'rsatishi mumkin. JavaScript’da bunga misol qilib, eski modullar tepasida ko'rinadigan \"use strict\" pragma’larini, shuningdek, React Server Components (RSC) kontekstidagi yaqinda qo'llanilgan \"use client\" pragmasini keltirish mumkin. Bu haqda batafsil \"React Server Komponentlari\" bobida to'xtalib o'tamiz. Pragma’larning ishlatilinishi Parser pragmasiga duch kelganda chaqiriladigan funksiya nomi moslashtirilishi mumkin va avval aytib o'tilganidek, funksiyasiga yoki yangiroq o'zgartirish bilan funksiyasiga o'zgartiriladi. Bu funksiya quyidagicha bo'lishi kerak: Ya'ni, u argument sifatida , va larni qabul qiladi. JSX qanday qilib oddiy JavaScript sintaksisiga mos kelishini quyida ko'rish mumkin. Quyidagi JSX kodi: quyidagi JavaScript kodiga aylantiriladi: Bu yerda tag ( ), props ( ) va children ( ) orasidagi moslikni ko'rishingiz mumkin. JSX pragmasining roli shunday: bu bir necha, rekursiv funksiya chaqiruvlariga sodda sintaksis(syntax sugar)ni beradi. JSX pragma asosan qisqartma(alias) hisoblanadi: o'rniga belgisi.",
    "url": "/books/fluent-react/jsx/jsx-pragma/page",
    "category": "books",
    "tags": [
      "fluent-react",
      "tutorial",
      "guide",
      "react",
      "javascript",
      "frontend",
      "jsx",
      "pragma",
      "javascript",
      "funksiya",
      "mumkin",
      "bilan",
      "hisoblanadi",
      "bunga",
      "duch",
      "kelganda",
      "chaqiruviga",
      "kompilyatorga",
      "lumot",
      "berish",
      "beradi"
    ]
  },
  {
    "id": "book-fluent-react-jsx-page",
    "title": "JSX Nima? JavaScript Sintaksis Kengaytmasi Bilan Tanishing",
    "content": "JSX o'zi nima? 1-bo'limda biz React va uning kelib chiqish tarixi haqida bilib oldik, shuningdek, uni zamonining boshqa mashhur JavaScript kutubxona va freymvorklari bilan taqqosladik. Biz React’ning haqiqiy qiymatini va nima uchun u shunchalik mashhur bo'lganini tushundik. 2-bo'limda esa biz JSX haqida o'rganamiz. JSX bu JavaScript uchun sintaksis kengaytmasi bo'lib, bizga JavaScript kodida HTML’ga o'xshash kod yozishga imkon beradi. React ilk bor 2013 yilda joriy qilinganda, odamlar birinchi bo'lib JSX’ga ko'plab tanqidlar yog'dirgan edi. Shu sababli, dastlabki bo'limlarda JSX’ni batafsil o'rganish mantiqan to'g'ri bo'ladi. Shunday qilib, keling, bu sintaksis kengaytmasini, uning qanday ishlashini va qanday qilib o'z kodimizni yaratishimiz mumkinligini ko'rib chiqamiz. Birinchi navbatda, JSX nimani anglatishini tushunaylik. Biz allaqachon JS — JavaScript ekanligini bilamiz. Shunday qilib, JSX \"JavaScript X\" degan ma'noni anglatadimi? Masalan, Mac OS X singari. Yoki JSX \"JavaScript Xtra\" degan ma'noni bildiradimi? Bularni oldindan taxmin qilish oson bo'lishi mumkin, lekin JSX’dagi X harfi _JavaScript Sintaksis Kengaytmasi(JavaScript Syntax eXtension)_ ni bildiradi. Ba'zida uni _JavaScript XML_ deb ham atashadi.",
    "url": "/books/fluent-react/jsx/page",
    "category": "books",
    "tags": [
      "fluent-react",
      "tutorial",
      "guide",
      "react",
      "javascript",
      "frontend",
      "jsx",
      "javascript",
      "biz",
      "sintaksis",
      "nima",
      "react",
      "kengaytmasi",
      "qilib",
      "limda",
      "uning",
      "haqida",
      "uni",
      "mashhur",
      "bilan",
      "uchun"
    ]
  },
  {
    "id": "book-fluent-react-jsx-recap-page",
    "title": "JSX Xulosasi: Asosiy Konsepsiyalar va Takrorlash",
    "content": "Bo'limni qisqacha takrorlash Yaxshi, biz JSX mavzusida yetarlicha ma'lumotlarni ko'rib chiqdik. Bu mavzuda o'zimizni ishonchli (yoki bu mavzuda yaxshi tushunchaga ega) his qilish darajasiga yetgan bo'lishimiz kerak, shunda JSX’ning turli jihatlarini osonlik bilan tushuntira olamiz. Takrorlash uchun savollar Quyidagi savollarga javob berib, mavzularni yaxshiroq tushunganingizni tekshirib ko'ring: 1. _JSX nima? Uning afzalliklari va kamchiliklari nimalar?_ 2. _JSX va HTML o'rtasidagi farq nima?_ 3. _Tekst satri qanday qilib mashina kodi(machine code)ga aylanadi?_ 4. _JSX ifodalari nima va ular qanday foydalar beradi?_ Agar bu savollarga javob berishda qiyinchilikka duch kelsangiz, bu bobni yana bir marta ko'rib chiqishingiz mumkin. Agar bunday bo'lmasa, keyingi bo'limga o'tamiz. Keyingi bo'lim Endi JSX bilan juda yaxshi tanishib chiqqanimizdan so'ng, React’ning navbatdagi jihatiga e'tibor qaratamiz va React’dagi bilimlarimizni yanada boyitamiz. Keling, virtual DOM’ni batafsil o'rganishga kirishamiz.",
    "url": "/books/fluent-react/jsx/recap/page",
    "category": "books",
    "tags": [
      "fluent-react",
      "tutorial",
      "guide",
      "react",
      "javascript",
      "frontend",
      "jsx",
      "takrorlash",
      "yaxshi",
      "_jsx",
      "nima",
      "rib",
      "mavzuda",
      "ning",
      "bilan",
      "savollarga",
      "javob",
      "qanday",
      "agar",
      "keyingi",
      "react"
    ]
  },
  {
    "id": "book-fluent-react-jsx-under-the-hood-page",
    "title": "JSX'ning Ichki Mexanizmi: Kompilyatorlar Qanday Ishlaydi?",
    "content": "JSX’ning ichki ishlash mexanizmi (under the hood) Qanday qilib biror dasturlash tilining kengaytmasini yaratish mumkin? Ular qanday ishlaydi? Bu savollarga javob berish uchun dasturlash tillari haqida biroz tushunishimiz kerak bo'ladi. Ayniqsa, quyidagi kod qanday qilib 3 ni chiqarishini tushunib olishimiz zarur: Bu oddiy misolni tushunish JSX’ni yaxshiroq anglashimizga yordam beradi, bu esa o'z navbatida React’ni yaxshiroq tushunishga va React bilan ishlashdagi qobiliyatimizni oshirishga olib keladi. Kod qanday ishlaydi? Oldingi kod misoli faqatgina tekst edi. Bu qanday qilib kompyuter tomonidan tushunilib, bajariladi? Yangi boshlovchilar uchun, bu tekst faylidagi so'zlarni aniqlay oladigan katta, aqlli (regular expression) emas. Tajribada shunday bir marta dasturlash tilini shu usulda yaratishga harakat qilingan va bu muvaffaqiyatsiz bo'lgan, chunki regex’lar to'g'ri ishlashini ta'minlash qiyin, ular o'qish va tushunish uchun ham murakkab, va texnik muammolar tufayli uni maintain qilish qiyin bo'ladi. Misol sifatida, quyidagi regex haqiqiy email manzilini tanib olish uchun ishlatiladi. Bir qarashda, uning nima uchun ishlatilayotganini bilish deyarli imkonsiz: Biroq, bu regex to'liq ham emas, chunki uning to'liq versiyasi hatto bir sahifaga sig'masligi mumkin! Shuning uchun, regex o'rniga, kod kompilyator deb nomlangan dastur yordamida o'qiladi. Kompilyator yuqori darajadagi dasturlash tilida yozilgan manba kodni sintaksis daraxtiga (masalan, JavaScript obyektiga o'xshash daraxt ma'lumotlar strukturasiga) aylantiradi va bu maxsus qoidalarga binoan amalga oshiriladi. Kod kompilyatsiyasi bir necha bosqichlarni o'z ichiga oladi: leksik tahlil(lexical analysis), sintaksisni tahlil qilish(parsing), semantik tahlil(semantic analysis), optimizatsiya va kodni generatsiya qilish(code generation). Keling, ushbu qadamlarning har birini batafsilroq ko'rib chiqamiz va zamonaviy dasturiy ta'minotni ishlab chiqish asnosida kompilyatorlarning rolini muhokama qilamiz. Kompilyator JavaScriptda uchta asosiy bosqichdan iborat jarayon orqali ishlaydi: _tokenizatsiya(tokenization)_, _tahlil qilish(parsing)_ va _kodni generatsiya qilish(code generation)_. Keling, har bir bosqichni batafsil ko'rib chiqamiz: Tokenizatsiya (Tokenization) Asosan, belgilardan iborat satrni mazmunli tokenlarga ajratish. Agar tokenlar holatga ega bo'lsa (stateful) va har bir token ota-ona yoki bolalar haqida holat(state) saqlasa, bunday tokenlash _lexer_ deb ataladi. Bu muhokamamiz maqsadlari uchun zarur bo'lgan soddalashtirishdir: leksing asosan holatga ega tokenlashdir. Lexer’lar tokenlarni aniqlash uchun ba'zan regex’lar yoki shunga o'xshash narsalardan foydalanadigan lexer qoidalariga ega bo'ladi. Ular o'zlarining dasturlash tilini ifodalovchi tekst satrida o'zgaruvchi nomlari, obyekt kalitlari va qiymatlari va boshqa muhim tokenlarni aniqlash uchun qo'llaniladi. Lexer keyin bu kalit so'zlarni amalga oshirilishiga qarab, ma'lum bir toifa bo'yicha xaritalaydi. Masalan, 0 ga, 1 ga, 2 ga va hokazo. Satr tokenlangan yoki lexed bo'lgandan so'ng, biz keyingi bosqichga o'tamiz, ya'ni parsing. Tahlil qilish (Parsing) Bu jarayon tokenlarni olib, ularni sintaksis daraxtiga aylantirish jarayonidir. Sintaksis daraxti kod tuzilishini ifodalovchi data structure(ma'lumotlar strukturasi)’dir. Masalan, oldin ko'rib chiqqan kodimiz satrlari sintaksis daraxti sifatida quyidagicha ifodalanishi mumkin: Parser’ning yordamida satr, ya'ni string, JSON obyekti bo'lib qoladi. Dasturchilar sifatida, biz bunday ma'lumotlar tuzilmasiga ega bo'lganda, qiziqarli narsalarni amalga oshirishimiz mumkin. Dasturlash tillari dvigate(engine)lari ushbu data structure’lardan foydalanib, uchinchi bosqichda kodni generatsiya qilish jarayonini tugatadi. Kodni generatsiya qilish (code generation) Bu yerda kompilyator abstrakt sintaksis daraxtidan (AST) mashina kodini ishlab chiqaradi. Bu AST’dagi kodni kompyuter protsessorida to'g'ridan-to'g'ri bajarilishi mumkin bo'lgan ko'rsatmalar to'plamiga aylantirishni o'z ichiga oladi. Natijada, mashina kodi JavaScript dvigateli tomonidan bajariladi. Umuman olganda, AST’ni mashina kodiga aylantirish jarayoni murakkab bo'lib, ko'plab turli bosqichlarni o'z ichiga oladi. Biroq, zamonaviy kompilyatorlar juda murakkab bo'lib, keng ko'lamdagi hardware arxitekturalarida samarali ishlaydigan yuqori darajada optimallashtirilgan kod ishlab chiqarishi mumkin. Kompilyator turlari Kompilyatorlar bir necha xil bo'lib, har biri turli xususiyatlar va foydalanish holatlariga ega. Eng ko'p tarqalgan kompilyator turlari quyidagilardir: - Native kompilyatorlar (Native compilers): Ushbu kompilyatorlar maqsad qilingan platformaning protsessorida to'g'ridan-to'g'ri bajarilishi mumkin bo'lgan mashina kodini ishlab chiqaradi. Native kompilyatorlar odatda mustaqil ilovalar yoki tizim darajasidagi dasturlar yaratish uchun ishlatiladi. - Cross kompilyatorlar (Cross-compilers): Ushbu kompilyatorlar, kompilyator ishlayotgan platformadan farq qiluvchi platforma uchun mashina kodini ishlab chiqaradi. Cross kompilyatorlar odatda o'rnatilgan(embedded) tizimlarni rivojlantirishda yoki ixtisoslashtirilgan hardware’larni maqsad qilganda ishlatiladi. - JIT (Just-in-Time) kompilyatorlar: Ushbu kompilyatorlar kodni bajarilish vaqti(runtime)da mashina kodiga aylantiradi, undan oldin emas. JIT kompilyatorlari, masalan, Java virtual mashinasida keng qo'llaniladi va an'anaviy tarjimon(interpreter) kompilyatorlarga nisbatan sezilarli darajada samaradorlik afzalliklarini taklif qiladi. - Tarjimon kompilyatorlar (Interpreters): Ushbu dasturlar manba kodini bevosita bajaradi, kompilyatsiyani talab qilmasdan. Interpreter’lar odatda kompilyatorlardan sekinroq bo'ladi, lekin kengroq moslashuvchanlik va foydalanish qulayligini taklif qiladi. Javascript foydalanadigan kompilyator JavaScript kodini samarali bajarish uchun zamonaviy muhitlar, shu jumladan veb brauzerlari, ko'pincha JIT kompilyatorlaridan foydalanadi. Ushbu tizimlarda, JavaScript manba kodi avval bir oraliqdagi ifodaga, masalan, bayt kodiga aylantirilishi mumkin. Keyin JIT kompilyatori dastur bajarilayotgan paytda, ushbu bayt kodini mashina kodiga dinamik ravishda aylantiradi. Bu _real vaqt rejimi (on-the-fly)_ kompilyatsiyasi, dvigatelga real vaqt ma'lumotlari, masalan, o'zgaruvchilar turlari va tez-tez bajariladigan kod yo'llari asosida optimallashtirish imkonini beradi. Ba'zi dvigatellar, bajarilayotgan kod segmentlari uchun tezkor, optimallashtirilmagan kompilyatsiyadan boshlanadigan bir necha bosqichli kompilyatsiyani qo'llaydi. Ushbu dinamik yondashuv JavaScript dvigatellariga keng doiradagi ilovalar uchun ajoyib samaradorlikni ta'minlash imkonini beradi. Javascript runtime’lari Runtime’lar odatda dvigatellar bilan interfeysni ta'minlaydi, o'z muhitlariga mos kontekstual yordamchilar va xususiyatlarni taqdim etadi. Eng mashhur JavaScript runtime’laridan biri, shubhasiz, Google Chrome kabi umumiy veb brauzerdir: u dvigatel bilan interfeysni ta'minlaydigan Chromium runtime’ni o'z ichiga oladi. Shuningdek, server tomonda _v8_ dvigatelidan foydalanadigan Node.js runtime’ni ishlatamiz. Siz hozirgi paytda qaysi yana boshqa dvigatel va runtime’larni bilasiz? Runtime JavaScript dvigatellariga kontekstni beradi, masalan, brauzer runtime bilan birga keladigan obyekti va obyekti. Agar siz avval brauzerlar va Node.js bilan ishlagan bo'lsangiz, Node.js'ning o'zida global obyekti yo'qligini payqagan bo'lsangiz kerak. Chunki bu boshqa runtime bo'lib, shuning uchun boshqa kontekstni taqdim etadi. Cloudflare _Workers_ deb nomlangan shunga o'xshash runtime’ni yaratdi, bu JavaScript’ni global distributsiya qilingan mashinalarda, ya'ni edge serverlarda bajarish uchun javobgardir. Bun va Deno esa yanada ko'proq alternativ runtime’lardir — ammo biz bu jarayonni chetlab o'tmoqdamiz. Bularning barchasi JSX bilan qanday bog'liq?",
    "url": "/books/fluent-react/jsx/under-the-hood/page",
    "category": "books",
    "tags": [
      "fluent-react",
      "tutorial",
      "guide",
      "react",
      "javascript",
      "frontend",
      "uchun",
      "kompilyatorlar",
      "runtime",
      "bir",
      "javascript",
      "kod",
      "ushbu",
      "mumkin",
      "qilish",
      "kompilyator",
      "qanday",
      "masalan",
      "mashina",
      "dasturlash",
      "bilan"
    ]
  },
  {
    "id": "book-fluent-react-page",
    "title": "React'ga Kirish: Ichki Ishlash Mexanizmlari Tahlili",
    "content": "React'ga kirish Ushbu platformamiz React'dan qanday foydalanishni o'rganmoqchi bo'lganlar uchun emas. Agar siz React bilan tanish bo'lmasangiz va darslik izlayotgan bo'lsangiz, react.dev saytidagi React dokumentatsiyasi boshlash uchun yaxshi bo'lishi mumkin. Aksincha, bu kitob qiziquvchanlar uchun: React'dan qanday foydalanishdan ko'ra, React _qanday ishlashi_ bilan qiziqqan odamlar uchun yozilgan. Biz birgalikda React tushunchalari orqali sayohat qilib, ularning qanday ishlashini tushunamiz va hammasi bir-biri bilan qanday mos kelib, React yordamida dasturlar yaratishga imkon berishini o'rganamiz. Asosiy mexanizmlarni anglash uchun zarur bo'lgan aqliy modellarini rivojlantirib, React va uning ekotizimi haqida chuqurroq bilimga ega bo'lamiz. Ushbu platformadagi o'quvchilarimizni quyidagilarni biladi deb taxmin qilamiz: brauzerlar veb-sahifalarni render qiladi. Veb-sahifalar CSS bilan stil berilgan HTML dokumentlari va JavaScript bilan interaktiv qilinadi. Shuningdek, buni boshlashdan avval, bizda React'ni qanday ishlatish haqida biroz tushuncha, bilimlar va bir yoki ikkita React dasturini yaratgan bo'lishimiz kerak. Ideal holda, ba'zi React dasturlarimiz production (foydalanish) holatida bo'lishi lozim. Dastavval, biz React bilan tanishamiz va uning tarixiga qisqacha nazar tashlaymiz, 2013-yilda ilk bor ochiq manba sifatida chiqarilgan vaqtga qaytamiz. Shundan so'ng, Biz JSX qanday ishlashi haqidagi kompilyator nazariyasiga kirib boramiz, fiber'lar haqida gaplashamiz va uning parallel(concurrent) dasturlash modelini chuqur tushunamiz. Shunday qilib, va kabi kuchli primitivlar orqali qanday memoizatsiya qilish va qaysi render ishlarini keyinga qoldirish kerakligini o'rganamiz. So'ngra, React uchun yaratilgan freymvorklarni o'rganamiz: ularning qanday muammolarni hal qilishi va buni qanday mexanizmlar orqali amalga oshirishi. Biz buni barcha veb-ilovalar uchun dolzarb bo'lgan uchta muammoni - serverda render qilish, routing qilish va ma'lumotlarni olish (data fetching) - hal qiladigan o'z freymvorkimizni yozish orqali amalga oshiramiz. Bu muammolarni o'zimiz hal qilganimizda, freymvorklar qanday ishlashini tushunimiz ancha qulayroq bo'ladi. Shuningdek, biz React server komponentlari (RSC) va serverdagi harakatlar (server actions) haqida chuqurroq bilib olamiz, keyingi avlod vositalarining (next-generation tooling), masalan, to'plash vositalari(bundlers) va izomorfik router'larning rolini anglaymiz. Yakunida esa, React'dan tashqariga nazar tashlab, Vue, Solid, Angular, Qwik va boshqa alternativlarni o'rganamiz. React'ning kam tafsiliy darajadagi (coarse-grained) reaktivlik modeliga qarshi yuqori tafsiliy darajada (fine-grained) bo'lgan reaktivlik modellarini o'rganamiz. Shuningdek, React'ning signalga javobi bo'lgan Forget vositalar zanjiri va u signal bilan qanday solishtirilishini ko'rib chiqamiz. Oldinda juda ko'p mavzular bor, shuning uchun vaqtni behuda sarflamaylik va tezroq boshlaylik! _\"O'zbekcha tarjimasi: Fluent React, by Tejas Kumar. Copyright 2024 Tejas Kumar. O'Reilly Media, Inc tomonidan nashr etilgan. Ruxsat bilan foydalanilgan.\"_ Fluent React React'ni chuqur o'rganish uchun to'liq qo'llanma Ushbu kitob haqida Bu kitob React'ni chuqur o'rganmoqchi bo'lgan dasturchilar uchun mo'ljallangan. Kitobda React'ning asosiy tushunchalari, ilg'or mavzular va amaliy misollar keltirilgan. Nima o'rganasiz - React'ning paydo bo'lish tarixi - Virtual DOM va uning ishlash tamoyili - JSX sintaksisi va uning ichki mexanizmi - Reconciliation jarayoni - React'ning ilg'or imkoniyatlari - Server-side rendering - Concurrent React - React freymvorklari - React server komponentlari Boshlash O'rganishni boshlash uchun chap tomondagi navigatsiyadan mavzuni tanlang yoki keyingi tugmasini bosing. Yaxshi o'rganish! 🚀",
    "url": "/books/fluent-react/page",
    "category": "books",
    "tags": [
      "fluent-react",
      "tutorial",
      "guide",
      "react",
      "javascript",
      "frontend",
      "react",
      "qanday",
      "uchun",
      "bilan",
      "biz",
      "rganamiz",
      "lgan",
      "uning",
      "haqida",
      "ning",
      "orqali",
      "server",
      "ushbu",
      "dan",
      "boshlash"
    ]
  },
  {
    "id": "book-fluent-react-powerful-patterns-compound-components-page",
    "title": "React'da Birlashgan Komponentlar (Compound Components) Patterni",
    "content": "Birlashgan komponentlar (Compound Components) Ba’zida bizda shunga o'xshash accordion komponentlari bo'ladi: Bu komponent quyidagi kabi ro'yxatni ko'rsatishga mo'ljallangan, faqat bir vaqtning o'zida bitta element ochiq bo'la oladi: - - - Ushbu komponentning ichki ishlashi taxminan quyidagicha ko'rinadi: Ammo, agar biz va elementlari orasida maxsus ajratgich bo'lishini xohlasakchi? Yoki uchinchi havolani qizil rangda bo'lishini istasak-chi? Biz, ehtimol, quyidagi kabi qandaydir hiylaga murojaat qilishimiz mumkin: Ammo bu ko'rinish biz xohlagandek bo'lmasligi mumkin. Shuning uchun, biz, ehtimol, o'zimiz yaratgan hiylani yanada o'zgartirishimiz kerak bo'ladi: Endi, bu kod bilan faxrlansak bo'ladimi? Ishonchimiz komil emas. Shuning uchun bizga _birlashgan komponentlar_ kerak bo'ladi: ular o'zaro bog'langan, alohida komponentlarni guruhlash imkonini beradi, ular birgalikda state’ni ulashadi, ammo ular avtomatik ravishda render qilinishi mumkin, bu esa bizga elementlar daraxtini boshqarish uchun ko'proq nazoratni taqdim etadi. Birlashgan komponentlar yordamida Accordion Birlashgan komponentlar (compound components) pattern’ini ishlatsak, ushbu accordion quyidagicha ko'rinadi: Agar bu pattern’ni React’da qanday amalga oshirish mumkinligini o'rgansak, ikkita usulni ko'rib chiqishimiz mumkin: - yordamida bolalarni boshqarish - yordamida React.context qo'shish eski API hisoblanadi, shuning uchun bu masalani React Context yordamida hal qilishni o'rganamiz. Avvalo, accordion’ning har bir qismi o'qiy oladigan context’ni yaratishdan boshlaymiz: Keyin, komponentimiz context’ni farzandlariga taqdim qiladi: Endi, alohida komponentlarini yaratamiz, ular ham ushbu context’ni iste'mol qilib, unga javob beradi: Endi, komponentining bir nechta qismi mavjud bo'lib, uni birlashgan komponentga aylantirdik. Foydalanishimiz quyidagicha o'zgaradi, avval bunday bo'lgan bo'lsa: Endi esa bunday: Buning afzalligi shundaki, biz ko'proq nazoratga ega bo'lamiz, shu bilan birga har bir ning kattaroq state’idan xabardor bo'ladi. Endi, agar biz va elementlari orasiga gorizontal chiziq qo'shmoqchi bo'lsak, biz metodini o'rniga, qo'lda boshqarish yo'lini tanlashimiz mumkin: Yoki aralash usulni qo'llashimiz mumkin: Bu birlashgan komponentlarning afzalligi shundaki, ular boshqaruvni render qilish uchun ota komponentga topshiradi, shu bilan birga farzandlar o'rtasidagi kontekstual holatni saqlab qoladi. Xuddi shu yondashuvni \"tab\" interfeysida ham qo'llash mumkin, bunda tab’lar joriy tab holatidan xabardor bo'ladi, lekin har xil darajadagi elementlar joylashishi mumkin. Boshqa bir afzallik shundaki, bu pattern ma'suliyatlarni ajratish(separation of concerns)ni qo'llab-quvvatlaydi, bu esa dasturlarni vaqt o'tishi bilan ancha yaxshi kengaytirishga yordam beradi.",
    "url": "/books/fluent-react/powerful-patterns/compound-components/page",
    "category": "books",
    "tags": [
      "fluent-react",
      "tutorial",
      "guide",
      "react",
      "javascript",
      "frontend",
      "mumkin",
      "biz",
      "birlashgan",
      "ladi",
      "bir",
      "uchun",
      "endi",
      "ular",
      "context",
      "komponentlar",
      "accordion",
      "bilan",
      "yordamida",
      "react",
      "compound"
    ]
  },
  {
    "id": "book-fluent-react-powerful-patterns-control-props-page",
    "title": "React'da Boshqaruvchi Props'lar (Control Props) Patterni",
    "content": "Boshqaruvchi props’lar (Control props) React’da _Control Props_ pattern’i — bu state’ni boshqarishning strategik yondashuvi bo'lib, boshqariladigan komponentlar konsepsiyasini kengaytiradi. Bu pattern komponent ichida qanday qilib state boshqarilishi haqida moslashuvchan mexanizm taqdim etadi. Buni yaxshiroq tushunish uchun avval boshqariladigan komponentlar haqida tushuncha hosil qilishimiz kerak. Boshqariladigan komponentlar (Controlled components) Boshqariladigan komponentlar o'z ichki state’ini saqlab turmaydigan komponentlardir. Buning o'rniga, ular o'zining joriy qiymatini ota komponentdan prop sifatida oladi, va bu state uchun yagona ishonch manbai hisoblanadi. State o'zgarishi kerak bo'lganda, boshqariladigan komponentlar ota komponentga odatda kabi callback funksiyalar orqali xabar beradi. Shunday qilib, ota komponent state’ini boshqarish va boshqariladigan komponentning qiymatini yangilash uchun javobgar hisoblanadi. Masalan, boshqariladigan elementi quyidagicha bo'ladi: _Control Props_ pattern’i boshqariladigan komponentlar tamoyilini yanada rivojlantiradi, bu orqali komponentga tashqaridan prop’lar orqali boshqarilish yoki o'zini state’ini ichki tomondan mustaqil ravishda boshqarish imkoniyati beriladi, ya'ni tashqi boshqaruvni ixtiyoriy qiladi. Ushbu pattern’ga amal qiluvchi komponent state qiymatini va uni yangilash uchun funksiyani prop sifatida qabul qiladi. Bu ikki tomonlama imkoniyat ota komponentga bolaning holatini nazorat qilish imkonini beradi, lekin nazorat qilinmasa, bola komponent mustaqil ravishda ishlay oladi. komponenti misoli _Control Props_ pattern’ga misol sifatida boshqarilishi mumkin bo'lgan yoki o'z holatini mustaqil boshqaruvchi almashtirish tugmasi(button)ni keltirish mumkin: Toggle komponentida ichki state’ni ifodalaydi, esa tashqi boshqaruv prop hisoblanadi. Agar ota komponent prop’ni taqdim etsa, komponent boshqariladigan rejimda ishlaydi. Agar unday bo'lmasa, u o'z ichki state’iga, ya'ni ga asoslanadi. esa ota komponentga state o'zgarishiga javob qaytarish imkonini beruvchi callback funksiya bo'lib, bu orqali ota komponent o'z state’ini komponenti state’i bilan sinxronlashtirish imkoniyatiga ega bo'ladi. Ushbu pattern komponentni moslashuvchanligini oshiradi, boshqariladigan va boshqarilmaydigan rejimlarda ishlash imkoniyatini taqdim etadi. Bu, kerak bo'lganda, ota komponentni boshqarish imkoniyatiga ega qiladi, shu bilan birga, komponentni aniq boshqarilmasa ham o'z state’ini mustaqil boshqarish imkonini beradi.",
    "url": "/books/fluent-react/powerful-patterns/control-props/page",
    "category": "books",
    "tags": [
      "fluent-react",
      "tutorial",
      "guide",
      "react",
      "javascript",
      "frontend",
      "state",
      "boshqariladigan",
      "ota",
      "komponent",
      "pattern",
      "komponentlar",
      "ini",
      "prop",
      "props",
      "uchun",
      "ichki",
      "komponentga",
      "orqali",
      "boshqarish",
      "mustaqil"
    ]
  },
  {
    "id": "book-fluent-react-powerful-patterns-high-order-component-page",
    "title": "Yuqori Darajadagi Komponentlar (HOC): React'da Logikani Qayta Ishlatish",
    "content": "Yuqori darajadagi komponent (Higher-Order Component) <Callout type='info'Vikipediyaga ko'ra, yuqori darajadagi funksiya (higher-order function, HOF) quyidagicha ta'riflanadi: Matematika va computer science’da, yuqori darajadagi funksiya kamida bittasini bajaradi: bir yoki bir nechta funksiyalarni argument sifatida oladi (ya'ni, protsedura parametri, bu protsedura o'zi protsedura bo'lgan parametr), natija sifatida funksiyani qaytaradi. </CalloutJSX dunyosida esa, yuqori darajadagi komponent (higher-order component, HOC) asosan shunday: bir komponent boshqa komponentni argument sifatida oladi va ularni kompozitsiyasi, ya'ni birlashtirish, natijasida yangi komponentni qaytaradi. HOC’lar komponentlar o'rtasida umumiy xatti-harakatlarni takrorlamaslik uchun juda foydalidir. Masalan, ko'plab veb-ilovalar ma'lumotlarni ba'zi ma'lumot manbalaridan asinxron ravishda so'rashlari kerak bo'ladi. Yuklash va xato holatlari bo'lishi ko'pincha muqarrar, ammo ba'zida dasturimizda ularni hisobga olishni unutamiz. Agar biz qo'lda komponentlarimizga , va kabi props’larni qo'shsak, ba'zilarini unutish ehtimoli oshadi. \"To do list\" misoli Keling, asosiy vazifalar ro'yxati ilovasini ko'rib chiqaylik: Ushbu ilovada bir nechta muammolar mavjud. Biz bunda yuklash yoki xato holatlarini hisobga olmadik. Keling, buni tuzatamiz: \"Cross-cutting concern\" muammosi va HOC bilan bartaraf etish Bunga e'tibor bering, bu juda tez murakkablashib ketdi. Bundan tashqari, bu faqat bitta komponent uchun muammoni hal qiladi. Har bir tashqi ma'lumot manbasi bilan ishlaydigan komponentga ushbu holatlarni (ya'ni, yuklanish, ma'lumot va xato) qo'shishimiz kerakmi? Bu umumiy masala muammosidir (cross-cutting concern) va aynan shu yerda HOC’lar yordamga keladi. Yuklanish, xato va ma'lumotlarni boshqarish uchun har bir komponentda bularni takrorlashning o'rniga, tashqi ma'lumot manbasi bilan asinxron muloqot qiladigan komponentlarda, HOC fabrikasi(factory, yaratuvchi funksiya)dan foydalanishimiz mumkin. Keling, bu holatlarni hal qiluvchi HOC fabrikasini ko'rib chiqamiz: yuklanish va xato holatlarini boshqaradi hamda ma'lumot mavjud bo'lganda har qanday komponentni ko'rsatadi. Keling, uning amalga oshirilishini ko'rib chiqaylik: Endi orqali har qanday o'tkazilganda, biz props’lariga asoslanib kerakli ma'lumotlarni ko'rsatadigan yangi komponentni olamiz. Bu dastlabki komponentimizni yanada qulayroq qilishga imkon beradi: Endi murakkab ifodalangan shartlar yo'q, va o'zi yuklanayotgan bo'lsa, xato bo'lsa yoki ma'lumotga ega bo'lsa, mos ma'lumotni ko'rsatadi. HOC fabrikasi bu \"cross-cutting concern\" muammosini hal qilgani sababli, biz tashqi ma'lumot manbasi bilan ishlaydigan har qanday komponentni u bilan o'rashimiz va hamda props’lariga javob beradigan yangi komponentni olishimiz mumkin. Masalan, blogni ko'rib chiqaylik: Ushbu misolda, va komponentlari HOC pattern’idan foydalanadi, bu esa va ning yangi versiyasini qaytaradi, ular endi va props’lariga javob beradi. Bu \"cross-cutting concern\" muammosini boshqarish da markazlashgan holda amalga oshirilgan, shuning uchun yuklanish va xato holatlarini hisobga olishni faqat HOC pattern’i orqali hal qilamiz. Biroq, oldingi tadimot va konteyner(boshqaruv) komponentlariga o'xshash, HOC’lar ko'pincha hook’lar foydasiga chiqarib yuboriladi, chunki hook’lar bir xil afzalliklarni va qo'shimcha qulaylik bilan taqdim etadi. HOC’larni kompozitsiya qilish Bir nechta HOC’larni birlashtirib kompozitsiya React’da keng tarqalgan pattern bo'lib, u dasturchilarga turli komponentlar orasida funksiyalar va xatti-harakatlarni aralashtirish va moslashtirish imkonini beradi. Keling, bir nechta HOC’larni qanday kompozitsiya qilish mumkinligini ko'rib chiqamiz: Faraz qilaylik, sizda ikkita HOC mavjud: va : Endi, ushbu ikkita HOC’ni birlashtirishni xohlaysiz. Buning bir usuli ularni ichma-ich joylashtirishdir: Biroq, ichma-ich joylashtirilgan HOC’larni o'qish va qo'llab-quvvatlash qiyin bo'lishi mumkin, ayniqsa HOC’lar soni ko'paygan sari. Faraz qiling, bu dasturingizda vaqt o'tishi bilan quyidagicha ko'rinishda bo'ladi: Yordamchi \"compose\" funksiyasi Yo'q! Buni o'qish qiyin. Yaxshi usul - bu bir nechta HOC’larni yagona HOC sifatida birlashtiradigan yordamchi funksiyani yaratishdir. Bunday yordamchi funksiya quyidagicha ko'rinishga ega bo'lishi mumkin: Ushbu funksiyasida har bir HOC’ni o'ngdan chapga qarab ga qo'llaydi. Bu usulda siz HOC’laringizni tekis ro'yxatda keltira olasiz, bu esa o'qish va uni qo'llab-quvvatlashni osonlashtiradi. funksiyasi funksional dasturlashda keng tarqalgan yordamchi vosita bo'lib, Redux kabi kutubxonalar ushbu maqsad uchun o'zlarining yordamchi funksiyasini taqdim etadi. Avvalgi murakkab misolimizni yangi yordamchi funksiyamiz bilan qayta ko'rib chiqsak, quyidagicha ko'rinadi: Yaxshiroq emasmi? Kamroq joy tashlash, yaxshiroq o'qish va osonroq qo'llab-quvvatlash. Zanjirdagi har bir HOC avvalgi HOC tomonidan ishlab chiqarilgan komponentni o'rab, o'z funksionalligini qo'shadi. Bu usulda siz murakkab komponentlarni oddiyroq komponentlar va HOC'lar yordamida yig'ishingiz mumkin, ularning har biri faqatgina o'ziga tegishli bo'lgan bir muammoga e'tibor qaratadi. Bu sizning kodingizni yanada modulli, tushunarli va testlash uchun qulayroq qiladi. HOC va hook’larni taqqoslash Hook’lar joriy etilganidan beri HOC’larning ommabopligi pasaydi. Hook’lar komponentlarga funksiyalarni qo'shish uchun qulayroq usulni taqdim etadi va HOC’lar bilan bog'liq ba'zi muammolarni ham hal qiladi. Masalan, HOC’lar ref’larni yo'naltirishda (ref forwarding) muammolarga olib kelishi mumkin va noto'g'ri ishlatilganda keraksiz qayta renderlashlarga sabab bo'lishi mumkin. Quyidagi jadvalda HOC va hook'larni taqqoslanishini ko'rishimiz mumkin: | Xususiyat | HOC'lar | Hook'lar | | :----- | :----: | ----: | | Kodni qayta ishlatish | Bir nechta komponentlarda logikani umumlashtirish uchun juda yaxshi | Komponent ichida yoki o'xshash komponentlar orasida logikani ajratib olish va umumlashtirish uchun ideal || | Render qilish logikasi | O'ralgan komponentni render qilishni boshqarishi mumkin | To'g'ridan-to'g'ri render qilishga ta'sir qilmaydi, lekin funksional komponentlarda rendering bilan bog'liq side effect’larni boshqarishi mumkin || | Prop’lar manipulyatsiyasi | Qo'shimcha ma'lumot yoki funksiyalarni taqdim etish uchun prop'larni qo'shishi va boshqarishi mumkin | Prop'larni to'g'ridan-to'g'ri qo'shish yoki boshqarish imkoniga ega emas || | State’larni boshqarish | O'ralgan komponentdan tashqarida state’ni boshqarishi va manipulyatsiya qilish mumkin | Funksional komponentlar ichida mahalliy state’ni boshqarish uchun mo'ljallangan || | Lifecycle metodlari | O'ralgan komponent bilan bog'liq lifecycle logikalarini o'z ichiga olishi mumkin | va boshqa hook'lar funksional komponentlar ichida lifecycle event’larini boshqarishi mumkin || | Kompozitsiya osonligi | Birga kompozitsiya qilinishi mumkin, lekin noto'g'ri boshqarilganda \"wrapper hell\" ga olib kelishi mumkin | Oson kompozitsiyaga ega va boshqa hook’lar bilan qo'shimcha komponentlar qatlamlarini qo'shmasdan foydalanishi mumkin || | Testlash qulayligi | Qo'shimcha o'ralgan komponentlar tufayli testlash murakkablashishi mumkin | Odatda testlash oson, chunki HOC’larga qaraganda osonroq izolyatsiya qilinishi mumkin || | Tip xavfsizligi | TypeScript bilan to'g'ri yozish chalg'itishi mumkin, ayniqsa chuqur ichma-ich joylashtirilgan HOC’larda | Yaxshiroq tip xulosasi va TypeScript bilan yozish osonroq || Jadval HOC va hook’larni yonma-yon taqqoslab, ularning kuchli tomonlari va qo'llanish joylarini ko'rsatadi. HOC’lar hali ham foydali pattern bo'lib qolmoqda, ammo hook’lar odatda osonligi va sodda ishlatilishi tufayli ko'p hollarda afzal ko'riladi. HOC’larning afzallik va kamchiliklari Ushbu jadvaldan ko'rish mumkinki, HOC va hook’lar React’da komponentlar orasida logikani umumlashtirish uchun juda muhimdir, ammo ularning ishlatilishi vaziyatlarga qarab biroz farqli qiladi. HOC’lar bir nechta komponentlar orasida logikani umumlashtirishda ustunlik qiladi va ayniqsa, o'ralgan komponentning render qilinishini boshqarish va qo'shimcha ma'lumot yoki funksiyalarni taqdim etish uchun prop'larni boshqarishda ancha yaxshi. Ular o'ralgan komponentdan tashqarida state’ni boshqarishi va uning hayotiy siklini o'z ichiga olishi mumkin. Ammo, ko'p HOC’lar bir-birining ichiga joylashtirilganida noto'g'ri boshqarilgan taqdirda “wrapper hell”ga olib kelishi mumkin. Bunday ichma-ich joylashtirish testlashni murakkablashtirishi va TypeScript bilan tip xavfsizligini ta'minlashni qiyinlashtirishi mumkin, ayniqsa chuqur ichma-ich HOC’larda. Hook’lar taqdim etadigan afzalliklar Boshqa tomondan, hook’lar komponent ichida yoki o'xshash komponentlar orasida logikani chiqarib olish va umumlashtirish uchun ideal, qo'shimcha komponentlar qatlamlarini qo'shmasdan. Bu “wrapper hell” holatidan qochishga yordam beradi. HOC’lardan farqli o'laroq, hook’lar to'g'ridan-to'g'ri render qilishga ta'sir qilmaydi va prop’larni qo'shish yoki boshqarish imkonini bermaydi. Ular funksional komponentlar ichida mahalliy state’ni boshqarish va kabi hook’lar yordamida lifecycle event’larini boshqarish uchun mo'ljallangan. Hook’lar kompozitsiyani osonlashtiradi va odatda HOC’larga nisbatan testlash osonroq, chunki ularni izolyatsiya qilish osonroq. Bundan tashqari, TypeScript bilan ishlatilganda hook’lar yaxshiroq tiplashni taqdim etadi va yozish osonroq, shu sababli tip xatolariga oid kamchiliklarni kamaytiradi. Qay birini ishlatgan ma'qul Har ikkisi ham logikani qayta ishlatish uchun mexanizmlar taqdim etadi, lekin hook’lar state’ni boshqarish, lifecycle event’lari va boshqa React xususiyatlarini funksional komponentlar ichida boshqarishda to'g'ridan-to'g'ri va murakkab bo'lmagan yondashuvni taklif etadi. Boshqa tomondan, HOC'lar komponentlarga qo'shimcha xususiyatlarni qo'shish uchun yaxshiroq strukturalashgan usulni taqdim etadi, bu yirik kod bazalarida yoki hali hook’larni qabul qilmagan kod bazalarida foydali bo'lishi mumkin. Har birining o'z afzalliklari bor va HOC yoki hook’lardan foydalanishni tanlash asosan loyihaning aniq talablariga va jamoaning ushbu patter’lar bilan qanchalik tanishligiga bog'liq bo'ladi. Biz React’da ko'p foydalanadigan HOC’larni eslay olamizmi? Albatta! Shu bobda ko'rib chiqqan - bu aslida HOC hisoblanadi! Yana birini ko'rib chiqamiz: . Bu, ref’ni bola komponentiga yo'naltiradigan HOC hisoblanadi. Keling, bir misolni ko'rib chiqamiz: Ushbu misolda biz dan foydalanib, komponentiga ref’ni yo'naltiryapmiz. Bu, bizga ota komponentda input elementining metodiga kirish imkonini beradi. Bu React'da keng tarqalgan pattern bo'lib, oddiy komponentlar bilan hal qilish qiyin bo'lgan muammolarni hal qilishda HOC’lar qanday yordam berishini ko'rsatadi.",
    "url": "/books/fluent-react/powerful-patterns/high-order-component/page",
    "category": "books",
    "tags": [
      "fluent-react",
      "tutorial",
      "guide",
      "react",
      "javascript",
      "frontend",
      "hoc",
      "lar",
      "mumkin",
      "hook",
      "bir",
      "larni",
      "bilan",
      "uchun",
      "komponentlar",
      "yoki",
      "har",
      "boshqarish",
      "rib",
      "ushbu",
      "taqdim"
    ]
  },
  {
    "id": "book-fluent-react-powerful-patterns-page",
    "title": "React'dagi Kuchli Dizayn Patternlari",
    "content": "Kuchli va ko'p ishlatiladigan pattern’lar Dasturiy ta'minot loyihalash pattern’lari (software design patterns) dasturiy ta'minotni ishlab chiqishda qayta-qayta uchraydigan muammolar uchun keng qo'llaniladigan yechimlardir. Ular boshqa dasturchilar tomonidan duch kelinib, hal qilingan muammolarni hal qilish usulini taqdim etadi, bu esa dasturiy ta'minotni ishlab chiqishda vaqt va kuchni tejashga yordam beradi. Pattern’lar odatda turli vaziyatlarda qo'llanilishi mumkin bo'lgan dasturiy ta'minotni yaratish uchun shablonlar yoki qo'llanmalar sifatida ifodalanadi. Ular odatda umumiy atamalar va belgilangan yozuvlar yordamida tavsiflanadi, bu esa ularni dasturchilar o'rtasida tushunishni va muloqotni osonlashtiradi. Ushbu pattern’lar dasturiy tizimlarning sifatini, qo'llab-quvvatlash imkoniyatini va samaradorligini oshirish uchun ishlatilishi mumkin. Nega dasturiy ta'minot loyihalash pattern’lari muhim? Dasturiy ta'minot loyihalash pattern’lari bir nechta sabablarga ko'ra muhim hisoblanadi: - Qayta foydalanuvchanlik (Reusability): Loyihalash pattern’lari odatiy muammolar uchun qayta foydalaniladigan yechimlarni taqdim etadi, bu esa dasturiy ta'minotni ishlab chiqishda vaqt va mehnatni tejaydi. - Standartlashtirish (Standardization): Pattern’lar muammolarni hal qilish uchun standart usulni taqdim etadi, bu esa dasturchilar uchun bir-birini tushunishni va muloqotni osonlashtiradi.. - Qo'llab-quvvatlash imkoniyati (Maintainability): Loyihalash pattern’lari kod tuzilishini boshqarish va o'zgartirish uchun qulay usulni taqdim etadi, bu esa dasturiy ta'minot tizimlarining umrini uzaytirishga yordam beradi.. - Samaradorlik (Efficiency): Loyihalash pattern’lari odatiy muammolar uchun samarali yechimlarni taqdim etadi, bu esa dasturiy ta'minot tizimlarining ishlash samaradorligini oshirishi mumkin.. Pattern’larning kelib chiqishi Odatda, dasturiy ta'minot loyihalash pattern’lari vaqt o'tishi bilan, real hayotiy ehtiyojlar asosida paydo bo'ladi. Ushbu pattern’lar muayyan muammolarni hal qilishga yordam beradi va ular \"dasturchilar arsenali\"dagi turli foydalanish holatlari uchun qo'llaniladigan vositalar qatoriga kiradi. _Bir pattern boshqasidan yomonroq yoki yaxshiroq emas_; har birining o'z o'rni bor. Aksariyat pattern’lar bizga ideal abstraktsiya darajalarini aniqlashga yordam beradi: kodni qanday yozish kerakki, u vaqt o'tishi bilan \"yaxshi sharob\" kabi eskirganida ham foydali bo'lsin, o'qilishi qiyin yoki qo'llab-quvvatlab bo'lmaydigan darajada qo'shimcha holat va konfiguratsiyalarga ega bo'lmasin. Shu sababli, pattern tanlashda keng tarqalgan jihatlardan biri \"control\", ya'ni nazoratdir: foydalanuvchilarga qancha nazorat beramiz va dasturimiz qanchalik ko'p ishni o'zi bajaradi. Endi esa, React’ning mashhur pattern’larini, ular qachon paydo bo'lganiga qarab taxminiy xronologik tartibda ko'rib chiqamiz.",
    "url": "/books/fluent-react/powerful-patterns/page",
    "category": "books",
    "tags": [
      "fluent-react",
      "tutorial",
      "guide",
      "react",
      "javascript",
      "frontend",
      "pattern",
      "dasturiy",
      "uchun",
      "loyihalash",
      "lari",
      "esa",
      "lar",
      "minot",
      "taqdim",
      "etadi",
      "minotni",
      "qayta",
      "ular",
      "dasturchilar",
      "hal"
    ]
  },
  {
    "id": "book-fluent-react-powerful-patterns-presentational-container-components-page",
    "title": "Taqdimot va Boshqaruv Komponentlari (Presentational/Container)",
    "content": "Taqdimot/Boshqaruv komponentlar (Presentational/Container components) React’da keng tarqalgan dizayn pattern’laridan biri ikki komponentning kombinatsiyasidir: _taqdimot komponenti_ va _konteyner(boshqaruv) komponenti_. Taqdimot komponenti foydalanuvchi interfeysi(UI)ni ko'rsatadi, va konteyner komponenti UI holatini boshqaradi. Keling, hisoblagich(counter)ni misol qilib olaylik. Ushbu pattern’ni tatbiq qilgan hisoblagich quyidagicha ko'rinadi: Ushbu misolda bizda ikkita komponent mavjud: (taqdimot komponent) va (konteyner komponent). Taqdimot komponent UI’ni render qiladi, konteyner komponent esa UI state’ini boshqaradi. Nega bu pattern foydali? Ushbu pattern bir nechta sabablarga ko'ra foydalidir, asosiy sabab esa yagona mas'uliyat tamoyili (Single Responsibility Principle). Ushbu tamoyil bizni dasturlarimizda vazifalarni ajratishga undaydi, natijada dasturlar ko'proq modulli, qayta foydalaniladigan va hatto test qilinadigan bo'ladi. Bir komponent qanday ko'rinishini va qanday ishlashini boshqarishi o'rniga, biz bu mas'uliyatlarni ajratamiz. Afzalliklari: - Modullilik: boshqa konteynerlarga o'tkazilishi va bir xil ko'rinishni saqlab qolishi mumkin, esa boshqa holatli konteynerga almashtirilishi va funksionallikni saqlab qolishi mumkin. - Testlash: komponentini alohida unit-test qilish mumkin, komponentini esa vizual tarzda (masalan, Storybook yordamida) alohida testlash mumkin. - Jamoaviy ishni bo'lishish: Vizual ishlarga ko'proq qiziqadigan dasturchilar ustida ishlashi, ma'lumotlar strukturalari va algoritmlar bilan ishlashni afzal ko'radigan dasturchilar esa ustida ishlashi mumkin. Ushbu ajratilgan yondashuv tufayli bizda juda ko'p imkoniyatlar mavjud. Shu sababli b boshqaruv/taqdimot komponent pattern’i katta mashhurlikka ega bo'lib, bugungi kunda ham qo'llanilmoqda. Biroq, hook’larning paydo bo'lishi komponentlarga state’ni qo'shish jarayonini yanada qulay qilib qo'ydi va konteyner komponentlardan state’ni olish uchun foydalanishni talab qilmaydi. Bugungi kunda, ko'pgina hollarda boshqaruv/taqdimot pattern’ni hook’lar bilan almashtirish mumkin. Garchi biz ushbu pattern’dan hatto _React Hooks_ bilan foydalana olsak ham, kichikroq dasturlarda u ortiqcha muhandislik ishi bo'lishi mumkin.",
    "url": "/books/fluent-react/powerful-patterns/presentational-container-components/page",
    "category": "books",
    "tags": [
      "fluent-react",
      "tutorial",
      "guide",
      "react",
      "javascript",
      "frontend",
      "taqdimot",
      "pattern",
      "komponent",
      "mumkin",
      "ushbu",
      "boshqaruv",
      "esa",
      "konteyner",
      "state",
      "bir",
      "bilan",
      "presentational",
      "container",
      "komponenti_",
      "komponenti"
    ]
  },
  {
    "id": "book-fluent-react-powerful-patterns-props-collections-page",
    "title": "React'da Props Collections va Prop Getters Patternlari",
    "content": "Props kolleksiyasi (Props collections) Ko'pincha bir nechta prop’larni birga to'plashimiz kerak bo'ladi. Masalan, \"sudrab tashlash\" (drag-and-drop) foydalanuvchi interfeyslarini yaratishda bir qancha prop’larni boshqarish talab qilinadi: - : foydalanuvchi elementni sudrashni boshlaganda brauzerga nima qilish kerakligini bildirish uchun - : tushirilishi mumkin bo'lgan zona(dropzone)ni aniqlash uchun - : element bu zonaga tushirilganda qandaydir kodni bajarish uchun - : element sudrab olib bo'lgandan keyin brauzerga nima qilish kerakligini bildirish uchun Bundan tashqari, ma'lumotlar yoki elementlar boshqa elementlarga default holatda tushirilishi mumkin emas. Bir elementning boshqasiga tushirilishini ta'minlash uchun, biz hodisasi uchun metodini chaqirib, elementning default holatda ishlov berishini oldini olishimiz kerak. Ushbu prop’lar odatda birga qo'llaniladi va odatda quyidagi kabi ishlatiladi: , shuning uchun biz bu prop’larni birga to'plab, turli komponentlarda qayta ishlatishimiz mumkin: Endi, agar biz React komponentini tushirilishi mumkin bo'lgan zona kabi ishlashini kutayotgan bo'lsak, bu prop kolleksiyasini quyidagicha ishlatishimiz mumkin: Bu — _Prop collection_ pattern’i bo'lib, bir nechta prop’larni qayta ishlatiladigan qiladi. Bu pattern ko'pincha foydalanish imkoniyati qulayligi(accessibility)ni oshirish sohasida keng qo'llaniladi, masalan, foydalanish imkoniyati qulayligiga ega komponentlarda bir qator prop’larni kiritish uchun. Shunga qaramay, hali ham bir muammo mavjud, agar biz o'zimizning maxsus prop’imizni yozsak va kolleksiyani bekor qilsak, kolleksiyadan avtomatik kelgan chaqiruvini yo'qotamiz. Bu kutilmagan xatti-harakatlarga olib kelishi mumkin, va komponentni ga tushirish imkoniyatini yo'qotadi: Yaxshiyamki, biz bu muammoni _prop getters_ yordamida tuzatishimiz mumkin. Props oluvchilar (Prop getters) _Prop getter_’lari aslida prop kolleksiyalarini maxsus prop’lar bilan kompozitsiya qiladi va ularni birga birlashtiradi. Bizning misolimizda, kolleksiyasidagi hodisa ishlov beruvchisidagi chaqiruvini saqlab qolishni va unga maxsus chaqiruvini qo'shishni xohlaymiz. Buni _prop getter_’lari yordamida amalga oshirishimiz mumkin. Birinchi navbatda, kolleksiyasini _prop getter_’ga o'zgartiramiz: Bu yerda prop kolleksiyasini eksport qilgan joyimizdan tashqari hech narsa o'zgarmagan, endi biz prop kolleksiyalarini qaytaradigan funksiya eksport qilamiz, bu _prop getter_’dir Chunki bu funksiya bo'lgani tufayli, u argumentlarni qabul qilishi mumkin, masalan, maxsus funksiyasi. Biz bu maxsus ni bizning default bo'yicha bilan quyidagicha birlashtira olamiz: Endi biz _prop getter_’ni quyidagicha ishlatishimiz mumkin: Bu moslashtirilgan bizning default bo'yicha ga birikadi, va ikkita narsa sodir bo'ladi: va . Bu _prop getter_ pattern’idir.",
    "url": "/books/fluent-react/powerful-patterns/props-collections/page",
    "category": "books",
    "tags": [
      "fluent-react",
      "tutorial",
      "guide",
      "react",
      "javascript",
      "frontend",
      "prop",
      "mumkin",
      "uchun",
      "biz",
      "_prop",
      "bir",
      "getter_",
      "larni",
      "maxsus",
      "props",
      "birga",
      "default",
      "masalan",
      "tushirilishi",
      "ishlatishimiz"
    ]
  },
  {
    "id": "book-fluent-react-powerful-patterns-recap-page",
    "title": "React Patternlari Xulosasi: Memoizatsiya, Lazy Loading va Reducer'lar",
    "content": "Bo'limni qisqacha takrorlash Bundan avvalgi va ushbu boblar davomida biz React’ning turli jihatlarini, shu jumladan _memoizatsiya_, _lazy loading_, reducer’lar va state’ni boshqarish mavzularini muhokama qildik. Turli yondashuvlarning afzalliklari va ehtimoliy kamchiliklarini hamda ularning React ilovalari ishlash samaradorligi va qo'llab-quvvatlash qulayligiga qanday ta'sir ko'rsatishi mumkinligini o'rgandik. Dastlab, Reac’da memoizatsiyani va uning komponentlarni render qilishni optimallashtirishdagi afzalliklarini muhokama qildik. funksiyasini va u orqali komponentlarni keraksiz qayta render qilishning oldini olishni ko'rib chiqdik. Shuningdek, memoizatsiya bilan bog'liq ehtimoliy muammolar, masalan, eski state va qaramliklarni diqqat bilan boshqarish zarurati haqida so'z yuritdik. Keyin, React’da _lazy loading_ haqida gaplashdik va uni ba'zi komponentlar yoki resurslarni faqat kerak bo'lganda yuklashni kechiktirish uchun qanday ishlatish mumkinligini ko'rsatdik. va komponentlarini React ilovasida _lazy loading_’ni amalga oshirish uchun qanday qo'llash mumkinligini o'rgandik. Shuningdek, _lazy loading_’ning murakkablikni oshirishi va ehtimoliy ishlash samaradorlik muammolari kabi kamchiliklarini muhokama qildik. Shundan so'ng, reducer’lar va ularni React’da state’ni boshqarish uchun qanday ishlatish mumkinligi haqida gapirdik. va o'rtasidagi farqlarni o'rgandik va state yangilanishlarini boshqarish uchun markazlashgan reducer funksiyasidan foydalanishning afzalliklari haqida so'z yuritdik. Mavzularni muhokama qilish davomida biz o'z misollarimizdan foydalanib, tushunchalarni kod orqali tasvirlab berdik. Ushbu misollarning ishlash mexanizmini va ular React ilovalarining ishlash samaradorligi va qo'llab-quvvatlash qulayligiga qanday ta'sir qilishini o'rganib chiqdik. Kod misollari va chuqur tushuntirishlar orqali biz ushbu mavzularni va ularni haqiqiy hayotdagi React ilovalarida qanday qo'llash mumkinligini yaxshiroq angladik. Takrorlash uchun savollar Ushbu bobda o'rganilgan tushunchalarni sinab ko'rish uchun o'zimizga bir nechta savollar beramiz: 1. _React’da memoizatsiya nima va u komponentlarni render qilishni optimallashtirish uchun qanday ishlatilishi mumkin?_ 2. _Reactd’a dan state’ni boshqarish uchun foydalanishning afzalliklari qanday va u dan qanday farq qiladi?_ 3. _ va komponentlaridan foydalanib, React ilovasida lazy loading qanday amalga oshirilishi mumkin?_ 4. _React’da memoizatsiyadan foydalanishda qanday muammolar yuzaga kelishi mumkin va ularni qanday bartaraf etish mumkin?_ 5. _useCallback hook’ini React’da komponentlarga prop sifatida uzatiladigan funksiyalarni memoizatsiya qilish uchun qanday ishlatish mumkin?_ Keyingi bo'lim Keyingi bobda biz server tomonida React’ni ko'rib chiqamiz — server tomonida render qilish, uning afzalliklari va kamchiliklari, hidratsiya, freymvorklar va boshqa mavzularga chuqurroq kirib boramiz.",
    "url": "/books/fluent-react/powerful-patterns/recap/page",
    "category": "books",
    "tags": [
      "fluent-react",
      "tutorial",
      "guide",
      "react",
      "javascript",
      "frontend",
      "qanday",
      "react",
      "uchun",
      "state",
      "boshqarish",
      "mumkin",
      "ushbu",
      "biz",
      "_lazy",
      "loading_",
      "reducer",
      "muhokama",
      "afzalliklari",
      "ishlash",
      "mumkinligini"
    ]
  },
  {
    "id": "book-fluent-react-powerful-patterns-render-props-page",
    "title": "React'da Render Props Patterni: Logikani Qayta Ishlatish",
    "content": "Renderlovchi props JSX ifodalari haqida allaqachon gaplashganimiz uchun, kodni qayta ishlatishni osonlashtirish uchun komponent darajasidagi holatni argument sifatida qabul qiladigan funksiyalarni props sifatida berish keng tarqalgan pattern’dir. Keling, oddiy misolni ko'rib chiqamiz: Bu yerda deb nomlangan prop borligini ko'rishimiz mumkin, bu qiymat sifatida funksiyani qabul qiladi. Bu prop hatto ba'zi JSX belgilarini chiqaradi, aslida bu render qilinadi. Lekin nega? ichki tarzda foydalanuvchining oynasi o'lchamini hisoblash uchun qandaydir \"sehr\" bajaradi va keyin ni chaqiradi, e'lon qilgan tuzilmani qaytarish uchun ichki state’dan foydalanib, oyna o'lchamini ko'rsatadi. komponenti misoli Keling, yaxshiroq tushunish uchun ni ko'rib chiqaylik: Ushbu misoldan ko'rish mumkinki, har safar o'lcham o'zgarganda ma'lumotlarni saqlash uchun event listener’dan foydalanadi, lekin komponentning o'zi interfeysga ega emas, shuning uchun \"headless\" deb nomlanadi, ya'ni qanday UI ko'rsatishi kerakligi haqida bilmaydi. Bu boshqaruvni uni render qilayotgan ota komponentga topshiradi va o'ziga berilgan _render prop_’ni chaqiradi, ya'ni render qilish ishini ota komponentga topshiradi. Bu pattern, oyna o'lchamiga bog'liq komponentga bloklarini takrorlamasdan ushbu ma'lumotni olishga yordam beradi va kodimizni biroz ko'proq DRY (Takrorlanmas Kod, \"Don't repeat yourself\") saqlaydi. Biroq, bu pattern hozirgi kunda unchalik ommalashmagan va React hook’lari bilan samarali tarzda almashtirilgan. Funksiya sifatida children Chunki ham prop hisoblanadi, ba'zi dasturchilar prop nomini butunlay olib tashlashni afzal ko'rishadi va o'rniga faqat dan foydalanishadi. Bu dan foydalanishni quyidagicha o'zgartiradi: Ba'zi React mualliflari bu yondashuvni afzal ko'rishadi, chunki bu kodning maqsadiga yaqinroq: bu holda biroz \"React context\"ga o'xshab ketadi va nima ko'rsatayotganimiz \"context\"ni iste'mol qilayotgan \"children\" kabi ko'rinadi. Shunga qaramay, React hook’lari ushbu pattern’ga bo'lgan ehtiyojni umuman yo'q qiladi, shuning uchun ehtiyotkorlik bilan yondashish kerak.",
    "url": "/books/fluent-react/powerful-patterns/render-props/page",
    "category": "books",
    "tags": [
      "fluent-react",
      "tutorial",
      "guide",
      "react",
      "javascript",
      "frontend",
      "uchun",
      "react",
      "sifatida",
      "pattern",
      "prop",
      "render",
      "dan",
      "props",
      "ushbu",
      "komponentga",
      "jsx",
      "haqida",
      "qayta",
      "qabul",
      "keling"
    ]
  },
  {
    "id": "book-fluent-react-powerful-patterns-state-reducer-page",
    "title": "React'da State Reducer Patterni: Komponentlarni Moslashuvchan Qilish",
    "content": "State reducer _State reducer_ pattern’i React’da Kent C. Dodds (@kentcdodds) tomonidan ixtiro qilingan va mashhur qilingan. U React bo'yicha eng taniqli va tajribali muhandislar va o'qituvchilar qatoriga kiradi hamda bu sohada dunyo miqyosida tan olingan mutaxassisdir. Ushbu pattern moslashuvchan va sozlanadigan komponentlar yaratishning kuchli usulini taqdim etadi. Bu tushunchani real hayotdagi misol bilan ko'rsatib beramiz: tugmachani yoqish/o'chirish komponenti. Ushbu misol asosiy tugmachani yoqish/o'chirish komponentini qanday qilib yanada kengaytirish mumkinligini va uning state logikasini sozlash uchun foydalanuvchilarga imkoniyat berishni namoyish etadi. Masalan, komponentni haftaning ayrim kunlarida ba'zi biznes sabablari tufayli o'chirib qo'yish. komponentida ushbu pattern’ni qo'llash Dastlab, biz hook’idan foydalanib, asosiy tugmachani yoqish/o'chirish komponentini yaratamiz. Komponent o'z holatini saqlaydi va tugma yoqilgan yoki o'chirilgan holatda ekanligini belgilaydi. Dastlabki state qilib o'rnatiladi, bu esa holatini anglatadi: _State reducer_ pattern’ini amalga oshirish uchun komponentini nomli prop’ni qabul qilish uchun o'zgartiramiz. Ushbu prop komponentning ichki state logikasini sozlash yoki kengaytirish imkonini beradi. Komponentning funksiyasi ichki reducer logikasini props’i orqali taqdim etilgan tashqi reducer bilan birlashtiradi: Bu kod qismi orqali prop komponentning ichki state logikasini sozlash uchun ishlatilishini ko'rishimiz mumkin. funksiyasi hozirgi state va action obyekti bilan chaqiriladi, ammo biz action’ga qo'shimcha sifatida metadata sifatida xususiyatini qo'shamiz. Bu xususiyati komponentning ichki reducer tomonidan hisoblangan keyingi state’ini o'z ichiga oladi. Bu tashqi reducer’ga komponentning keyingi state’ini ko'rish va unga asoslangan qarorlar qabul qilish imkonini beradi. Endi ushbu pattern asosida komponentini maxsus xatti-harakatlar bilan qanday ishlatish mumkinligini ko'rib chiqamiz. Quyidagi misolda komponenti dan foydalanadi va maxsus ni taqdim etadi. Ushbu reducer’da chorshanba kuni tugmani o'chirib qo'yishni taqiqlovchi mantiq mavjud, chunki ushbu ilovaning joylashuvida chorshanba \"umumiy o'chirish mumkin bo'lmagan kun\" hisoblanadi. Bu state reducer pattern’ining komponentni o'zgartirmasdan turib, uning xatti-harakatlarini moslashuvchan tarzda o'zgartirish imkonini qanday taqdim etishini ko'rsatadi: Ushbu misol bilan biz _state reducer_ pattern’ining komponentlarni yuqori darajada moslashuvchan va qayta foydalanish imkoniyatiga ega qilish kuchini ko'ramiz. Komponentning ichki state boshqaruvi bilan tashqi logikani integratsiya qilish orqali biz keng ko'lamdagi xatti-harakatlar va foydalanish holatlarini qamrab olishimiz mumkin, bu esa komponentning foydaliligini va ko'p qirraligini oshiradi.",
    "url": "/books/fluent-react/powerful-patterns/state-reducer/page",
    "category": "books",
    "tags": [
      "fluent-react",
      "tutorial",
      "guide",
      "react",
      "javascript",
      "frontend",
      "state",
      "reducer",
      "ushbu",
      "pattern",
      "komponentning",
      "bilan",
      "qilish",
      "ichki",
      "moslashuvchan",
      "taqdim",
      "chirish",
      "komponentini",
      "logikasini",
      "uchun",
      "biz"
    ]
  },
  {
    "id": "book-fluent-react-react-alternatives-angular-page",
    "title": "Angular Tahlili: O'zgarishlarni Aniqlash (Change Detection) va Signallar",
    "content": "Angular Angular, Google tomonidan ishlab chiqilgan va qo'llab-quvvatlanadigan, JavaScript freymvorklari dunyosidagi mashhur o'yinchilardan biridir. Angular to'liq, ma'lum me'yorlarga ega bo'lgan freymvork bo'lib, frontend bilan bog'liq keng qamrovli masalalar uchun o'z yechimlarini taklif etadi, bu yechimlar orasida renderlash, state menejment, routing va forma ishlovi mavjud. Angular React’dan farqli reaktivlik modelini taklif etadi. Virtual DOM farqlash(diffing) va reconciliation jarayoni o'rniga Angular o'zining \"o'zgarishlarni aniqlash\" (change detection) tizimini qo'llaydi. Angular’da har bir komponent o'z ko'rinishida o'zgarishlarni tekshiradigan o'zgarish detektori bilan jihozlangan bo'lib, bu uchun Zone.js kutubxonasidan foydalanadi. Bu jarayon haqida ko'proq ma'lumotni quyida ko'rib chiqamiz. O'zgarishlarni aniqlash (Change detection) O'zgarishlarni aniqlash — bu Angular ilova holatining o'zgargan yoki o'zgarmaganligini tekshirish va kerakli hollarda DOM yangilanishi kerakligini aniqlash jarayoni. Yuqori darajada qaralganda, Angular komponentlaringizni yuqoridan pastga qarab yurib chiqadi va o'zgarishlarni qidiradi. Angular o'zgarishlarni aniqlash mexanizmini vaqti-vaqti bilan ishga tushiradi, shunda ma'lumot modeli o'zgarishlari ilovaning ko'rinishiga aks etadi. O'zgarishlarni aniqlashni mustaqil yoki asinxron event orqali ishga tushirish mumkin. O'zgarishlarni aniqlash yuqori darajada optimallashtirilgan va samarali, ammo ilova uni juda tez-tez ishga tushirsa, sekinlashuvga olib kelishi mumkin. Ushbu tizim kuchli va moslashuvchan vositadir, shuningdek, Angular turli xil ssenariylar uchun ishlashni optimizatsiyalash maqsadida uning xatti-harakatlarini puxta sozlash uchun bir nechta strategiyalarni taklif etadi. Shablon sintaksisi (Template syntax) Angular, Vue singari, shablon sintaksisidan foydalanadi, ammo DOM bilan ishlash uchun yanada kuchli direktivalar va konstruksiyalarni taklif etadi, masalan, elementlarni shartli ravishda renderlash uchun va ro'yxatlarni renderlash uchun . Bu React’dan farq qiladi, chunki React dinamik ma'lumotlarni renderlash uchun JSX va uni ichida JavaScript ifodalari ishlatiladi. Signallar Angular fundamental o'zgarishlarni boshdan kechirmoqda, bunda kirli tekshiruvlar(dirty-checking)dan voz kechib, o'zining reaktivlik primitivi bo'yicha yechimini taqdim etmoqda. _Angular Signal API_ quyidagicha ko'rinadi: _Vue refs_ bilan solishtirganda, Angular’ning getter’ga asoslangan API uslubi Vue komponentlarida foydalanilganda qiziqarli ijobiy va salbiy jihatlarini taqdim etadi: - ishlatish dan ko'ra kam batafsilroq bo'ladi, ammo qiymatni yangilash biroz batafsilroq. - Hech qanday _ref-unwrapping_(qiymatlarni avtomatik ochish) mavjud emas: qiymatni olish har doim bilan amalga oshiriladi. Bu qiymat olishni har yerda izchil qiladi. Bu, shuningdek, oddiy signallarni komponent parametrlariga to'g'ridan-to'g'ri uzatishga imkon beradi. Angular murakkab ilovalarni yaratish uchun keng qamrovli vositalarni taqdim etuvchi universal vosita sifatida tanilgan. Uning qat'iy qoidalari bir tomondan kod strukturasi va izchilligini ta'minlash bilan kuchli tomon hisoblanadi, boshqa tomondan esa yangi dasturchilar uchun o'rganish jarayonini qiyinlashtiradi va moslashuvchanlikni cheklaydi.",
    "url": "/books/fluent-react/react-alternatives/angular/page",
    "category": "books",
    "tags": [
      "fluent-react",
      "tutorial",
      "guide",
      "react",
      "javascript",
      "frontend",
      "angular",
      "uchun",
      "zgarishlarni",
      "bilan",
      "aniqlash",
      "etadi",
      "taklif",
      "renderlash",
      "dan",
      "react",
      "dom",
      "change",
      "detection",
      "har",
      "bir"
    ]
  },
  {
    "id": "book-fluent-react-react-alternatives-common-patterns-page",
    "title": "Zamonaviy JavaScript Freymvorklaridagi Umumiy Patternlar",
    "content": "Umumiy pattern’lar Bu texnologiyalarning barchasi — React, Angular, Qwik, Solid va Svelte — veb uchun boy, interaktiv foydalanuvchi interfeyslarini yaratish uchun mo'ljallangan yechimlar hisoblanadi. Ular o'zlarining falsafasi, metodologiyasi va amalga oshirish tafsilotlari bo'yicha farqlansalar-da, ularning umumiy maqsadlarini aks ettiruvchi bir nechta umumiy jihatlar mavjud. Komponentga asoslangan arxitektura Ushbu freymvorklar va kutubxonalar orasidagi asosiy umumiyliklardan biri komponentga asoslangan arxitektura qabul qilinganligidir. Komponentga asoslangan arxitekturada foydalanuvchi interfeyslari kichik qismlarga, ya'ni komponentlarga bo'linadi, va har bir komponent foydalanuvchi interfeysining aniq bir qismi uchun javobgardir. Komponentlar o'z state’i va logikasini o'z ichida saqlaydi va ulardan murakkab foydalanuvchi interfeyslarini yaratish uchun kompozitsiya qilish mumkin. Ushbu modullilik kodni qayta ishlatish, ma'suliyatlarni ajratish va qo'llab-quvvatlash imkoniyatini yaxshilaydi. Ushbu freymvorklarning har birida komponentlar funksional bo'lishi mumkin va ular ko'pincha murakkab komponentlarni yaratish uchun birlashtirilishi, kengaytirilishi yoki bezatilishi mumkin. Deklarativ sintaksis React, Angular, Qwik, Solid va Svelte UI’larni belgilash uchun deklarativ sintaksisdan foydalanadi. Deklarativ yondashuvda dasturchilar UI ma'lum bir holat uchun qanday ko'rinishga ega bo'lishi kerakligini aniqlaydi, va freymvork o'sha holatga mos ravishda UI’ni yangilashni amalga oshiradi. Bu, UI yaratishda DOM manipulyatsiyalarini mustaqil bajarish zaruriyatini yo'q qiladi va dasturchilarni qiyin va xatolarga moyil bo'lgan jarayondan qutqaradi. Ushbu texnologiyalarning barchasi deklarativ UI yozish uchun o'ziga xos shablon tilini taqdim etadi. React, Qwik va Solid JSX’dan foydalanadi; Angular o'zining HTML’ga asoslangan shablon sintaksisidan foydalanadi; Svelte esa HTML’dan ilhomlangan tilga ega. Yangilanishlar Ushbu kutubxonalar va freymvorklar barchasi dastur holatidagi o'zgarishlarga javob berish va foydalanuvchi interfeysini mos ravishda o'zgartirish mexanizmini taqdim etadi. React va Vue yangilanishlarni amalga oshirish uchun virtual DOM (vDOM) farqlash algoritmidan foydalanadi. Boshqa tomondan, Svelte komponentlarni DOM’ni to'g'ridan-to'g'ri yangilaydigan imperativ kodga kompilyatsiya qiladi. Angular esa, zonalar va kuzatiladiganlar(observables)ga asoslangan o'zgarishlarni aniqlash mexanizmidan foydalanadi. Tez orada deyarli faqat React vDOM’dan foydalanishi va boshqa barcha freymvorklar turli xil signal usullaridan foydalanishi mumkin. Usullar turli bo'lsa-da, maqsad bir xil: holat o'zgarishlariga javoban UI’ni samarali yangilash, murakkab DOM manipulyatsiyasini yashirib, dasturchilarni asosan dastur logikasiga e'tibor qaratishga imkon berish. Lifecycle metodlari React, Angular, Solid va Svelte komponentlarning turli lifecycle(hayotiy sikl)larida chaqiriladigan lifecycle metodlari yoki hook’larni taqdim etadi. Bu funksiyalar komponent birinchi marta yaratilganda, yangilanganida yoki DOM’dan olib tashlanishidan oldin chaqiriladi. Dasturchilar ushbu metodlardan side effect’lar hosil qilish, resurslarni tozalash yoki props o'zgarishlariga qarab yangilanishlar kiritish uchun foydalanishi mumkin. Ekotizim va vositalar Har bir freymvork va kutubxona boy vositalar, kutubxonalar va resurslar ekotizimi bilan qo'llab-quvvatlanadi. Ular barcha zamonaviy JavaScript xususiyatlarini, jumladan ES6 sintaksisi, modullar, va Webpack hamda Babel kabi qurish vositalarini qo'llab-quvvatlaydi. Ular TypeScript bilan yaxshi mos keladi, bu esa dasturchilarga turli xatolardan himoyalangan kod yozish va TypeScript’ning kuchli xususiyatlaridan foydalanish imkonini beradi. Ushbu texnologiyalarning aksariyati yoki o'ziga xos dasturchi vositalari, yoki osonlik bilan mavjud dastur xatolarini tuzatish va profiling qilish vositalariga ega. Misol uchun, React va Angular’ning mashhur brauzerlar uchun dasturchi vositalari bunga yaxshi misol bo'la oladi. React, Angular, Qwik, Solid va Svelte o'ziga xos kuchli tomonlar va falsafalarga ega bo'lsa-da, ularning umumiy maqsadlari bir xil: komponentga asoslangan arxitekturani taqdim etish, deklarativ UI’ni yaratish imkonini berish, holat o'zgarishlariga reaktivlikni ta'minlash, event’larni boshqarishni soddalashtirish, lifecycle metodlarini taqdim etish va boy JavaScript ekotizimi hamda zamonaviy dasturiy ta'minot vositalarini qo'llab-quvvatlash. Bu xususiyatlar va tushunchalar to'plami veb-dasturlashni yanada modulli, deklarativ va reaktiv paradigmalar tomon rivojlanishining dalili hisoblanadi.",
    "url": "/books/fluent-react/react-alternatives/common-patterns/page",
    "category": "books",
    "tags": [
      "fluent-react",
      "tutorial",
      "guide",
      "react",
      "javascript",
      "frontend",
      "uchun",
      "react",
      "angular",
      "bir",
      "ushbu",
      "svelte",
      "asoslangan",
      "yoki",
      "deklarativ",
      "umumiy",
      "solid",
      "foydalanuvchi",
      "mumkin",
      "foydalanadi",
      "dom"
    ]
  },
  {
    "id": "book-fluent-react-react-alternatives-future-of-react-page",
    "title": "React'ning Kelajagi: Signallar va 'React Forget' Kompilyatori",
    "content": "React’ning kelajagi Reaktiv primitivlar, masalan, signal kabi texnologiyalarning keng tarqalgan qabul qilinishi bilan, ba'zilar React ham shunga o'xshash yondashuvni qabul qilishi mumkin deb o'ylashlari mumkin. Biroq, React jamoasi signalga \"hayajonlanmaganligini\" bildirgan va signallar taqdim etadigan shunga o'xshash ishlash samaradorligi afzalliklariga erishish uchun muqobil yondashuvni tanlashlarini bildirgan. Buni biroz yaxshiroq tushunish uchun, React haqida o'rgangan ba'zi narsalarni misol bilan ko'rib chiqaylik. Quyidagi komponentni ko'rib chiqamiz: Bu juda oddiy misolda, bizda deb nomlangan state’ga ega bo'lgan komponent mavjud, unda bir nechta bolalar mavjud: - Joriy hisobni ko'rsatuvchi elementi - Hisobni oshiradigan elementi - Ko'p hisoblashlarni bajaradigan qimmatli _children_’ni render qiladigan komponenti Endi, agar biz hisobni oshirish uchun tugmani bosamiz, nima bo'ladi? funksiyasi chaqiriladi/yangidan chaqiriladi/yangi render qilinadi, bu bilan uning barcha bolalari ham yangilanadi. Bu React’ning default xatti-harakatidir. Demak, komponenti ham yangilanadi, garchi u yangilanishi shart bo'lmasa: uning props yoki state’i o'zgarmagan taqdirda ham! React’ning va kam tafsiliy darajali reaktivligi Bu kam tafsiliy darajadagi reaktivlik React'ni potensialidan kam samarali qiladi. Biroq, bu muammoni juda oson hal qilish mumkin: biz faqat kerakli joyda va kerakli vaqtda dan foydalanishimiz kerak: Bu ishlaydi, chunki biz dan har doim kerakli joyda foydalanishni eslaymiz. Haqiqatan ham, bu signallar bilan bir xil yuqori tafsiliy darajali reaktivlikni taqdim etadi. Biroq, bu signallarga nisbatan qulay emas, chunki har doim dan foydalanishni eslab qolishimiz kerak. Signal va React jamoasi yondashuvi Ko'pchiligimiz, signallar bu muammoni oson hal qilishi mumkin deb o'ylashimiz mumkin, lekin Meta kompaniyasidagi React jamoasi signallar, kabi, kundalik dasturchilar uchun amalga oshirish tafsiloti bo'lishi kerak, deb hisoblaydi va React’dan foydalanadigan kundalik dasturchilar bu haqda o'ylamasligi kerak. Ular React’ning dastlabki qiymat taklifiga quloq solishadi: “UI’ni deklarativ tarzda tasvirlab bering, React esa qolganini amalga oshirsin.” React jamoasi, dasturchilar signallar, , yoki boshqa tafsilotlarga bog'lanib qolmasligini va React UI’ni eng optimal tarzda render qilishini ta'minlashini maqsad qilishadi. Yangi Dastur: React Forget Bu maqsadga erishish uchun jamoa yangi dastur ustida ishlamoqda: React Forget. Bu dastur orqali React UI’ni yanada samarali va intuitiv tarzda yaratishga yordam beradi, shunda dasturchilar ko'proq murakkablikni hisobga olishlari shart emas.",
    "url": "/books/fluent-react/react-alternatives/future-of-react/page",
    "category": "books",
    "tags": [
      "fluent-react",
      "tutorial",
      "guide",
      "react",
      "javascript",
      "frontend",
      "react",
      "signallar",
      "ning",
      "ham",
      "mumkin",
      "uchun",
      "bilan",
      "deb",
      "jamoasi",
      "dan",
      "kerak",
      "dasturchilar",
      "biroq",
      "hisobni",
      "render"
    ]
  },
  {
    "id": "book-fluent-react-react-alternatives-page",
    "title": "React Alternativlari: Vue, Angular, Svelte, Solid va Qwik",
    "content": "React alternativlari Oldingi bobda biz React Server Components (RSCs) haqida batafsil ma'lumot berdik. Ushbu komponentlarning qanday ishlashi, qachon ulardan foydalanish kerakligi va nima uchun kelgusi avlod dasturlar to'plamlari, yo'riqnoma tizimlari kabi kuchli vositalarga muhtoj ekanligi haqida o'rgandik. Shuningdek, server komponentlari va server tomonidan renderlash o'rtasidagi farqlarni ham muhokama qildik. RSC mexanizmini chuqurroq tushunish uchun oddiy RSC renderer yaratdik. React va uning ekotizimidan alternativlarni o'rganishga o'tayotganimizda, freymvork va server komponentlarining rolini tushunish bizga foydali kontekst beradi. Ushbu bobda muhokama qiladigan har bir kutubxona ham o'ziga xos freymvorklarni taqdim etadi, va React’da ko'rib chiqqan tamoyillar ham bu ekotizimlarda qo'llanilishi mumkin. Endi diqqatimizni React va uning ekotizimidan chetga olib, frontend rivojlanish ekotizimidagi mashhur alternativlarga — Vue.js, Angular, Svelte, Solid va Qwik kutubxonalariga o'taylik. Har bir kutubxona va freymvork o'ziga xos reaktivlik modelini va UI ishlab chiqishiga o'ziga xos yondashuvlarni taqdim etadi. Ushbu turli modellarning farqlarini tushunish fikr doiramizni kengaytirishi va loyihalarimizdagi muammolarni hal qilish uchun ko'proq vositalarni taqdim etishi mumkin.",
    "url": "/books/fluent-react/react-alternatives/page",
    "category": "books",
    "tags": [
      "fluent-react",
      "tutorial",
      "guide",
      "react",
      "javascript",
      "frontend",
      "react",
      "server",
      "ushbu",
      "uchun",
      "ham",
      "tushunish",
      "ziga",
      "xos",
      "taqdim",
      "alternativlari",
      "bobda",
      "haqida",
      "muhokama",
      "rsc",
      "uning"
    ]
  },
  {
    "id": "book-fluent-react-react-alternatives-qwik-page",
    "title": "Qwik Tahlili: Resumability (Davom Ettiruvchanlik) va O(1) Freymvork",
    "content": "Qwik Qwik — bu veb sahifalarni yuklashni optimizatsiyalash va foydalanuvchi interaktivligi hamda javob beruvchanligini ustuvor qilishga mo'ljallangan noyob freymvork. An'anaviy freymvorklardan farqli o'laroq, u veb sahifalarni mustaqil yuklanishi va talabga binoan o'zaro aloqada bo'lishi mumkin bo'lgan komponentlar to'plami sifatida ko'radi. Ushbu yondashuv sahifaning dastlabki yuklanish vaqtini sezilarli darajada qisqartiradi va umumiy foydalanuvchi bilan ishlash qulayligini yaxshilaydi. Qwik bilan qurilgan veb ilovalar va saytlar juda kichik va doimiy dastlabki JavaScript hajmini (~1 kB) o'z ichiga oladi. Qwik saytining dastlabki yuklanadigan JavaScript miqdori doimiy, chunki bu Qwik yuklovchisi(loader)dir. Shu sababli, Qwik ba'zi doiralarda \"O(1) freymvork\" sifatida tanilgan, ya'ni ilovaning hajmiga qaramay, doimiy o'zgarmas yuklanish vaqtiga ega. Dastlab, Qwik minimal JavaScript miqdorini yuklaydi, lekin keyinchalik kerak bo'lganda komponentlar va boshqa xatti-harakatlarni yuklaydi. Ushbu yondashuv Qwik’ga eng muhim komponentlarni birinchi bo'lib yuklashni ustuvor qilish imkonini beradi, bu esa tezroq dastlabki yuklanish va tezkor foydalanuvchi bilan ishlash qulayligini ta'minlaydi. Davom ettiruvchanlik(resumability) xususiyati Qwik’ning muhim xususiyati resumability (davom ettiruvchanlik qobiliyati)dir. Biz resumability’ni 6-bobda _server tomonidagi React_ bobimizda ko'rib o'tgandik, lekin takrorlash uchun: resumability — bu serverda render qilingan sahifaning dastlabki holatining snapshot’ini klientga yuborish jarayonidir. Foydalanuvchi sahifani ochganda, ular ushbu statik snapshot bilan interaktivlikka kirishib turadi, keyin esa ko'proq interaktivlikka ehtiyoj tug'ilganda turli xatti-harakatlar talabga binoan yuklanadi. Ushbu mexanizm foydalanuvchiga tezkor interaktivlik imkonini beradi, bu ko'plab boshqa freymvorklarda mavjud emas. _Davom ettiruvchanlik_ hidratsiyadan ancha ustun hisoblanadi, chunki u komponentlarni ikki marta render qilishni talab qilmaydi. Bu shuningdek, server tomonidan render qilingan markup brauzerga o'tgandan so'ng va JavaScript sahifani yuklab olib hidratsiya qilgunga qadar bir vaqt davomida interaktiv bo'lmagan veb-saytlarning \"ga'yrioddiy vodiy\" holatidan qochishga yordam beradi. Qwik esa darhol ishga tushadi. Qwik’ning boshqa freymvorklar bilan solishtirilishi Qwik’ni React, Vue, Svelte yoki Solid kabi mashhur freymvorklar bilan taqqoslaganda bir qator farqlar yuzaga chiqadi. React va Vue ham komponentlarga asoslangan yondashuvni qabul qilsa-da, agar biz _code-splitting_ texnikasini ishlatishda ehtiyot bo'lmasak, dastur uchun butun JavaScript to'plam paketini klientga birinchi navbatda yuborishimiz mumkin, bu esa ba'zan ko'plab megabaytlar zonasiga olib kelishi mumkin. Ushbu jarayon, ayniqsa katta ilovalar uchun, dastlabki yuklanish vaqtining uzayishiga sabab bo'lishi mumkin. Qwik esa, aksincha, faqat kerak bo'lganda komponentlar va event’larni yuklaydi, natijada tezroq dastlabki yuklanish va yanada tezroq javob beruvchanlikni ta'minlaydi. Qwik, shuningdek, dastlabki yuklashda barcha kerakli elementlarni oldindan yuklab olishni o'z ichiga olgan holda, kerakli vaqtda yuklanadigan elementlar uchun oldindan yuklashni juda aqlli qiladi, shunday qilib, hamma narsa dastlabki yuklashda oldindan yuklanadi, lekin faqat talabga binoan tahlil qilinadi va bajariladi. Qwik, Svelte va Solid kabi, ishlash samaradorligiga e'tibor beradi, lekin buni turli usullar bilan amalga oshiradi. Svelte komponentlarni bevosita DOM’ni manipulyatsiya qiladigan juda samarali imperativ kodga kompilyatsiya qiladi, Solid esa komponentlar uchun yuqori tafsiliy darajali reaktivlik modelidan foydalanadi. Qwik esa reaktiv primitivlardan foydalangan holda, komponent yuklanishini optimallashtirishga va eng muhimlarini imkon qadar tezroq mavjud bo'lishini ta'minlashga e'tibor beradi. Afzalliklari Qwik dasturchilar uchun oson va intuitiv API taqdim etadi, bu komponentlarni belgilash va ular bilan ishlashni osonlashtiradi. Qwik komponentlari sintaksis va tuzilish jihatidan deyarli React komponentlariga o'xshashdir, chunki ular ham JSX (yoki TSX) yordamida ifodalanadi. Bu o'xshashlik dasturchilar uchun Qwik bilan ishlashni osonlashtiradi, ayniqsa, agar ular allaqachon React bilan tanish bo'lsalar. Qwik shuningdek, React bilan hamkorlik imkoniyatini taqdim etadi, bu esa dasturchilarga React komponentlarini Qwik ilovalarida yordamchi funksiyasi orqali ishlatish imkonini beradi. Bu hamkorlik, Qwik’dan foydalanmoqchi bo'lgan, lekin React kutubxonalarining boy ekosistemasi va vositalaridan foydalangan holda ishlashni xohlagan dasturchilar uchun muhim afzallikdir. Qwik komponentga asoslangan va event’ga yo'naltirilgan arxitekturasi bilan zamonaviy veb-ishlab chiqishga yangicha yondashuvni taqdim etadi. Davom ettiruvchanlik va yuklashni ustuvor qilishga qaratilgan e'tibor uni React, Vue, Svelte va Solid kabi boshqa freymvorklardan farqli qiladi. Ushbu vositalarning har biri o'zining kuchli tomonlari va ishlatilish sohalariga ega, lekin Qwik’ning noyob xususiyatlari uni veb-ishlab chiqish freymvorklari maydoniga qiziqarli qo'shimcha sifatida ajratadi. U yuqori ishlash samaradorligi, foydalanuvchi markazida va samarali tarzda veb-ilovalarni yaratish uchun to'g'ri tanlov bo'lishi mumkin. Kamchiliklari Qwik’ning yagona kamchiligi shundaki, u hali ham nisbatan yangi va React, Vue yoki Angular kabi rivojlangan ekosistemaga ega emas. Biroq, u tezda rivojlanmoqda va o'sib borayotgan dasturchilar va hissadorlar jamoasiga ega. Qwik rivojlanishda davom etar ekan, uning boshqa freymvorklar bilan solishtirilishi va yanada kuchli ilovalarni yaratish uchun qanday ishlatilishi qiziq bo'ladi.",
    "url": "/books/fluent-react/react-alternatives/qwik/page",
    "category": "books",
    "tags": [
      "fluent-react",
      "tutorial",
      "guide",
      "react",
      "javascript",
      "frontend",
      "qwik",
      "bilan",
      "uchun",
      "dastlabki",
      "react",
      "esa",
      "veb",
      "ushbu",
      "lekin",
      "beradi",
      "foydalanuvchi",
      "mumkin",
      "yuklanish",
      "javascript",
      "boshqa"
    ]
  },
  {
    "id": "book-fluent-react-react-alternatives-react-forget-page",
    "title": "React Forget: Avtomatik Memoizatsiya Kelajagi",
    "content": "React Forget Forget — bu React uchun linterni andozasiga o'xshash bir vositalar to'plami bo'lib, uning bayrog'i faollashtirilgan. Bu React qoidalarini majburan amalga oshiradi va keyin avtomatik ravishda React kodini dastur lifecycle’i davomida o'zgarmaydigan qiymatlarni, masalan, ni aqlli tarzda memoizatsiya qilib, optimal holatga aylantiradi. React qoidalari sababli, Forget kompilyatori bu qiymatlarni oldindan taxmin qila olishi va biz uchun memoizatsiya qilishi mumkin. Bu Svelte’dan olingan o'xshash yondashuvdir, lekin imperativ kodga kompilatsiya qilish o'rniga, Forget yanada samarali React kodiga kompilatsiya qiladi. React qoidalari React qoidalarini qaytadan ko'rib chiqamiz: 1. React komponentlari sof(pure) funksiyalar bo'lishi kerak. 2. Ba'zi hook’lar va maxsus event handler’lar sof bo'lishi shart emas. 3. Sof funksiyalar ichida taqiqlangan harakatlar: - Funksiya ichida yangi yaratilmagan o'zgaruvchilar/obyektlarni o'zgartirish. - O'zgarishi mumkin bo'lgan xususiyatlarni o'qish. 4. Ruxsat berilgan harakatlar: - Props yoki state’ni o'qish. - Xatolarni chiqarish. - Yangi yaratilgan obyektlarni/binding’larni o'zgartirish. 5. Kerakli vaqtda ishga tushirish (lazy initialization) — ishga tushirish maqsadida o'zgartirishga(mutatsiyaga) ruxsat beruvchi istisno. 6. Render paytida yaratilgan obyektlar yoki closure’lar render tugagandan so'ng o'zgartirilmasligi kerak, faqat state'da saqlangan o'zgaruvchilar bundan mustasno. Bu qoidalar tufayli, Forget kompilyatori qaysi qiymatlar dastur lifecycle’i davomida o'zgarmasligini oldindan taxmin qilib, ularni biz uchun memoizatsiya qila oladi. Natijada? Yuqori darajada optimallashtirilgan, samarali React kodi, boshqa kutubxonalar bilan raqobatlashadigan darajada signal ishlatadigan kutubxonalar bilan teng keladigan ishlash samaradorligini ta'minlaydi. Ushbu dokumentatsiyalar yozilishi vaqtida, Forget Meta’da baholanish jarayonida bo'lib, Instagram va WhatsApp’da foydalanishda kutilganidan yuqori natijalarni ko'rsatmoqda. Hozirda u ochiq manbali emas, lekin React jamoasi uni yaqin kelajakda ochiq manba dasturi sifatida chiqarishni ko'rib chiqmoqda. Forget va signallarni taqqoslash Forget hali ochiq manba emasligi sababli, uning afzalliklari va kamchiliklari haqida ishonchli tarzda fikr bildirish qiyin. Biroq, shuni aytishimiz mumkinki, agar Forget haqiqatan ham o'zgarmaydigan barcha qiymatlarni memoizatsiya qilsa, signallarning yuqori tafsiliy darajali reaktivligi React Forget bilan kam tafsiliy darajali reaktivlikdan ustun bo'lishi mumkin, chunki signallar komponentlar ierarxiyasidan tashqarida parallel olamda yashaydi. Shunday qilib, yangilanish sodir bo'lganda, React hali ham butun komponent daraxti bo'ylab yurib chiqishi va har bir komponentning props’larining yangi va eski qiymatlarini taqqoslab, qaysi komponentlarning qayta render qilinishi kerakligini aniqlashi kerak. Bu signallar bilan bunday emas; signallar bilan UI’ning faqat reaktiv qismlari yangilanadi va butun daraxtni yurib chiqishga hojat qolmaydi. Bu dastlabki ma'lumotlar shuni ko'rsatadiki, hatto Forget bilan ham, React signallar standart bo'lgan kutubxonalarga nisbatan sekinroq bo'lishi mumkin, ammo bu haqida aytish uchun hali erta.",
    "url": "/books/fluent-react/react-alternatives/react-forget/page",
    "category": "books",
    "tags": [
      "fluent-react",
      "tutorial",
      "guide",
      "react",
      "javascript",
      "frontend",
      "react",
      "forget",
      "bilan",
      "memoizatsiya",
      "uchun",
      "mumkin",
      "lishi",
      "signallar",
      "qiymatlarni",
      "qilib",
      "sof",
      "kerak",
      "lar",
      "emas",
      "yangi"
    ]
  },
  {
    "id": "book-fluent-react-react-alternatives-react-is-not-reactive-page",
    "title": "React Reaktiv Emas: Reaktivlik Modellari Tahlili",
    "content": "React reaktiv emas Dasturlash dunyosida \"reaktiv\" atamasi turli narsalarni ifodalash uchun ishlatiladi, ammo odatda ma'lumotlar o'zgarishlariga avtomatik ravishda javob beruvchi tizimlarni tavsiflash uchun qo'llaniladi. Reaktiv dasturlash paradigmasi o'zgarishlarga javob beruvchi tizimlarni yaratishga va ushbu o'zgarishlarni tizim bo'ylab avtomatik ravishda tarqatishga qaratilgan. Shu sababli Vue.js va Svelte kabi freymvorklar ko'pincha reaktiv sifatida ta'riflanadi. Biroq, React an'anaviy reaktiv modelga amal qilmaydi va uning yondashuvi tubdan farq qiladi. React foydalanuvchi interfeyslarini deklarativ tarzda yaratish uchun kutubxona sifatida paydo bo'lgan. Bu deklarativ uslub, React dasturchilarga faqat nimani xohlashini tavsiflash imkonini beradi va React qanday qilishni o'zi hal qiladi. React dasturchilarga joriy state’ga asoslangan foydalanuvchi interfeysini tavsiflash imkonini beradi va har safar state o'zgarganda UI’ni yangilaydi. Bu tavsif React’ni reaktivdek ko'rsatishi mumkin, ammo uning ichki mexanizmlariga chuqurroq kirishganimizda, React’ning modeli an'anaviy reaktiv dasturlash modelidan tubdan farq qilishini ko'ramiz. An'anaviy reaktiv tizim React’ning nima uchun an'anaviy reaktiv bo'lmasligini tushunish uchun, avval an'anaviy reaktivlikning qanday ishlashiga qaraylik. An'anaviy reaktiv tizimda hisob-kitoblar orasidagi qaramliklar avtomatik ravishda kodni ishlatishda kuzatiladi. Reaktiv qaramlik o'zgarganda, unga bog'liq barcha hisob-kitoblar o'zgarishni aks ettirish uchun avtomatik ravishda qayta bajariladi. Bu odatda ma'lumotlar bog'lanishi (data-binding), kuzatiluvchilar (observables), yoki signal va slotlar kabi texnikalar yordamida amalga oshiriladi. Masalan, signal - bu reaktiv qiymat yaratish uchun ishlatiladigan reaktiv primitiv. O'qilganda signal o'quvchini obuna qiladi, yozishda esa barcha obunachilarga bildirishnoma yuboriladi. Bu reaktivlikning asosiy qoidasi (Reactivity 101) hisoblanadi. Reactning yondashuvi React state va uning yangilanishlarini boshqarish uchun boshqacha yondashuvni qo'llaydi. Qaramliklarni avtomatik ravishda kuzatish va o'zgarishlarni tarqatish o'rniga, React state’ni yangilash uchun yanada aniqroq mexanizmni - hook’ni kiritadi. State o'zgarganda, React darhol yangilanishlarni amalga oshirmay, qayta render qilishni rejalashtiradi va ushbu qayta render jarayonida butun komponent funksiyasi yangi state bilan qayta ishlaydi. Reactning bu usuli reaktiv tizimlardan farq qilib, barcha qaramliklarni avtomatik kuzatmaydi va hisob-kitoblarni o'z-o'zidan qayta bajarishga asoslanmaydi. 1-misol: Counter komponenti Ushbu hisoblagich misolida kod quyidagicha yozilgan: Bu misolda chaqirilganda, funksiyasi, shu jumladan hook ham qayta chaqiriladi. Bu an'anaviy reaktiv modeldan farq qiladi. An'anaviy reaktiv tizimda, butun funksiyani qayta chaqirish o'rniga, faqat UI’ning reaktiv qismlari yangilanardi. Bu holda faqat ichidagi yangilanishi kerak edi. Bu \"yirik darajadagi reaktivlik\" deb ataladi va bu signalning \"mayda darajadagi reaktivlik\" modeliga qarama-qarshi. React tenglamasi React ko'pincha quyidagi tenglama bilan ifodalanadi: Bu yerda, UI (v) uning state’i (s) funksiyasi sifatida aniqlanadi. Ushbu tenglama React’ning reaktiv emasligini ko'rsatadi: UI state’ning funksiyasi sifatida beriladi, lekin state o'zgarganda avtomatik ravishda yangilanmaydi. Buning o'rniga, UI faqat yangi state bilan funksiya qayta bajarilganda yangilanadi. Virtual DOM va reconciliation jarayoni Bu erda React virtual DOM’ni _diffing_ va _reconciliation_ jarayoni boshlanadi. Komponentning state’i yoki props o'zgarganda, React komponentni qayta render qiladi va yangi virtual DOM quyi daraxtini yaratadi. Keyin u yangi daraxtni eski daraxt bilan solishtiradi, real DOM’da kerakli minimal o'zgarishlarni aniqlaydi va ularni qo'llaydi. Bu jarayon Reactning state’ni yangilash va UI o'zgarishlarini samarali ravishda boshqarishiga yordam beradi, lekin u an'anaviy reaktiv modelga o'xshamaydi, chunki UI avtomatik tarzda yangilanmaydi va butun funksiyani qayta chaqirish talab qilinadi. Bu modelda state aniq o'rnatilib, qayta render qilinadi. Boshqa reaktiv tizimlardan farqli ravishda o'zgarishlar avtomatik ravishda tarqatilmaydi, bu esa oldindan ko'ra olish imkoniyatini oshiradi. Agar React inson qiyofasida tasavvur qilinsa, u shunday deya oladi: “Menga state kutishlaringizni ayting, men uni boshqaraman.” Bu yondashuv state yangilanishlarini guruhlash kabi xususiyatlarini yoqadi va ilova state’ini istalgan vaqtda tushunishni osonlashtiradi, chunki state yangilanishi va natijadagi UI yangilanishi yagona, atom operatsiyasida bog'langan bo'ladi. Biroq, bu model React komponentlarini an’anaviy ma'nodagi reaktivlikdan uzoqlashtiradi. Ular ma'lumotlar o'zgarishlariga avtomatik tarzda reaksiyaga kirmaydi. Buning o'rniga, React aynan shu state uchun UI qanday ko'rinishi kerakligini aniqlab beradi va state o'zgarganda, kerakli yangilanishlarni amalga oshirish uchun butun funksiyani qayta ishga tushiradi. Bu, faqat mos qiymatlar joyida yangilanadigan avtomatik reaktiv tarqatishdan farq qiladi. React’ning reaktiv bo'lmagan yondashuvi React avtomatik o'zgarishlarni kuzatish va tarqatish jihatidan reaktiv bo'lmasa-da, dinamik va interaktiv foydalanuvchi interfeyslarini yaratish uchun samarali mexanizmni taqdim etadi. State va props orqali renderni boshqarish, o'zgarishlarning ilovada qanday tarqalishini tushunishda aniq va ishonchli modelni ta'minlaydi, va virtual DOM tizimi real DOM’ni samarali boshqarish uchun yangilanishlarni amalga oshiradi. Yakunida, React yondashuvi reaktivlik deb atalishi yoki atalmasligi semantikaga bog'liq. Agar reaktivlikni tizim orqali o'zgarishlarni avtomatik tarqatish deb tushunsangiz, unda, ha, React reaktiv emas. Ammo reaktivlikni tizimning state o'zgarishlariga oldindan aytib bo'ladigan va nazoratli tarzda javob berish qobiliyati sifatida tushunsangiz, unda React reaktiv deb hisoblanishi mumkin. React va boshqa freymvorklar yoki kutubxonalarni ko'rib chiqsak, UI ishlab chiqishda state va reaktivlikni boshqarishda yagona yondashuv yo'qligi aniq bo'ladi. Har bir vosita o'zining kuchli tomonlari va kamchiliklariga ega va turli holatlar uchun mos keladi. Ushbu farqlarni tushunish to'g'ri vositani tanlash uchun muhimdir va qaysi freymvork yoki kutubxonadan foydalanganingizdan qat'i nazar, samarali va effektiv kod yozishga yordam beradi. React’ning state’ni boshqarish va yangilanish modeli boshqaruv va qulaylik o'rtasidagi ajoyib muvozanatni ta'minlaydi. State’ni aniq yangilash mexanizmi dasturchilarga dastur holati haqida osonroq fikr yuritish imkonini beradi, shu bilan birga, reconciliation va farqlash(diffing) algoritmi yangilanishlarni DOM’ga samarali qo'llaydi. An'anaviy ravishda \"reaktiv\" bo'lmasa-da, React’ning yondashuvi murakkab foydalanuvchi interfeyslarini yaratishda juda samarali ekanligini isbotladi. Reaktiv dasturlash modeli va Solid misoli Reaktiv dasturlash modellari, ayniqsa, avtomatik ravishda qaramliklarni va yangilanishlarni boshqarish haqida gap ketganda, bir qator inkor etib bo'lmas afzalliklarni taqdim etadi. Ammo biz ko'rganimizdek, React yondashuvi o'zining yuqori darajadagi nazorat va oldindan ko'ra oluvchanlik qobiliyatlari bilan birga keladi. To'liq qilish uchun, endi Solid freymvorkida qanday qilib bir xil hisoblagich ko'rinishini ko'rib chiqamiz: Ushbu misolda, komponentning ma'lumotlarining reaktiv xususiyati hisoblanadi. Biz ni sifatida chaqirish orqali o'qiganimizda, bu JSX’ning ushbu qismiga reaktiv qiymatga bilvosita obuna bo'lamiz. Keyinchalik, biz ni chaqirganimda, chaqiriladi va qiymatni yangilaydi va barcha obunachilarni o'zgarish haqida xabardor qiladi, bu esa ularga yangilanishni amalga oshirishni talab qiladi. Bu, obunachi va nashr etuvchi o'rtasidagi munosabatni ifodalovchi \"pub/sub\" modeliga o'xshaydi. Natijada, yuqori tafsiliy darajadagi reaktivlik (fine-grained reactivity) yuzaga keladi: ya'ni, funksiya komponenti, , bir martadan ortiq chaqirilmaydi, lekin nozik va kichik reaktiv qiymatlar chaqiriladi. 2- misol: O'zaro bog'liq qiymatlar (Dependent values) Keling, mahsulotlar ro'yxatini va ularning sonini ko'rsatadigan komponentni ko'rib chiqamiz. Svelte kabi reaktiv tizimda, ro'yxat o'zgarganda, son avtomatik ravishda yangilanadi: Bu yerda reaktiv bayonotni e'lon qiladi. o'zgarganda, avtomatik ravishda qayta hisoblanadi. React’da bu biroz boshqacha ko'rinadi: Bu React komponentida, qiymati o'zgarganda avtomatik yangilanadigan reaktiv qiymat emas. Buning o'rniga, bu joriy state’dan yaratilgan qiymat bo'lib, u render bosqichida hisoblanadi. o'zgarganda, biz ni chaqirib, state’ni yangilashimiz va qayta render qilishimiz kerak. Bu vaqtda qayta hisoblanadi, lekin bu reaktiv bo'lganligi sababli emas, balki funksiya komponenti qayta chaqirilganda bo'ladi.",
    "url": "/books/fluent-react/react-alternatives/react-is-not-reactive/page",
    "category": "books",
    "tags": [
      "fluent-react",
      "tutorial",
      "guide",
      "react",
      "javascript",
      "frontend",
      "reaktiv",
      "react",
      "state",
      "avtomatik",
      "uchun",
      "qayta",
      "ravishda",
      "anaviy",
      "zgarganda",
      "qiladi",
      "ning",
      "ushbu",
      "dom",
      "sifatida",
      "yondashuvi"
    ]
  },
  {
    "id": "book-fluent-react-react-alternatives-recap-page",
    "title": "React Alternativlari Xulosasi: Angular, Vue, Svelte, Solid va Qwik",
    "content": "Bo'limni qisqacha takrorlash Ushbu bob 9-bobga nazar tashlashdan boshlandi, unda biz RSC’larni batafsil ko'rib chiqdik. Keyin esa React’dan tashqari JavaScript freymvorklarining keng olamini, jumladan Angular, Vue, Svelte, Solid va Qwik’ni o'rganishga kirishdik, bu kutubxonalar va freymvorklar o'rtasidagi farqlar va o'xshashliklarni tushunishga qaratilgan. Biz Vue.js’ga nazar tashladik va uning UI qurishda deklarativ yondashuvni qanday qo'llashi va komponentlar asosidagi arxitekturasi orqali kuchli vazifalarni ajratishni qanday rag'batlantirishini o'rganib chiqdik. Keyin Angular, Svelte, Solid va Qwik’ga kirishib, ularning o'ziga xos xususiyatlari va falsafalarini o'rganib chiqdik. Ularning ma'lumotlardagi o'zgarishlarga javoban UI’ni avtomatik ravishda yangilash uchun reaktiv primitivlardan qanday foydalanishini va bu jihatdan React’dan qanday farq qilishini ko'rib chiqdik. Shaxsiy ko'rib chiqishlardan so'ng, biz ushbu UI kutubxonalarini taqqosladik, ularning kuchli va zaif tomonlari, o'zaro bog'liqliklarini ta'kidladik. Biz reaktivlik modellari, arxitektura tanlovlari, ishlab chiqish tajribasi va samaradorlik xususiyatlarini ko'rib chiqdik. Kod misollari orqali biz har birining noyob xususiyatlarini ko'rsatdik va ularning farqlarini yaxshiroq tushunishga yordam berdik. Shuningdek, reaktivlik kontseptsiyasini ko'rib chiqdik va u turli kutubxonalarda qanday amalga oshirilishini o'rgandik. Qiziqarlisi, React’ning an'anaviy reaktivlikda bo'lmaganligini, chunki u state o'zgarishi qayta renderlashga olib keladigan kam tafsiliy darajani qo'llashini muhokama qildik; bu esa Vue yoki Svelte kabi kutubxonalarda yuqori tafsiliy darajali reaktivlik modelidan farq qiladi. Yakunida, React’ning kelajagi va uning kelajakda qanday rivojlanishi mumkinligini ko'rib chiqdik. React jamoasining reaktivlik yondashuvi va uning an'anaviy reaktiv dasturlash modelidan qanday farq qilishini muhokama qildik. Shuningdek, lifecycle davomida o'zgarishi mumkin bo'lmagan qiymatlarni memoizatsiya qilish orqali React kodini avtomatik ravishda optimallashtirish uchun Forget kompilyatori haqida ham gaplashdik. Endi biz yakuniy xulosaga keldik. Takrorlash uchun savollar Ushbu bobda qamrab olingan tushunchalarni tushunishingizni kuzatishga yordam beradigan savollar ro'yxati. Agar ularning barchasiga ishonch bilan javob bera olsangiz, juda yaxshi! Bu sizning ushbu platformadan o'rganayotganingizning belgisidir. Agar javob bera olmasangiz, bu bobni yana bir bor o'qib chiqishingiz kerak bo'lishi mumkin. 1. _React, Vue, Svelte, Solid va Angular o'rtasidagi reaktivlik modelining farqlari qanday? Ushbu farqlar bu kutubxonalar/freymvorklarning ishlash samaradorligi va rivojlanish tajribasiga qanday ta'sir qiladi?_ 2. _Qwik’ning samaradorlikni maksimal darajada oshirish uchun o'ziga xos yondashuvini muhokama qiling. Bu boshqa UI kutubxonalari/freymvorklari yondashuvidan qanday farq qiladi?_ 3. _Ushbu bobda muhokama qilingan har bir UI kutubxonasi/freymvorkining asosiy kuchli va zaif tomonlari qanday? Ushbu kuchli va zaif tomonlar muayyan loyiha uchun kutubxona/freymvorkni tanlashga qanday ta'sir qilishi mumkin?_ 4. _React an'anaviy ma'noda reaktiv emas degan gapni batafsil tushuntiring. Buni Vue yoki Svelte kabi kutubxonalardagi “oshirish asosidagi” reaktivlik modeli bilan taqqoslang?_ 5. _React Forget nima? U qanday ishlaydi? U signal bilan qanday taqqoslanadi?_ Keyingi qadamlar React va uning ekotizimi bo'yicha ushbu keng qamrovli sayohatimizni yakunlashga yaqinlashganda, o'rganganlarimizni birlashtirishga tayyorlanmoqdamiz. Keyingi va oxirgi bobda biz umumiy manzaraga nazar tashlaymiz. Ushbu kitobni tugatish va bugun qayerda turganimiz va ertaga nima kutishimiz mumkinligini taqdim etamiz. Bunda biz ushbu kitob davomida to'plagan barcha texnik bilim va tushunchalardan foydalanamiz. React’ning reconciler’i qanday ishlashi, asinxronlikka chuqur kirish, server komponentlarini o'rganish, turli React freymvorklarini tushunish, Reactni tengdoshlari bilan taqqoslash - bularning barchasi bir maqsadga xizmat qildi. Endi biz nuqtalarni bog'lashga, katta rasmni ko'rishga va kelajak yo'lini belgilashga tayyormiz. Shunday qilib, siz React va frontend rivojlanishining kelajagiga qadam qo'yishga tayyormisiz? Katta final uchun tayyor bo'ling!",
    "url": "/books/fluent-react/react-alternatives/recap/page",
    "category": "books",
    "tags": [
      "fluent-react",
      "tutorial",
      "guide",
      "react",
      "javascript",
      "frontend",
      "qanday",
      "react",
      "ushbu",
      "biz",
      "chiqdik",
      "rib",
      "vue",
      "svelte",
      "uchun",
      "reaktivlik",
      "ularning",
      "angular",
      "solid",
      "uning",
      "kuchli"
    ]
  },
  {
    "id": "book-fluent-react-react-alternatives-solid-js-page",
    "title": "Solid.js Tahlili: Yuqori Tafsiliy Darajali Reaktivlik va Signallar",
    "content": "Solid.js Solid - bu foydalanuvchi interfeyslarini yaratish uchun deklarativ JavaScript kutubxonasi. U komponent modeliga asoslanganligi bilan React’ga o'xshaydi, ammo Solid reaktiv primitivlardan foydalanadi. Solid virtual DOM o'rniga, qaramliklarni avtomatik ravishda kuzatib boradigan va DOM’ni to'g'ridan-to'g'ri yangilaydigan yuqori tafsiliy daraja tizimidan foydalanadi, bu esa samarali yangilanishlarga olib kelishi mumkin. Quyida oddiy Solid komponentining misoli keltirilgan: Ushbu misolda, reaktiv primitiv yaratadi, bu Reactdagi ga o'xshaydi. Asosiy farq shundaki, joriy qiymatni qaytaradigan funksiyadir va bilvosita reaktiv kontekst uchun qaramlikni ro'yxatdan o'tkazadi. chaqirilganda, bu ga bog'liq bo'lgan UI’ning har qanday qismida funksional komponentlarni qayta chaqirishsiz yangilanishni amalga oshiradi. Buni React bilan taqqoslaganda, React’da bu holatda nomli komponent qayta chaqiriladi, uning ichidagi barcha logikani ham o'z ichiga oladi. Shunday qilib, qiymati o'z-o'zidan reaktiv emas. Solid’da esa funksiyasi hech qachon qayta chaqirilmaydi, lekin qiymati o'z-o'zidan reaktiv bo'lib, chaqirilganda har doim o'zgaradi. Bu \"yuqori tafsiliy darajasi\" deb ataladi va React’ning \"kam tafsiliy darajasi\" reaktivligiga to'g'ridan-to'g'ri qarama-qarshi hisoblanadi. Solid’ning yuqori tafsiliy darajali tizimi Solid’ning yuqori tafsiliy darajali reaktivlik tizimi ortiqcha yangilanishlarni minimallashtirish va _diffing_ bosqichiga ehtiyojni yo'qotish imkonini beradi, bu esa juda yuqori samaradorlikka olib keladi. Biroq, u nisbatan yangi va kamroq ishlatiladigan kutubxona bo'lgani uchun, uni ba'zi an'anaviy variantlar bilan solishtirganda ko'proq resurslar va hamjamiyat yechimlari mavjud emas. Solid’ning API dizayni o'qish/yozish ajratilishiga e'tibor qaratadi. Signal o'qish uchun mo'ljallangan _getter_ va alohida _setter_ sifatida ochiladi: signali _setter_’siz qanday o'tkazilishi mumkinligiga e'tibor bering. Bu, agar _setter_ ham aniq namoyon bo'lmasa, state hech qachon mutatsiyaga uchramasligini ta'minlaydi. Solid _signal_ tushunchasini yana bir bor muhokama qilishga qaytadi va bu tushuncha ko'plab boshqa freymvorklar va kutubxonalar tomonidan qabul qilingan, oldin ko'rganimizdek. Signalga oid ilgari aytib o'tgan barcha ma'lumotlar Solid muallifi Ryan Carniato tomonidan keltirilgan bo'lib, u qandaydir tarzda 2010-yildan kelgan tushunchani qayta olib kelish orqali butun oldingi ekotizimni o'zgartira oldi.",
    "url": "/books/fluent-react/react-alternatives/solid-js/page",
    "category": "books",
    "tags": [
      "fluent-react",
      "tutorial",
      "guide",
      "react",
      "javascript",
      "frontend",
      "solid",
      "yuqori",
      "tafsiliy",
      "reaktiv",
      "ning",
      "uchun",
      "react",
      "qayta",
      "bilan",
      "esa",
      "olib",
      "darajali",
      "_setter_",
      "komponent",
      "xshaydi"
    ]
  },
  {
    "id": "book-fluent-react-react-alternatives-svelte-page",
    "title": "Svelte Tahlili: Kompilyatsiya va Runes bilan Yangi Reaktivlik",
    "content": "Svelte Svelte foydalanuvchi interfeyslarini yaratish uchun tubdan yangi bo'lgan yondashuvni taklif qiladi. An'anaviy freymvorklardan farqli o'laroq, Svelte sizning deklarativ komponentlaringizni samarali imperativ kodga aylantiruvchi kompilyator hisoblanadi va bu kod DOM’ni aniq yangilab turadi. Natijada, kamroq kod bilan yuqori samaradorlikka ega, reaktiv veb-ilovalarni yozish imkoniyatiga ega bo'lasiz. Reaktivlik Svelte'ning reaktivlik modeli juda oddiy, lekin kuchli. Svelte'dagi reaktiv yozuvlar oddiy sintaksisda yoziladi va bu, masalan, elektron jadvallardagi formulalarni eslatadi. Quyida asosiy Svelte komponenti keltirilgan: Ushbu misolda sintaksisi markup ichida o'zgaruvchisi o'zgarganda avtomatik yangilanadi. Bu React’ning JSX’iga o'xshaydi, ammo bir asosiy farq bor: Svelte'da bu reaktivlik avtomatik tarzda amalga oshadi. DOM’ni yangilash uchun setter funksiyasini chaqirish yoki maxsus API’dan foydalanish shart emas; o'zgaruvchiga yangi qiymat tayinlashning o'zi kifoya va Svelte qolgan ishni o'zi bajardi. Svelte, shuningdek, reaktiv yozuv sintaksisini ham taqdim etadi, bu orqali reaktiv ma'lumotlar asosida qiymatlarni hisoblash mumkin: Bu misolda avtomatik tarzda o'zgarganida yangilanadi. Bu Vue'dagi _computed properties_ (hisoblangan xususiyatlar)ni eslatadi, ammo biroz oddiyroq sintaksisda. Svelte'ning kompilyatorga asoslangan yondashuvi bir qancha afzalliklarga ega. Bu odatda tezroq ish vaqti samaradorligini ta'minlaydi, chunki virtual DOM diffing va patching (farqni topish va tuzatish) jarayoniga ehtiyoj yo'q. Buning o'rniga, Svelte DOM’ni bevosita yangilaydigan kod yaratadi. Shu bilan birga, bu yondashuv bilan bog'liq ijobiy va salbiy jihatlar ham mavjud. Svelte'ning kompilyatorga asoslangan tabiati virtual DOM’ga asoslangan freymvorklar taklif qiladigan ba'zi dinamik imkoniyatlarni, masalan, dinamik komponent turlarini ifodalashni biroz qiyinroq yoki batafsilroq qiladi. Shuningdek, Svelte ekotizimi React, Vue va Angular’nikiga qaraganda kichikroq va yoshroq bo'lgani uchun, unda resurslar, kutubxonalar va hamjamiyat yechimlari kamroq bo'lishi mumkin. Runiklar (Runes) Runiklar — bu Svelte kompilyatoriga ta'sir qiluvchi maxsus belgilar. Bugungi kunda Svelte , , kalit so'zi va belgilaridan maxsus ma'nolar bilan foydalanadi, lekin runiklar _funksiya sintaksisi_ orqali shunga o'xshash va qo'shimcha imkoniyatlarni ham taqdim etadi. Misol uchun, reaktiv holatni e'lon qilish uchun runikidan foydalanish mumkin: Ilovalar murakkablashgani sayin, qaysi qiymatlar reaktiv ekanligini va qaysilari reaktiv emasligini aniqlash qiyin bo'lib qoladi. Hozirgi amaliyot faqat komponentning yuqori darajasida bilan e'lon qilingan qiymatlar uchun ishlaydi, bu esa tushunmovchiliklarni keltirib chiqarishi mumkin. _.svelte_ fayllarida bir xil, _.js_ fayllarida esa boshqacha ishlash xatti-harakati, masalan, kodni ko'plab joylarda qayta yozish zarurati tug'ilganda uni refactor qilishni murakkablashtiradi. Runiklar yordamida reaktivlik _.svelte_ fayllarining chegarasidan tashqariga ham kengayadi. Masalan, hisoblagich logikasini bir nechta komponentlar o'rtasida qayta ishlatilishi mumkin bo'lgan tarzda inkapsulyatsiya qilishni xohlasangiz, bugungi kunda _.js_ yoki .ts faylida maxsus saqlovchi (store) yaratishingiz kerak bo'ladi: Chunki bu _saqlovchi shartnomasini (store contract)_ amalga oshiradi — ya'ni qaytarilgan qiymat metodiga ega — biz store qiymatini prefiksini qo'shish orqali olamiz: Bu ishlaydi, lekin biroz g'alati! Store API yanada murakkab narsalarni bajarishga uringanda, juda noqulay bo'lib qolishi mumkin. Runiklar yordamida, bu jarayon ancha osonlashadi: E'tibor bering, biz qaytarilgan obyekt ichida xususiyatidan foydalanmoqdamiz, shuning uchun har doim hozirgi qiymatga ishora qiladi, funksiya chaqirilgan vaqtdagi qiymatga emas. Ishlash vaqtida reaktivlik (Runtime reactivity) Bugungi kunda Svelte _kompilyatsiya vaqtida reaktivlik(compile-time reactivity)dan_ foydalanadi. Bu, agar sizda yorlig'idan foydalanadigan ba'zi kod bo'lsa va u avtomatik ravishda qayta ishlanishi kerak bo'lsa, bu qaramliklar Svelte sizning komponentingizni kompilyatsiya qilganda aniqlanadi: Bu yaxshi ishlaydi...garchi bu ishlamasa. Faraz qilaylik, biz kodni quyidagicha refactor qilaylik: Chunki e'lon qilinishi faqat ni ko'radi, bu o'zgarganda qayta hisoblanmaydi. Natijada, kodni refactor qilish qiyinlashadi va Svelte qachon qanday qiymatlarni yangilashini tushunish ma'lum darajadagi murakkablikdan keyin juda qiyin bo'lib qolishi mumkin. Svelte 5’da yangi runiklar Svelte 5 va runiklarini taqdim etadi, bu esa o'z ifodalari qaramliklarini baholanganida aniqlaydi: Yana, , va sizning va fayllaringizda ham ishlatilishi mumkin. Signalni kuchaytirish Boshqa barcha freymvorklar singari, Svelte ham Knockout har doim haqligini anglab yetdi. Svelte 5’ning reaktivligi signallar yordamida boshqariladi, bu asosan 2010 yilda Knockout tomonidan amalga oshirilgan narsalardir. So'nggi paytlarda, signallar Solid tomonidan ommalashgan (keyinchalik bu haqida ko'proq ma'lumot beramiz) va boshqa ko'plab freymvorklar tomonidan qabul qilingan. Svelte 5’da signallar to'g'ridan-to'g'ri o'zaro ta'sir qilinadigan narsalar emas, balki ichki ishlash mexanizmida amalga oshiriladigan tafsilot hisoblanadi.",
    "url": "/books/fluent-react/react-alternatives/svelte/page",
    "category": "books",
    "tags": [
      "fluent-react",
      "tutorial",
      "guide",
      "react",
      "javascript",
      "frontend",
      "svelte",
      "mumkin",
      "uchun",
      "reaktiv",
      "reaktivlik",
      "bilan",
      "ham",
      "runiklar",
      "dom",
      "ning",
      "yangi",
      "kod",
      "ega",
      "masalan",
      "avtomatik"
    ]
  },
  {
    "id": "book-fluent-react-react-alternatives-vue-js-page",
    "title": "Vue.js Tahlili: Reaktivlik, Composition API va Signallar",
    "content": "Vue.js Vue.js foydalanuvchi interfeyslarini yaratish uchun mo'ljallangan mashhur JavaScript freymvorkidir. Uni sobiq Google muhandisi Evan Yu ishlab chiqdi. AngularJS bilan ishlash tajribasiga ega bo'lgan Evan, Angular'ning yaxshi tomonlarini olib, yengilroq, oson qo'llab-quvvatlanadigan va kamroq qattiq qoidalarga ega bo'lgan Vue.js freymvorkini yaratdi. Reaktivlik tizimi Vue.js'ning eng ajralib turadigan xususiyatlaridan biri - reaktivlik tizimi bo'lib, bu tizim ishlatilgan holda komponent state'i reaktiv JavaScript obyektlaridan iborat bo'ladi. Ularni o'zgartirganda, ko'rinish ham yangilanadi. Ushbu model state'ni boshqarishni oddiy va intuitiv qiladi, ammo qanday ishlashini yaxshi tushunish ba'zi muammolardan qochish uchun muhimdir. Vue'ning reaktivlik modelida, u obyekt xususiyatlarini o'qish va yozish jarayonlarini tutib qoladi. Vue 2 da, brauzer qo'llab-quvvatlash cheklovlari tugayli faqat getter/setter'lardan foydalanilgan. Vue 3 da esa, reaktiv obyektlar uchun proxy'lardan, ref uchun esa getter/setter'lardan foydalaniladi. Quyidagi Vue dokumentatsiyasidagi psevdokod bu jarayonni ko'rsatadi: Reaktiv tizimning soddalashtirilgan namunasi Bu osonlashtirilgan misol bo'lib, proxy’lardan foydalanadigan sodda reaktiv tizimni ko'rsatadi. funksiyasi obyektni qabul qilib, ushbu obyektning proxy’sini qaytaradi, bu proxy va operatsiyalarini tutib qoladi. operatsiyasida, funksiyasi chaqirilib, so'ralgan xususiyatni qaytaradi. operatsiyasida esa qiymat yangilanadi va funksiyasi chaqiriladi. funksiyasi esa, o'z navbatida, qiymatni obyekt ichiga joylashtiradi va bu qiymat uchun reaktiv va operatsiyalarini taqdim etadi. Bu proxy’ga o'xshash ishlaydi, ammo strukturasida farq bor, ya'ni qiymatga kirish yoki uni o'zgartirishda va funksiyalari kerakli vaqtda chaqirilishini ta'minlaydi. DOM’ni yangilash uchun reaktiv tizimdan foydalanish Bu oddiy reaktiv tizim namunasi Vue’ning reaktivlik modelining asosiy tamoyillarini ko'rsatadi. Bu reaktivlik modeli DOM’ni yangilash uchun ham ishlatilishi mumkin. Quyidagi misol oddiy “reaktiv rendering”ni amalga oshiradi: Aslida, Vue komponenti state va DOM’ni sinxronlashtirish uchun xuddi shunday usuldan foydalanadi - har bir komponent nusxasi DOM’ni render qilish va yangilash uchun reaktiv effekt yaratadi. Albatta, Vue komponentlari DOM’ni yangilashning dan ko'ra ancha samaraliroq usullaridan foydalanadi, ammo bu Vue’ning qanday ishlashini tushunish uchun yetarli. Composition API , , va kabi API’lar Vue’ning Composition API qismiga kiradi. Bu API’lar Vue komponentlarida state’ni boshqarish, hisoblash va ko'rinishni yangilash jarayonlarini soddalashtiradi. Signallar Bir qancha boshqa freymvorklar Vue’ning Composition API’sidagi lariga o'xshash reaktivlik primitivlarini “signallar” degan nom ostida joriy qilgan. Ushbu bobda signallarni batafsil muhokama qilamiz. Asosan, signallar Vue lariga o'xshash reaktivlik primitividir. Bu qiymatni saqlovchi konteyner bo'lib, unga kirishda qaramlik kuzatuvini ta'minlaydi va o'zgarishda _side effect_’larni ishga tushiradi. Bu reaktivlikka asoslangan paradigma frontend olamida yangi tushuncha emas: bu kontseptsiya o'n yildan ortiq vaqt oldin _Knockout observables_ va _Meteor Tracker_ kabi dasturiy ta'minotlarga borib taqaladi. _Vue Options API_ va React uchun MobX state menejment kutubxonasi ham xuddi shu prinsiplarga asoslangan, ammo ushbu primitivlarni obyekt xususiyatlari ortida yashiradi. Signal tushunchasiga xos bo'lmasa-da, bugungi kunda ushbu kontseptsiya o'zgarishlar yuqori tafsiliy darajadagi obunalar orqali amalga oshiriladigan rendering modeli bilan birga muhokama qilinadi. Virtual DOM’dan foydalanishi sababli, Vue ayni paytda xuddi shunday optimallashtirishlarni amalga oshirish uchun kompilyatorlarga tayanadi. Biroq, Vue, shuningdek virtual DOM’ga tayanmaydigan va Vue’ning ichki o'rnatilgan reaktivlik tizimidan ko'proq foydalanadigan yangi Solid’dan ilhomlangan kompilyatsiya strategiyasini (Vapor Mode) o'rganmoqda. Soddalik Vue’ning eng katta kuchli tomoni uning soddaligida. Vue bilan ishlashni boshlash juda oson: siz Vue kutubxonasini HTML faylingizga tegida kiritishingiz va Vue komponentlarini yozishni boshlashingiz mumkin. Vue, shuningdek, yangi loyihalarni tuzish uchun CLI vositasini ham taqdim etadi, bu esa murakkabroq ilova yaratishni boshlash uchun ajoyib vosita bo'lishi mumkin. Vue.js’ning faqat asosiy jihatlarini ko'rib chiqqan bo'lsak ham, Vue’ning kuchli reaktivlik tizimi, shablon asosidagi sintaksisi va yaxshi tuzilgan komponent modeli ko'plab dasturchilar uchun jozibador tanlov ekanligini anglash qiyin emas.",
    "url": "/books/fluent-react/react-alternatives/vue-js/page",
    "category": "books",
    "tags": [
      "fluent-react",
      "tutorial",
      "guide",
      "react",
      "javascript",
      "frontend",
      "vue",
      "uchun",
      "ning",
      "reaktivlik",
      "reaktiv",
      "dom",
      "api",
      "state",
      "ham",
      "ushbu",
      "esa",
      "proxy",
      "ammo",
      "lardan",
      "funksiyasi"
    ]
  },
  {
    "id": "book-fluent-react-react-server-components-future-of-react-server-components-page",
    "title": "React Server Komponentlarining Kelajagi: Nimalar Kutilmoqda?",
    "content": "React server komponentlarning kelajagi RSC’lar vaqt o'tishi bilan rivojlanishi va yaxshilanishi kutilmoqda. React jamoasi ushbu funksiyani yanada takomillashtirish, muammolarni hal qilish va funksional imkoniyatlarini kengaytirish ustida faol ish olib bormoqda. Hozirgi rivojlanayotgan ba’zi yo'nalishlar quyidagilardan iborat: - Yaxshiroq to'plash vositalari(bundler) integratsiyasilari: React jamoasi Webpack, Rollup va boshqa jamlash vositalari bilan yaxshiroq moslashuvni ta’minlash uchun ularning dasturchilari bilan hamkorlik qilmoqda. Bu esa RSC’larga mos freymvorklar va ilovalarni yaratishni osonlashtiradi. - Ekotizim qo'llab-quvvatlovi: RSC’lar ommalashgani sari ushbu yangi dastur arxitekturasini qo'llab-quvvatlash va kengaytirish uchun ko'proq vositalar, kutubxonalar va freymvorklar paydo bo'lishi kutilmoqda. Bu esa dasturchilarga RSC’larni o'z loyihalariga osonroq kiritish va ularning ishlash samaradorligidan va unumdorligidan foyda olish imkonini beradi. RSC’lar React ekotizimida muhim o'zgarishlarni ifodalaydi. Ular yanada yuqori unumdorlik, ma’lumotlarni osonroq olish va yaxshiroq foydalanuvchi bilan ishlash qulayligini taqdim etadi. RSC’lar rivojlanishda va keng ko'lamda qo'llanishda davom etar ekan, ular zamonaviy, samarali va foydalanuvchi uchun qulay React ilovalarini yaratish uchun muhim vosita bo'lib qoladi. Endilikda RSC’lar haqidagi ushbu keng qamrovli tushunchangiz bilan siz ushbu yangi va takomillashgan eksperimental funksiyani o'z loyihalaringizda o'rganishga va sinab ko'rishga tayyorsiz deb umid qilamiz.",
    "url": "/books/fluent-react/react-server-components/future-of-react-server-components/page",
    "category": "books",
    "tags": [
      "fluent-react",
      "tutorial",
      "guide",
      "react",
      "javascript",
      "frontend",
      "rsc",
      "react",
      "lar",
      "bilan",
      "ushbu",
      "uchun",
      "kutilmoqda",
      "yaxshiroq",
      "server",
      "kelajagi",
      "jamoasi",
      "funksiyani",
      "yanada",
      "kengaytirish",
      "vositalari"
    ]
  },
  {
    "id": "book-fluent-react-react-server-components-making-updates-page",
    "title": "React Server Komponentlarida Yangilanishlar va Interaktivlik",
    "content": "Yangilanishlarni amalga oshirish RSC’larning ko'plab ijobiy jihatlari bo'lsa-da, e'tibor berish kerak bo'lgan ayrim cheklovlar ham mavjud, ikki xil turdagi komponentlar (server va klient) haqida o'ylash kerak bo'lgan ortiqcha aqliy o'ylashni qabul qilish. Buning sababi shundaki, barcha komponentlar server komponentlari bo'la olmaydi. Misol: Counter komponenti Masalan, foydalanuvchi tugmasini bosganida hisob qiymatini ga oshiradigan oddiy hisoblagich komponentini ko'rib chiqaylik: Bu komponent ikkita sababga ko'ra server komponenti bo'lishi mumkin emas: useState’dan foydalanish Bu useState’dan foydalanadi va bu faqat klient tomonda ishlatiladigan API hisoblanadi. Bu shuni anglatadiki, server ning boshlang'ich qiymatini bilmaydi, shuning uchun u boshlang'ich HTML’ni render qila olmaydi. Bu muammo, chunki server dastlabki HTML’ni render qilishi kerak, keyin klient interaktiv UI’ni render qilishi mumkin. Server muhitida \"state\" tushunchasi bir nechta klientlar o'rtasida ulashiladi. Biroq, RSC’lar joriy qilinishidan oldin, React’da state hozirgi dasturga lokalizatsiya qilingan edi. Ushbu farq xavf tug'dirishi mumkin. Bu bir nechta klientlar o'rtasida state’ning sizib chiqishiga olib kelishi, potensial ravishda nozik ma'lumotlarni oshkor bo'lishi muammosiga sabab bo'lishi mumkin. Ushbu farq va unga tegishli xavfsizlik xavflari sababli, RSC’lar server tomonda dan foydalanishni qo'llab-quvvatlamaydi. Chunki server tomonidagi state klient tomonidagi state’dan tubdan farq qiladi. Bundan tashqari, dan olinadigan dispetcher funksiyasi seriyalashtirilishi va klientga yuborilishi kerak, ammo funksiyalar seriyalashtirilmaydi, shuning uchun bu imkonsiz bo'ladi. onClick’dan foydalanish ham faqat klient tomonida ishlatiladigan API hisoblanadi. Chunki serverlar interaktiv emas: serverda ishlayotgan jarayonni \"click\" qilib bo'lmaydi, shuning uchun server komponentlarida biroz imkonsiz holatdir. Bundan tashqari, server komponentlari uchun barcha props’lar seriyalashtirilishi kerak, chunki server props’larni seriyalashtirishi va klientga yuborishi kerak, funksiyalar esa seriyalashtirilmaydi. Klient va server komponentga ajratish Shu sababli, agar biz server komponentlarining kuchidan foydalanishni xohlasak, oddiy hisoblagich endi server qismi va klient qismiga bo'linishi kerak: Bu misol biroz tasavvuriy misol bo'lsa-da, lekin u shunchaki React komponentini olib, uni server komponentiga aylantira olmasligingizni ko'rsatadi.. Sizning komponentingizning qaysi qismlari serverda render qilinishi va qaysi qismlari klientda render qilinishi to'g'risida o'ylashingiz kerak. Bu bir oz qiyinchilik keltirib chiqaradi, chunki bu misolda serverda render qilinadigan va klientda render qilinadigan qismlar aniq, lekin real hayotdagi dasturlarda bunchalik aniq bo'lmasligi mumkin. Shunday qilib, biz hisoblagich dasturimizning interaktiv qismidan kichik bir qismini ajratib oldik va faqat shu qism bizning foydalanuvchilarimizga JavaScript to'plam paketi sifatida yetkaziladi; qolgan qismi esa yetkazilmaydi. Natijada, biz tarmoq orqali juda kichik JavaScript paketlarini jo'natamiz, bu esa yuklash vaqtlarini tezlashtiradi va foydalanuvchilarimiz uchun CPU va tarmoq jihatidan yanada yaxshi ishlashni ta'minlaydi, chunki JavaScript’ni tahlil qilish va bajarish uchun kamroq ish qilinishi kerak va yuklanadigan ma'lumotlar kam bo'ladi. Shu sababli, biz xavfsiz serverda imkon qadar ko'proq render qilishni xohlaymiz, shunda klient tomondagi paketlar ichiga kod qo'shmaymiz. Ichki ishlash mexanizmi Qo'shimcha aqliy o'ylashni hisobga olgan holda, keling, React qanday qilib server komponentlari va klient komponentlarini ichki mexanizmda alohida ajratib va ulardan qanday foydalanishini ko'rib chiqaylik. Bu muhim, chunki bu bizga dasturimizga yangilanishlar kiritishni tushunishga yordam beradi. Klient komponentlari va grafiklar Klient komponentlari direktivasi yordamida ajratiladi va bu direktiva klient komponentlarini o'z ichiga olgan faylning yuqori qismida joylashadi. RSCs server va klient komponentlarini ushbu direktivalarning ishlatilishiga asoslanib farqlash uchun keyingi avlod vositalarini talab qiladi. Keyingi avlod vositalarini to'plash vositasi(bundler) yoki to'plash vositasi konfiguratsiyasi(bundler configuration)dan foydalangan holda, to'plash vositalari React ilovalari uchun alohida modul grafiklarini ishlab chiqarish imkoniyatiga ega: server grafik va klient grafik. Server grafiki hech qachon to'plam paketiga aylantirilmaydi, chunki u foydalanuvchilarga yetkazib berilmaydi, lekin direktivasi bilan boshlanuvchi barcha fayllar bitta klient to'plam paketi yoki bir nechta to'plam paketlarga qo'shiladi, ularni _lazy loading_ orqali yuklab olish mumkin. Ushbu implementatsiya tafsilotlari RSCs ustida qurilgan freymvorklar bilan bog'liq. Shunday qilib, kontseptual jihatdan bizda serverda bajariladigan server grafigi va klientda kerak bo'lganda yuklab olinadigan va bajariladigan bitta yoki bir nechta klient to'plam paketlari mavjud. Ammo React klient komponentlarini qachon import qilish va bajarish kerakligini qanday biladi? Buni tushunish uchun biz odatiy React daraxtini ko'rib chiqishimiz kerak. Keling, hisoblagich misolimizdan foydalanamiz. Komponentlar daraxti Pastdagi rasmda, hisoblagich ilovamiz uchun komponentlar daraxtini vizualizatsiya qilamiz, bu yerda to'rtta komponentlar serverda render qilingan va yashil komponentlar klientda render qilingan. Daraxtning ildizi server komponenti bo'lgani uchun, butun daraxt serverda render qilinadi. Biroq, komponenti klient komponenti bo'lgani uchun, u serverda render qilinmaydi. Buning o'rniga, server klient komponenti uchun placeholder, ya'ni joy saqlab turuvchi, render qiladi, bu esa klient to'plash vositasi ishlab chiqargan maxsus modulga havola hisoblanadi. Ushbu modul havolasi asosan “agar siz daraxtda ushbu nuqtaga yetib kelsangiz, ushbu maxsus moduldan foydalanish vaqti keldi” degan ma'noni anglatadi. !Server va klient komponentlarini ko'rsatuvchi daraxt Modul har doim faqat kerak bo'lganda yuklab olinishi shart emas, balki dastlabki to'plam to'plam paketdan ham yuklab olinishi mumkin, chunki to'plash vositalari foydalanuvchilarga yetkazib beradigan to'plam paketlarda ko'plab modullarni qo'shadi. Bu tom ma'noda, yoki shunga o'xshash narsa bo'lishi mumkin. Asosiy nuqtasi shundaki, server to'g'ri klient moduliga havolani yuboradi va React klient tomonida bo'sh joyni to'ldiradi. Bu jarayon sodir bo'lganda, React modul havolasini klient to'plam paketi ichidagi haqiqiy modul bilan almashtiradi. Bu biroz soddalashtirish bo'lsa-da, mexanizmni yaxshi tushunishimizga yordam beradi. Klient komponenti klientda render qilinadi va klient komponenti bilan odatdagidek interaktivlikka kirishish mumkin bo'ladi. RSCs uchun keyingi avlod to'plash vositalari kerak bo'lishining sababi shundaki, ular server va klient komponentlari uchun alohida modul grafiklarini ishlab chiqarishi kerak. Render qilingan daraxt Amalda, bu bizning hisoblagich misolimizda server quyidagi daraxtni render qiladi: Ushbu daraxt klient tomoniga yuboriladi va React uni render qilar ekan, modul havolasiga duch kelganda, React ushbu modul havolasini klient to'plam paketi ichidagi haqiqiy modul bilan \"aqlli\" tarzda almashtiradi. Shunday qilib, React qachon klient komponentlarini import qilish va bajarish kerakligini biladi. Klient komponentlarining qayta qo'llanilishi Shunday qilib, biz to'plash vositasi(bundler) serverda butun daraxtni render qilish imkoniyatiga ega ekanligini va faqat klientda to'ldirilishi kerak bo'lgan \"teshiklar\" qoldirilishini ko'ramiz, shu bilan birga, serverda klient komponentlarining bolalarini rekursiv tarzda render qilib, to'liq daraxt hosil qiladi. Keyin esa, klient zarur bo'lgan har qanday teshikni klient to'plam paketlarini yuklab olish va bajarish orqali to'ldiradi. Server komponentlarini, shuningdek, Suspense hududlariga o'rash ham mumkin, bunda freymvorklar \"tayyor\" bo'lganda ularni server tomonidan foydalanuvchilarga _stream_ tarzida uzatish uchun zarur ishlarni bajaradi: ya'ni ular talab qiladigan har qanday ma'lumotlar olinadi va boshqa barcha operatsiyalar asinxron tarzda bajariladi. Umid qilamizki, endi biz klient komponentlarining server komponentlaridan qanday ajratilishini tushundik, bu esa RSC’larga yo'naltirilgan ilovalarda yangilanishlarni amalga oshirish imkonini beradi. bilan belgilangan klient komponentlari ichki state’lar( kabi) va kabi event handler’larni muammosiz o'z ichiga olishi mumkin. Endi biz klient komponentlari bilan siklni yopganimizni va server komponentlari qanday ishlashini, shuningdek, klient komponentlari qanday qilib klient to'plam paketlariga qo'shilishini tushunganimizdan so'ng, bu mavzular atrofida bir oz nozik jihat(nyuans)larni muhokama qilishimiz kerak.",
    "url": "/books/fluent-react/react-server-components/making-updates/page",
    "category": "books",
    "tags": [
      "fluent-react",
      "tutorial",
      "guide",
      "react",
      "javascript",
      "frontend",
      "klient",
      "server",
      "render",
      "kerak",
      "uchun",
      "react",
      "plam",
      "mumkin",
      "komponentlari",
      "serverda",
      "chunki",
      "ushbu",
      "modul",
      "komponenti",
      "qilib"
    ]
  },
  {
    "id": "book-fluent-react-react-server-components-navigation-page",
    "title": "React Server Komponentlarida Navigatsiya",
    "content": "Navigatsiya Agar bizning RSC’larga imkon beruvchi dasturimizda quyidagi kabi bir havola bo'lsa: Ushbu havolaga bosilganda, bu butun sahifa navigatsiyasini amalga oshiradi, bu esa brauzerni serverga so'rov yuborishiga olib keladi, server esa sahifani render qilib, uni brauzerga qaytaradi. Biz ko'p yillar oldin PHP davrida shu ishlarni qilar edik va bu jarayonda bir oz noqulaylik va sekinlik hissi paydo bo'ladi. Biz yaxshirog'ini qilishimiz mumkin: RSC’lar yordamida biz oson navigatsiyani amalga oshira olamiz, bu holda state route’lar o'zgarishi o'rtasida saqlanadi. Buni amalga oshirish uchun biz serverga navigatsiya qilmoqchi bo'lgan URL’ni yuboramiz va server bizga ushbu sahifaning JSX daraxtini qaytaradi. Keyin brauzerdagi React yangi JSX daraxti bilan butun sahifani qayta render qiladi va biz to'liq sahifani yangilamasdan yangi sahifaga ega bo'lamiz. Bu aynan biz amalga oshirishimiz kerak bo'lgan jarayon. Klient tomonidagi o'zgartirishlar Buni amalga oshirish uchun, biz klientdagi kodimizni biroz o'zgartirishimiz kerak. Biz dasturimizdagi barcha havolalarga standard havolani bosish harakatini to'xtatadigan va o'rniga yangi sahifa uchun serverga so'rov yuboradigan event listener’ni qo'shamiz. Buni quyidagi tarzda amalga oshirishimiz mumkin: Biz event listener’ni ga qo'shmoqdamiz, chunki bu ishlash samaradorligi uchun muhim: biz dasturimizdagi har bir havolaga event listener’ni qo'shishni xohlamaymiz, bu katta miqdordagi event listener’lari qo'shilishiga olib keladi va bu jarayonni sekinlashtirishi mumkin. O'rniga, biz ga bitta event listener’ni qo'shamiz va bosish maqsadining havola ekanligini tekshiramiz. Bu usul _event delegation_ deb ataladi. Navigatsiya funksiyasini ta'riflash Agar foydalanuvchi A elementiga bosgan bo'lsa, biz avval havolaning standard harakatini to'xtatamiz va uning o'rniga biz bir soniya ichida aniqlaydigan funksiyasini chaqiramiz. Ushbu funksiya yangi sahifa uchun serverga so'rov yuboradi va keyin React uni klientda render qiladi. Keling funksiyasini ta'riflab ko'ramiz: Bu yerda biz amalga oshirayotgan jarayon juda oddiy: biz yangi sahifa uchun serverga so'rov yuboramiz, javobni React elementi sifatida deseriyalashtiramiz va keyin bu elementni dasturimizning asos(root)iga render qilamiz. Bu React’ga sahifani yangi JSX daraxti bilan qayta render qilishga olib keladi va biz to'liq sahifani yangilamasdan yangi sahifaga ega bo'lamiz. Lekin nima? Buni tushunish uchun biz klient tomonidagi to'liq JavaScript faylini ko'rib chiqishimiz kerak: Biz sahifani dastlabki hidratsiyalashda React’dan root’ni olamiz va bu root’dan yangi elementlarni render qilish uchun foydalanamiz. Bu React ichki tomondan qanday ishlashini ifodalaydi va biz faqat React ichki ishlatadigan API’ni ishlatmoqdamiz. Bu yaxshi narsa, chunki bu biz hech qanday maxsus yoki qiyin jarayonni amalga oshirmayotganimizni anglatadi, biz faqat React’ning ochiq API’sini ishlatmoqdamiz. Serverning javobini sozlash Va nihoyat, bizning serverimiz sarlavha(header)si bilan berilgan so'rovga, keyingi sahifa uchun to'liq HTML satri o'rniga faqat JSX daraxti obyektini qaytarishi kerak. Buni quyidagicha amalga oshirishimiz mumkin: E'tibor bering, agar sarlavha mavjud bo'lsa, biz JSON yubormayapmiz, balki faqat string yuboryapmizmi? Chunki biz buni klient tomonda qilishimiz kerak va string’ni kutadi, JSON obyektini emas. Bu API’ga oid bir o'ziga xoslik, lekin juda ham yomon deb bo'lmaydi. Yangi sahifalarga navigatsiya Endi biz yangi sahifalarga to'liq sahifa yangilanishisiz navigatsiya qilish yo'lini yaratdik. Bizning RSCs imkoniyatiga ega dasturimizda barcha bog'lanish havolalari navigatsiyasi to'liq sahifa yangilanishisiz silliq va erkin o'tadi. Lekin yangilanishlar haqida nima deymiz? Yangilanishlarni qanday boshqaramiz? Keling, buni ham ko'rib chiqamiz.",
    "url": "/books/fluent-react/react-server-components/navigation/page",
    "category": "books",
    "tags": [
      "fluent-react",
      "tutorial",
      "guide",
      "react",
      "javascript",
      "frontend",
      "biz",
      "yangi",
      "amalga",
      "uchun",
      "react",
      "sahifa",
      "buni",
      "navigatsiya",
      "sahifani",
      "render",
      "liq",
      "bir",
      "serverga",
      "kerak",
      "event"
    ]
  },
  {
    "id": "book-fluent-react-react-server-components-nuance-page",
    "title": "React Server Komponentlarida Nozik Jihatlar: Bajarilish Konteksti",
    "content": "Nozik jihatlar (Nuances) Server komponentlari faqat serverda, klient komponentlari esa faqat klientda bajariladi, degan umumiy noto'g'ri tushuncha mavjud. Bu haqiqatga to'g'ri kelmaydi. Server komponentlari faqat serverda bajariladi va React elementlarini ifodalovchi obyektlarni ifoda etadi, lekin klient komponentlari faqat klientda bajarilmaydi. \"Komponentlar bajarilishi\" deganda nima nazarda tutiladi? Buni chuqurroq tushunishimiz uchun kelin, \"Komponentlar bajarilishi\", ya'ni _components execute_ deganda nimani anglatishini muhokama qilaylik. \"Komponentlar bajarilishi\" deganda biz komponentni ifodalovchi funksiya chaqirilishini nazarda tutamiz. Masalan, bizda ushbu komponent bor deylik: \" bajarilishi\" deganda, biz funksiyasi uning props’lari bilan chaqirilishi va React elementini qaytarishini nazarda tutamiz—bu oddiy JavaScript obyekti bo'lib, quyidagi ko'rinishga ega: Bu \"komponentlar bajarilishi\" deganda nimani nazarda tutayotganimizdir. Serverda klient komponentlarining bajarilishi _Server rendering_ paytida klient komponentlari serverda bajariladi va React elementlarini ifodalovchi obyektlarni chiqaradi. Bu elementlar keyinchalik HTML satriga seriyalashtiriladi va klientga jo'natiladi, bu yerda brauzer HTML markup’ini render qiladi. Shunday qilib, klient komponentlari ham serverda bajariladi, React elementlarini ifodalovchi ba'zi obyektlarni qaytaradi, va keyin server ularni HTML’ga seriyalashtiradi va klientga yuboradi. To'g'ri bayonotlar Buni aniqroq tasavvur qilish uchun biz quyidagi to'g'ri bayonotlarni keltirishimiz mumkin: 1. Server komponentlari serverda bajariladi, React elementlarini ifodalovchi obyektlarni chiqaradi. 2. Klient komponentlari serverda bajariladi, React elementlarini ifodalovchi obyektlarni chiqaradi. 3. Serverda klient va server komponentlarining barcha React elementlarini ifodalovchi katta obyekt mavjud. 4. Bu satr(string)ga aylantiriladi va klientga yuboriladi. 5. Ushbu nuqtadan boshlab, server komponentlari klientda hech qachon bajarilmaydi. 6. Klient komponentlari faqat klientda bajariladi. Bu nuqtai nazar bilan, server va klient komponentlarining bajarilish chegaralari yanada aniqroq bo'ladi. Biz bu yerda nozik masalalarni muhokama qilayotgan bo'lishimiz mumkin, lekin ikkita komponent turining o'zaro ta'sirini to'liq tushunish va qadrlash uchun qo'shimcha tafsilotlarni qo'shish muhimdir.",
    "url": "/books/fluent-react/react-server-components/nuance/page",
    "category": "books",
    "tags": [
      "fluent-react",
      "tutorial",
      "guide",
      "react",
      "javascript",
      "frontend",
      "komponentlari",
      "klient",
      "server",
      "serverda",
      "react",
      "bajariladi",
      "ifodalovchi",
      "elementlarini",
      "bajarilishi",
      "faqat",
      "obyektlarni",
      "deganda",
      "klientda",
      "komponentlar",
      "nazarda"
    ]
  },
  {
    "id": "book-fluent-react-react-server-components-page",
    "title": "React Server Komponentlari (RSC): Yangi Avlod Arxitekturasi",
    "content": "React server komponentlari Oldingi bo'limda biz React freymvorklariga, ayniqsa, Next.js va Remix’ga e'tibor qaratdik. Freymvorklardan foydalanishning sabablarini, masalan, abstraksiya foydalari, ishlab chiqishni tezlashtiruvchi konvensiyalar, keng tarqalgan muammolar uchun kompleks yechimlar va umuman samaradorlikni oshirishga bo'lgan ta'sirini ko'rib chiqdik. Biz Remix va Next.js’ning batafsil jihatlarini tahlil qilib, har bir freymvorkning o'xshash muammolarni qanday hal qilishini, hatto o'zimizning minimal freymvorkimizni yaratish orqali ko'rsatdik va Next.js’ning React Server Components(RSCs)ga to'liq moslashgan server-first yo'nalishiga qisqacha to'xtaldik. RSC’lar React ekotizimidagi qiziqarli tendensiyalardan biri bo'lib, React ilovalarining samaradorligi, ishlashi va foydalanuvchi bilan ishlash qulayligini yaxshilash uchun ishlab chiqilgan. Ushbu takomillashgan ilova arxitekturasi serverda render qilinadigan ko'p sahifali ilovalarning (MPA) va klient tomonida render qilinadigan ilovalarning (SPA) eng yaxshi jihatlarini birlashtirib, foydalanuvchi bilan ishlash qulayligini yaxshilaydi va samaradorlik yoki texnik xizmat ko'rsatish jihatlaridan tavakkal qilmaslik imkonini beradi. Ushbu bo'limda biz RSC’larning asosiy tushunchalari, afzalliklari, mental modellari va mexanizmlarini muhokama qilamiz. Eng so'nggi ma'lumotlar uchun har doim react.dev saytiga murojaat qilishingiz mumkin. RSC’lar serverda \"ishlaydigan\" va klient tomonidagi JavaScript to'plam paketiga kiritilmaydigan yangi turdagi komponentlarni joriy qiladi. Bu komponentlar qurish vaqtida ishlashi mumkin bo'lib, fayl tizimidan o'qish, statik kontent olish yoki ma'lumotlar qatlamiga kirish imkonini beradi. Server komponentlaridan interaktiv klient komponentlariga brauzerda prop sifatida ma'lumot uzatish orqali RSC’lar samarador va yuqori ishlashga ega bo'lgan ilovani ta'minlaydi.",
    "url": "/books/fluent-react/react-server-components/page",
    "category": "books",
    "tags": [
      "fluent-react",
      "tutorial",
      "guide",
      "react",
      "javascript",
      "frontend",
      "react",
      "server",
      "rsc",
      "biz",
      "next",
      "uchun",
      "lar",
      "klient",
      "komponentlari",
      "limda",
      "remix",
      "ishlab",
      "lgan",
      "ning",
      "jihatlarini"
    ]
  },
  {
    "id": "book-fluent-react-react-server-components-recap-page",
    "title": "React Server Komponentlar Xulosasi: Asosiy Tushunchalar va Kelajak",
    "content": "Bo'limni qisqacha takrorlash Ushbu bobda biz React Server Componentlar (RSC) haqida to'liq to'xtalib o'tdik. Bu React ekotizimida katta yutuq bo'lib, u React ilovalarining ishlash samaradorligi, unumdorligi va foydalanuvchi bilan ishlash qulayligini oshirishga qaratilgan. RSC’lar serverda render qilingan ko'p sahifali ilovalar (MPA) va klientda render qilingan bir sahifali ilovalar (SPA)ning eng yaxshi xususiyatlarini birlashtiradigan innovatsion ilova arxitekturasini ifodalaydi. Bu yondashuv ishlash samaradorligi yoki qo'llab-quvvatlash qulayligini qurbon qilmasdan uzluksiz foydalanuvchi bilan ishlash qulayligini taqdim etadi. Biz RSC’lar asosiy tushunchalari, afzalliklari hamda ularning mental model va mexanizmlari bilan tanishdik. Asosiy e'tibor serverda ishlaydigan yangi turdagi komponentga qaratildi. Bu komponent klient tomoni JavaScript to'plam paketiga kirmaydi va qurilish vaqtida ishlashi mumkin. Ushbu yutuq yanada samarali va effektiv ilova strukturasini yaratadi. E'tibor bering, ushbu dokumentatsiya yozilayotgan paytda, RSC’lar React va veb muhandislik sohasida muhim mavzu hisoblanadi, shuning uchun ba'zi tafsilotlar o'zgargan bo'lishi mumkin. Har doim so'nggi yangiliklar uchun react.dev va React’ning turli hamjamiyat kanallariga nazar tashlashni tavsiya qilamiz. Takrorlash uchun savollar 1. _React server komponentlarining asosiy qiymati nimada?_ 2. _Klient komponentlari server komponentlarini import qila oladimi? Nima uchun ha/yo'q?_ 3. _Server komponentlari va an’anaviy faqat klient tomonida ishlaydigan React ilovalari o'rtasidagi ba'zi afzallik va kamchiliklar qanday?_ 4. _Modul ma'lumotnomalari nima va React ularni reconciliation jarayonida qanday qayta ishlaydi?_ 5. _Server harakatlari React ilovalarini qanday qilib yanada qulayroq qiladi?_ Keyingi bo'lim Keyingi bobda biz ozgina boshqa yo'lga o'tamiz. Hozirgacha bo'lgan sayohatimizda biz React’ning chuqur ichki mexanizmlariga, state'ni boshqarish strategiyalariga, asinxron render qilish imkoniyatlariga va nihoyat, kuchli freymvorklarga e'tibor qaratdik. Endi biroz orqaga chekinib, nuqtai nazarimizni kengaytiramiz. Biz React’dan tashqariga chiqib, React’ning o'sishi bilan birga rivojlangan va ba'zan uning ustunligiga javoban paydo bo'lgan alternativ UI kutubxonalari va freymvorklar olamiga sho'ng'iymiz. Ushbu alternativlar nafaqat React’ning eng yaxshi xususiyatlarini qabul qilgan, balki UI dasturiy ta'minotida yangi paradigmalarga va imkoniyatlarga olib keluvchi o'ziga xos yangiliklarni ham joriy qilgan. Kelgusi tadqiqotda biz Vue, Angular, Solid, Qwik va Svelte kabi boshqa UI kutubxonalarining ishlash mexanizmlari va falsafasini o'rganamiz. Biz ularning state menejment, side effect’larni boshqarish strategiyalari va React bilan taqqoslaganda ishlash samaradorligi va dasturchi bilan ishlash qulayligi bo'yicha qanday farqlanishlarini ko'rib chiqamiz. Har bir alternativni o'ziga xos afzallik va kamchiliklari bilan baholaymiz, bu ularni turli loyihalar yoki dasturchilar afzalliklari uchun mosroq qiladi: - Vue: Vue progressiv qabul qilinadigan freymvork bo'lib, sizga kichikroq loyihadan boshlash imkonini beradi va asta-sekin Vue xususiyatlarini zarur bo'lganda qabul qilishingiz mumkin. Vue o'zining nafis API va dasturchi bilan ishlash qulayligiga e'tibori bilan mashhur. U oddiy, ammo kuchli reaktivlik modelini taqdim etadi, uning asosiy kontseptsiyasi reaktivlikka bo'lgan qaramliklarni ko'rsatish paytida kuzatiladi. - Angular: Angular to'liq va qat'iy freymvork bo'lib, o'rganish qiyinroq, ammo tayyor holatda kuchli yechimlarni taklif qiladi. Uning bog'lanish tizimi va deklarativ shablonlari React bilan taqqoslaganda ilova strukturasi va state menejmentda boshqacha yondashuvni ta'minlaydi. - Solid: Solid JavaScript hamjamiyatida e'tibor qozonayotgan yana bir da'vogardir. U React’ga o'xshash dasturlash modeli bilan birga, tezroq va samaraliroq render qilishga e'tibor beradi. Solid qaramliklarni kuzatish usuli ko'proq samaradorlik izlayotgan dasturchilar uchun yangicha yondashuv bo'lishi mumkin. - Qwik: Qwik optimal yuklanish unumdorligini “oldindan ko'rish” orqali yaxshilashga e'tibor qaratadi. Bu ilova strukturasi va JavaScript’ni foydalanuvchi bilan ishlash qulayligi uchun eng yaxshi holatda yetkazish usullari haqida yangi nuqtai nazarni taklif etadi. - Svelte: Svelte boshlang'ich yuklanish vaqtlarini qisqartirish va silliq yangilanishlarni ta'minlash uchun komponentlarni tuzish vaqtida to'g'ridan-to'g'ri DOM’ni boshqaradigan imperativ kodga kompilyatsiya qiladi. Uning reaktivlik modeli, ya'ni reaktiv ifodalar orqali ishlashi React’ning virtual DOM farqlash strategiyasidan keskin farq qiladi. Bu freymvorklar va kutubxonalarni o'rganish jarayonida biz React haqidagi bilimlarimizni asosiy mezon sifatida saqlaymiz. Bu nafaqat boshqa kutubxonalarni yaxshiroq tushunishga yordam beradi, balki taqqoslash va qarama-qarshi nuqtalarni taqdim etish orqali React haqidagi tushunchamizni ham chuqurlashtiradi. Shu sababli, ushbu alternativ UI kutubxonalarning reaktivlik, state menejment, side effect’lar va boshqa jihatlarga qanday yondashuvlari bilan tanishishga tayyorlaning. Ushbu alternativlarni o'rganish orqali biz tanlagan kutubxona yoki freymvorkdan qat'i nazar, muammolarni hal qilish yondashuvimizni boyitadigan qimmatli ma'lumotlar olamiz. JavaScript dunyosi katta va xilma-xil, va biz ushbu sayohatga shiddat bilan sho'ng'ish oldidamiz. Qo'llaringizni bog'lang! Sayohat yanada qiziqarli bo'ladi.",
    "url": "/books/fluent-react/react-server-components/recap/page",
    "category": "books",
    "tags": [
      "fluent-react",
      "tutorial",
      "guide",
      "react",
      "javascript",
      "frontend",
      "react",
      "bilan",
      "biz",
      "ishlash",
      "uchun",
      "ushbu",
      "ning",
      "asosiy",
      "tibor",
      "qanday",
      "qiladi",
      "vue",
      "server",
      "rsc",
      "lar"
    ]
  },
  {
    "id": "book-fluent-react-react-server-components-rules-of-server-components-page",
    "title": "React Server Komponentlar: Qoidalar, Cheklovlar va Server Actions",
    "content": "Server komponentlar qoidalari Endi server komponentlarning qanday ishlashini tushunib yetganimizdan so'ng, server komponentlar bilan ishlashda amal qilishimiz kerak bo'lgan ba'zi qoidalarni, yoki kengroq ma'noda, server komponentlar bilan ishlashda e'tiborga olishimiz kerak bo'lgan jihatlarni muhokama qilamiz. Seriyalashtirish muhim omil Server komponentlar bilan ishlashda barcha props’lar seriyalashtiriladigan bo'lishi kerak. Buning sababi shundaki, server props’larni seriyalashtirib, ularni klientga yuborishi kerak, avval muhokama qilganimizdek. Shuning uchun props’lar server komponentlarda funksiyalar yoki boshqa seriyalashtirilmaydigan qiymatlar bo'lishi mumkin emas. Bu esa, 5-bobda ko'rib chiqqanimiz \"render props\" pattern’ini amalda eskirgan qilib qo'yadi. Ushbu nuqtada, RSC’lar serverda qanday render qilinishi, keyin oson va silliq navigatsiya orqali klientga yuborilish jarayonini tushungan holda, bu qoida nimaga kerakligini tushunishimiz kerak. Misol uchun, agar bizda quyidagicha server komponent bo'lsa: Bu xato keltirib chiqaradi. Ammo, biz ichidagi prop’ini inkapsulyatsiya qilish orqali bu muammoni hal qilishimiz mumkin. Effektli hook’lardan foydalanmaslik Server klientdan keskin farq qiladigan muhitdir. U interaktiv emas, DOM’ga ega emas va unda mavjud emas. Shu sababli, effektli hook’lar server komponentlarda qo'llab-quvvatlanmaydi. Ba'zi freymvorklar, masalan, Next.js, server komponentlarda barcha hook’larni taqiqlovchi lint qoidalariga ega, lekin bu har doim ham zarur emas. RSC’lar state, effektlar yoki faqat brauzerga xos API’larga bog'lanmagan hook’larni ishlatishi mumkin. Masalan, hook’ini server komponentlarda ishlatish mutlaqo to'g'ri, chunki u state, effekt yoki faqat brauzerga xos API’larga bog'liq emas. Biroq, bu yomon bo'lmasligi mumkin, chunki bu bizni komponentlar bilan xavfsizroq ishlashga majbur qilad. State - klient komponentidagi state emas Server komponentlardagi state - klient komponentlardagi state’dan farq qiladi. Chunki server komponentlar serverda, klient komponentlar esa klientda render qilinadi. Bu, server komponentlardagi state bir nechta klientlar orasida umumiy bo'lishi mumkinligini anglatadi, chunki server va klient o'rtasidagi aloqa keng tarqaluvchi (broadcast) usulda amalga oshadi, unicast (bitta klient, bitta state) kabi emas, va shu sababli klientlar o'rtasida state’ni oshkor qilish xavfi yuqori bo'lishi mumkin. Hook’lar qoidasini hisobga olgan holda, yoki kabi state’ga bog'liq komponentlar eng yaxshi klient komponentlar sifatida ishlatilishi tavsiya etiladi. Klient komponentlar server komponentlarni import qilolmaydi Klient komponentlar server komponentlarni import qila olmaydi. Buning sababi, server komponentlar faqat serverda bajariladi, ammo klient komponentlar ham serverda, ham brauzerlarda bajariladi. Masalan, agar bizda quyidagi kabi klient komponenti bo'lsa: bu xato keltirib chiqaradi, chunki klient komponenti server komponentini import qilishga harakat qilmoqda. Server komponentlar faqat serverda bajarilishi sababli, bu komponent Node.js API’larini import qilishi mumkin, va ular klient muhitida mavjud emas, bu esa klientda xatolarga olib keladi. Masalan, server komponenti quyidagicha ko'rinishi mumkin: Agar biz bu komponentni klientda ishlatishga urinib ko'rsak, funksiyasi va moduli brauzerda mavjud emasligi sababli xato yuzaga keladi. Shu sababdan, klient komponentlar server komponentlarni import qila olmaydi. Server komponentlarni props yordamida kompozitsiya qilish Ammo, klient komponentlar server komponentlarni props orqali kompozitsiya qilishi mumkin. Masalan, biz klient komponentini quyidagicha qayta yozishimiz mumkin: Keyin esa, bu klient komponentini o'z ichiga olgan ota server komponentda shunday qilish mumkin: Bu ishlaydi, chunki bu yerda klient komponenti server komponentini aniq import qilmayapti; aksincha, ota server komponent server komponentni props sifatida klient komponentiga uzatmoqda. Importlar orqali cheklov qo'yilishining sababi server komponentlarni klient uchun mo'ljallangan to'plam paketda ko'rish imkoniyatini oldini olishdir, chunki to'plash vositalar(bundlers) faqat import bayonotlariga e'tibor beradi, props orqali kompozitsiyaga esa emas. Klient komponentlar yomon emas Shuni ta'kidlash joizki, server komponentlar joriy etilgunga qadar, klient komponentlar bizda React’da mavjud bo'lgan yagona komponent turi bo'lgan. Bu, mavjud barcha komponentlarimiz klient komponentlar ekanligini anglatadi va bu yomon emas. Klient komponentlar yomon emas va ular yo'qolmaydi. Klient komponentlar React ilovalarining asosi bo'lib qoladi va hali ham eng ko'p yoziladigan komponentlar hisoblanadi. Bu yerda bu mavzuni eslatib o'tishimizning sababi, ayrimlar server komponentlarni klient komponentlarga nisbatan ustunroq deb qabul qilayotganidir. Aslida, bu noto'g'ri. Server komponentlar klient komponentlarga qo'shimcha sifatida ishlatilishi mumkin bo'lgan yangi turdagi komponentdir, lekin klient komponentlar uchun o'rinbosar emas. Server harakatlari (Server actions) Server komponentlar React’da kuchli bo'lgan yangi xususiyat bo'lsa-da, ular yagona yangi xususiyat emas. RSC'lar deb nomlangan yangi direktiva bilan birgalikda ishlaydi, bu direktiva klient kodidan chaqirilishi mumkin bo'lgan server tomonidagi funksiyalarni belgilaydi. Biz bu funksiyalarni _server harakatlari (server actions)_ deb ataymiz. Har qanday asinxron funksiya tanasining birinchi qatorida ni yozish orqali, bu funksiyani klient kodidan chaqirish mumkinligini, lekin faqat serverda bajarilishi kerakligini React va to'plash vositasiga bildiradi. Agar klient tomonda server harakatini chaqirganimizda, u serverga tarmoqli so'rov yuboradi va barcha argumentlarni seriyalashtirilgan holda uzatadi. Agar server harakati qiymat qaytarsa, bu qiymat ham seriyalashtirilib, klientga qaytariladi. Agar alohida funksiyalarni bilan belgilashni xohlamasangiz, fayl boshiga bu direktivani qo'shib, fayldagi barcha eksport qilingan funksiyalarni _server actions_ sifatida belgilashingiz ham mumkin. Bu holatda, ularni klient kodidan ham import qilib ishlatish mumkin bo'ladi. Formalar va mutatsiyalar (Forms and mutations) 8-bobda biz Next.js va Remix qanday qilib formalar va o'zgartirishlarni (mutatsiyalarni) boshqarishi haqida gaplashgan edik. React ham bu funksiyalar uchun birinchi darajali primitivlarni qo'shmoqda (yoki allaqachon qo'shgan). Quyidagi formani ko'rib chiqaylik: Ushbu misolda, formaga server harakati sifatida berilgan. Foydalanuvchi formani yuborganida, server funksiyasiga tarmoqli so'rov amalga oshiriladi. Formada server harakatini chaqirganda, React formaning obyektini server harakatiga birinchi argument sifatida taqdim etadi. Formaga server harakatini sifatida berish orqali, React formani asta-sekin yaxshilaydi. Bu shuni anglatadiki, forma JavaScript to'plam paketi yuklanmasidan oldin yuborilishi mumkin. Formalardan tashqarida Server harakatlari ochiq server so'rov nuqtalari(endpoint) hisoblanadi va klient kodida istalgan joydan chaqirilishi mumkin. Formadan tashqarida server harakatini ishlatishda, biz uni o'tish (transition) jarayonida chaqirishimiz mumkin, bu esa yuklanish indikatorini ko'rsatish, optimistik state yangilanishlarini namoyish qilish va kutilmagan xatolarni boshqarish imkonini beradi. Quyida formadan tashqarida server harakatiga misol keltirilgan: Shunday qilib, server harakatlari React’da klient tomonidagi koddan server tomonidagi funksiyalarni chaqirish imkonini beruvchi kuchli yangi xususiyatdir. Bu funksiyalar asosan kutubxonalar yoki freymvorklar ichida ishlatish uchun mo'ljallangan, chunki ularni an’anaviy (vanilla) React’da ishlatish biroz qiyinchilik tug'dirishi va ko'p moslashtirish ishlari talab etiladi. Biroq, bu juda ko'p qiziqarli foydalanish holatlarini amalga oshirishga imkon beruvchi kuchli xususiyatdir.",
    "url": "/books/fluent-react/react-server-components/rules-of-server-components/page",
    "category": "books",
    "tags": [
      "fluent-react",
      "tutorial",
      "guide",
      "react",
      "javascript",
      "frontend",
      "server",
      "klient",
      "komponentlar",
      "mumkin",
      "emas",
      "state",
      "react",
      "props",
      "ham",
      "chunki",
      "import",
      "lgan",
      "yoki",
      "lar",
      "orqali"
    ]
  },
  {
    "id": "book-fluent-react-react-server-components-serialization-page",
    "title": "React Server Komponentlarida Seriyalashtirish (Serialization)",
    "content": "Seriyalashtirish React elementlarini seriyalashtirishda ish biroz qiyinlashadi. React elementlarini seriyalashtirish dasturiy ta'minotingizni dastlabki yuklanishda to'g'ri va samarali render qilishini ta'minlashning asosiy jihati hisoblanadi, chunki serverdan olingan bir xil renderlangan chiquvchi natija klient bilan mos kelishi kerak, shunda React to'g'ri muvofiqlashtirishi va farqlarni aniqlashi mumkin. Dasturiy ta'minotingiz serverda render qilinayotganda, yaratilgan React elementlari HTML satrlariga aylantirilishi kerak, buning yordamida ularni brauzerga yuborish mumkin. React elementlarini satrlarga, ya'ni string’ga, aylantirish jarayoni seriyalashtirish(serialization) deb ataladi. Odatiy React ilovasi namunasida Odatiy React ilovasida, React elementlari xotirada obyektlar hisoblanadi. Ular chaqirilishi yoki JSX sintaksisi yordamida yaratiladi. Ushbu elementlar komponentning maqsadli renderlanishini ifodalaydi, lekin ular hali real DOM elementlari emas. Ular DOM qanday ko'rinishda bo'lishi kerakligi haqida instruksiyalardir: Serverda kabi funksiya yordamida render qilinayotganda, ushbu React elementlari HTML satrlariga seriyalashtiriladi. Bu seriyalashtirish jarayoni React elementlar daraxtidan o'tib chiqadi, har bir element uchun mos HTML yaratadi va barchasini bitta HTML satriga birlashtiradi: Ushbu HTML satr keyinchalik klientga yuborilishi mumkin, u sahifaning dastlabki markup’i sifatida ishlatiladi. JavaScript to'plam paketi klientda yuklangach, React DOM’ni hidratsiya qiladi, event handler’larni ulaydi va har qanday dinamik kontentni to'ldiradi. Seriyalashtirishning ahamiyati Seriyalashtirish jarayoni bir necha sabablarga ko'ra muhimdir. Birinchi navbatda, bu serverga klientga tezda ko'rsatishga tayyor bo'lgan to'liq HTML markup’ini yuborishga imkon beradi. Bu sahifaning yuklanish vaqtini sezilarli darajada yaxshilaydi, chunki foydalanuvchilar kontent bilan tezroq interaktivlikka kirishishlari mumkin bo'ladi. Shuningdek, React elementlarini HTML satriga seriyalashtirish muhitdan qat'i nazar, bir xil va prognozli dastlabki renderni ta'minlaydi. Yaratilgan HTML statikdir va serverda yoki klientda render qilinganda bir xil ko'rinishga ega bo'ladi. Ushbu muvofiqlik, dastlabki renderning oxirgi renderdan farq qilishi natijasida yuz berishi mumkin bo'lgan miltillashlar yoki joylashuv o'zgarishlarini oldini oladi, bu esa foydalanuvchi bilan ishlash qulayligini yaxshilashga yordam beradi. Oxir-oqibat, seriyalashtirish klient tomonida hidratsiyalash jarayonini osonlashtiradi. JavaScript to'plam paketi klientda yuklanganda, React event handler’larni ulash va har qanday dinamik kontentni to'ldirish kerak bo'ladi. Dastlabki markup sifatida seriyalashgan HTML satrini olish, React uchun ishonchli asosni ta'minlaydi va qayta hidratsiyalash jarayonini samarali va ishonchli qilishga yordam beradi. Seriyalashtirish jarayoni Biz komponentlarni satrlarga seriyalashtirishimiz kerak bo'lsa ham, lekin shunchaki dan foydalana olmaymiz, chunki React elementlari odatiy JavaScript obyektlari emas. Ular React tomonidan ularni aniqlash uchun ishlatiladigan maxsus xususiyatiga ega. Ushbu xususiyatlarning qiymati esa symbol hisoblanadi. Symbol’ni esa seriyalashtirish va tarmoq orqali yuborish mumkin emas, shuning uchun biz boshqa yo'l tutishimiz kerak. Bu jarayonni amalga oshirish oson, chunki JavaScript ishchi muhitlarida, jumladan brauzer va Node.js’da bizga kerakli bo'lgan ichki o'rnatilgan qo'llab-quvvatlash mavjud. Bu qo'llab-quvvatlash va funksiyalari orqali taqdim etiladi. Ushbu funksiyalar JSON obyektlarini seriyalashtirish yoki deseriyalashtirish(seriyadan chiqarish) uchun rekursiv tarzda ishlaydi, bu esa React elementlaridir. Ularning API’si quyidagicha: Bu yerda funksiyasi kalit va qiymatni oladi va ma'lum shartlar bajarilgan taqdirda, almashtirish qiymatini qaytarishi mumkin. Bizning holatimizda, biz qiymatini seriyalashtirish mumkin bo'lgan turga, masalan, string’ga almashtirmoqchimiz. Buni quyidagicha amalga oshiramiz: Deseriyalashtirish (seriyadan chiqarish) Bu holatda endi tayyor! Klient tomonida bu jarayonni deseriyalashtirish uchun, bunga qarama-qarshi jarayonni bajaramiz: Shu bilan biz React elementlarini seriyalashtirish va deseriyalashtirishimiz mumkin. Endi biz serverda server komponentlarini render qilolamiz va ularni klientlarga yubora olamiz. Bu dastlabki yuklashni hal qiladi; ammo, yangilanishlar va navigatsiya bilan ishlashimiz kerak. Avval navigatsiya bilan shug'ullanamiz va keyin yangilanishlarni ko'rib chiqamiz.",
    "url": "/books/fluent-react/react-server-components/serialization/page",
    "category": "books",
    "tags": [
      "fluent-react",
      "tutorial",
      "guide",
      "react",
      "javascript",
      "frontend",
      "react",
      "seriyalashtirish",
      "mumkin",
      "html",
      "dastlabki",
      "bilan",
      "kerak",
      "ushbu",
      "uchun",
      "elementlarini",
      "render",
      "bir",
      "elementlari",
      "biz",
      "chunki"
    ]
  },
  {
    "id": "book-fluent-react-react-server-components-server-komponentlar-ishlashi-page",
    "title": "React Server Komponentlar Qanday Ishlaydi?",
    "content": "Server komponentlar qanday ishlaydi Server komponentlar qanday qilib ishlaydi? Server komponentlari nima ekanligini yaxshiroq tushunish uchun bu mavzuga chuqurroq kiramiz. Kirish qismida aytib o'tilganidek, server komponenti — bu faqat serverda bajariladigan maxsus turdagi komponent. Buni yaxshiroq tushunish uchun, React komponenti shunchaki bir React elementini qaytaradigan funksiyadan boshqa narsa emasligini eslaylik: Ushbu kodda funksiyasi elementini qaytaradi. Tabiiyki, React elementini qaytaradi, chunki React’da belgisi ga sinonim hisoblanadi. Biz buni 2-bobda JSX haqida o'rgangan edik. Agar bu haqida unutgan bo'lsangiz, tezda ushbu mavzuni qayta ko'rib chiqib, davom ettirishingiz mumkin. Oxir-oqibat, barcha komponentlar React elementlarini, ya'ni virtual DOM (vDOM)ni qaytaradi. Server komponentlari ham bundan farq qilmaydi. Agar funksiyasi server yoki klientda bajarilsa, u vDOM’ni qaytaradi. 3-bobda, React elementlari shunchaki quyidagi sxemaga ega JavaScript obyektlari ekanligini ko'rgan edik: funksiyamiz klient yoki server muhitida ishga tushirilsa, React elementini qaytaradi, xuddi yuqoridagi kabi. Server komponentlari esa faqatgina serverda chaqiriladi va elementni ifodalovchi JavaScript obyektini tarmoq orqali klientga yuboradi. Klient komponentlari esa biz odatlangan oddiy React komponentlari hisoblanadi. Afzalliklari Server komponentlarini tushungan holda, ular ba'zi bir asosiy afzalliklarni taqdim etishini ko'ra boshlaymiz: - Serverda bajarilishi: Server komponentlari faqat server tomonida, biz nazorat qiladigan hisoblash quvvatiga ega qurilmalarda bajariladi. Bu esa ancha prognozli ishlash samaradorligini ta'minlaydi, chunki klient qurilmalaridagi noaniq hisoblashlar bilan bog'liq muammolar yo'q. - Xavfsizlik muhiti: Ular bizning xavfsiz server muhitlarimizda bajariladi, shuning uchun server komponentlarida xavfsiz operatsiyalarni bajarishimiz mumkin va tokenlar yoki boshqa xavfsiz ma'lumotlarning sizib chiqishi haqida tashvishlanmasak ham bo'ladi. - Asinxronlik imkoniyati: Server komponentlari asinxron bo'lishi mumkin, chunki biz ularga serverda ishlashni yakunlashlari uchun kutishimiz va natijalarni klientlarga tarmoqlar orqali ulashishimiz mumkin. Bu — server komponentlarining haqiqiy kuchidir. Endi, server komponentlarining server tomonida render qilish (SSR) bilan qanday o'zaro bog'lanishini ko'rib chiqamiz.",
    "url": "/books/fluent-react/react-server-components/server-komponentlar-ishlashi/page",
    "category": "books",
    "tags": [
      "fluent-react",
      "tutorial",
      "guide",
      "react",
      "javascript",
      "frontend",
      "server",
      "react",
      "komponentlari",
      "qaytaradi",
      "komponentlar",
      "qanday",
      "uchun",
      "serverda",
      "elementini",
      "biz",
      "mumkin",
      "ishlaydi",
      "chunki",
      "haqida",
      "yoki"
    ]
  },
  {
    "id": "book-fluent-react-react-server-components-server-rendering-page",
    "title": "Server Komponentlar va Serverda Renderlash (SSR) Aloqasi",
    "content": "Server rendering Biz oldingi boblarda server tomonida render qilishni batafsil muhokama qildik, shuning uchun bu yerda uning tafsilotlariga chuqur to'xtalmaymiz. Asosiy e’tiborimizni server komponentlari va server tomonida render qilishning qanday o'zaro aloqada ishlashiga qaratamiz. Aslini olganda, server komponentlari va serverda render qilishni ikki mustaqil jarayon sifatida tasavvur qilishimiz mumkin. Bunda bir jarayon komponentlarni serverda render qilish va React elementlari daraxtini yaratish bilan shug'ullanadi, ikkinchi jarayon — server renderer — esa bu React elementlari daraxtini markup’ga (HTML formatiga) o'tkazib, tarmoq orqali klientlarga uzatadi. Agar bu ikkita jarayonni ko'rib chiqsak — biri komponentlarni React elementlariga aylantiradi, ikkinchisi esa React elementlarini HTML satrlariga yoki oqim(stream)larga aylantiradi — bu ikkita tushunchaning qanday mos tushishini tushuna boshlaymiz. Birinchi jarayonni _RSC’s renderer_ deb ataymiz, u server komponentlarini React elementlari daraxtiga aylantiradi; ikkinchi jarayon esa _server renderer_ bo'lib, React elementlarini HTML oqimiga aylantiradi. Server komponentlari va server tomonda renderlash Bu tushunchaga asoslanib, server komponentlari va serverda render qilish qanday o'zaro bog'lanishini quyidagicha tushuntirish mumkin: 1. Serverda JSX daraxtini React elementlari daraxtiga aylantirish Masalan, quyidagi JSX daraxtini ko'rib chiqamiz: Bu daraxt quyidagi elementlar daraxtiga aylantiriladi: 2. Serverda elementlar daraxtini satr yoki oqimga aylantirish Ushbu elementlar daraxti keyinroq satrga yoki oqimga seriyalashtiriladi. 3. Klientga katta JSON sifatida yuborish Shu tarzda yaratilgan katta satrga aylantirilgan JSON obyekti klientga uzatiladi 4. Klient tomonida render qilish Klient tomonida React ushbu JSON ma'lumotlarini o'qib, odatdagidek render qiladi. Server kodi Agar bu jarayonni server tomonidagi kod sifatida tasvirlasak, quyidagicha ko'rinishda bo'ladi: Ushbu server kodi 6-bobdan bevosita olingan bo'lib, u yerda server tomonidagi React haqida muhokama qilgan edik. Bu yerda esa, biz server komponentlarini server tomoni renderer'iga uzatishdan oldin ularni qayta ishlash bosqichini qo'shdik — bu bizning misolimizdagi ikkinchi jarayon. Mantiqan olganda, server komponentlari va server tomonidagi renderlash aynan shunday bir-biriga mos keladi: ular bir-birini to'ldiruvchi jarayonlardir. Yana bir bor ta'kidlash joizki, biz bu yerda funksiyasidan faqat namoyish uchun foydalanmoqdamiz. Va 6-bobda ta'kidlanganidek, asosiy foydalanish holatlarida yoki shunga o'xshash asinxron va uzluksiz API’dan foydalanish yaxshiroq bo'ladi. Endi biz _server rendering_ va server komponentlari o'rtasidagi o'zaro aloqani tushunib olganimizdan so'ng, oldingi kodda ishlatilgan funksiyasini chuqurroq o'rganamiz. Bu nima qiladi? Qanday qilib server komponentlarini elementlar daraxtiga aylantiradi? Bu React renderer’i hisoblanadimi? Keling, buni aniqlab olaylik.",
    "url": "/books/fluent-react/react-server-components/server-rendering/page",
    "category": "books",
    "tags": [
      "fluent-react",
      "tutorial",
      "guide",
      "react",
      "javascript",
      "frontend",
      "server",
      "react",
      "render",
      "komponentlari",
      "serverda",
      "jarayon",
      "daraxtini",
      "aylantiradi",
      "biz",
      "tomonida",
      "yerda",
      "qanday",
      "bir",
      "elementlari",
      "esa"
    ]
  },
  {
    "id": "book-fluent-react-react-server-components-under-the-hood-page",
    "title": "React Server Komponentlarining Ichki Mexanizmi (Under the Hood)",
    "content": "Ichki ishlash mexanizmi Qisqa va ba'zan soddalashtirilgan javob: ha, bu React renderer’i hisoblanadi. U yuqori darajadan, masalan, dan boshlanib, rekursiv ravishda React daraxtiga kirib boradi va har bir komponentni chaqirib, uning qaytaradigan React elementi(oddiy JavaScript obyekti)ni oladi. Keling, buni amalga oshirishning namunaviy kodini ko'rib chiqaylik va uning nima qilishi haqida muhokama qilaylik: Ushbu kod parchasini ko'rganingizda, u biroz qo'rqinchli ko'rinishi mumkin bo'lsa-da, aniq aytadigan bo'lsak: bu faqatgina argumentlarga asoslangan katta daraxtidir. Keling, har bir tarmoqni ko'rib chiqaylik va uning qanday ishlashini tushunamiz, avval input argumenti dan boshlaymiz. Birinchi tarmoq(branch) Birinchi tarmoq uchun, agar biz React elementini quyidagicha hisoblasak: Bu yerda bolasi faqatgina string. Agar biz bu string’ni server komponenti renderer'iga topshirsak, uni shunday qoldirishni xohlaymiz. G'oya shundaki, server va klient tomonida React tushunishi mumkin bo'lgan turdagi narsalarni qaytarishdir. React, string, number va boolean’larni server va klient tomonida tushunishi va render qilishi mumkin, shuning uchun ularni shunday qoldiramiz. Massivlarni qayta ishlash Keyingi bosqichda, agar bizda massiv bo'lsa, uni metodi orqali yurib chiqamiz va har bir elementni rekursiv ravishda bizning funksiyamiz orqali qayta ishlaymiz. Massivlar bir qancha bolalarni o'z ichiga olishi mumkin, masalan: Masalan, Fragment’lar bolalarni massiv sifatida ifodalaydi. Shunday qilib, biz shunchaki ularni har bir bola uchun rekursiv chaqirib qayta ishlaymiz va davom etamiz. Obyektlar bilan ishlash Keyingi qismda juda qiziqarli bo'ladi: obyektlarni qayta ishlaymiz. Unutmangki, barcha React elementlari obyektlardir, lekin barcha obyektlar React elementlari emas. Qanday qilib biz obyektning React elementi ekanligini bilamiz? U xususiyatiga ega bo'lib, bu symbol qiymatini oladi — aniqrog'i, . Shuning uchun, biz obyekt bu kalit/qiymat juftligiga ega ekanligini tekshiramiz va agar mavjud bo'lsa, uni React elementi sifatida qayta ishlaymiz. Bu qismdagi kodda buni qilamiz: Yana bir tekshiruv Agar shartli bayonotining haqiqiy tarmog'ida bo'lsak, yana bir tekshiruv o'tkazamiz: qiymati yoki mi? Buni biz React elementlari ikkisini ham tur sifatida olishi mumkinligi uchun qilamiz. String’lar oddiy DOM elementlari, masalan, , kabi ishlatiladi. Funksiyalar esa maxsus komponentlar, masalan, uchun ishlatiladi. Agar bu string bo'lsa, u oddiy DOM elementi ekanligini bilamiz, shuning uchun uni shunday qoldiramiz, lekin uning props’larini rekursiv chaqiramiz — chunki uning props’lari bolalarga ega bo'lishi mumkin bo'lgan concurrent React komponentidir. Agar bu funksiya bo'lsa, u maxsus komponent ekanligini bilamiz, shuning uchun uni props’lari bilan chaqiramiz va rekursiv ravishda qaytarilgan JSX ustida funksiyamizni chaqiramiz. Bu jarayon oxir-oqibatda string, number, boolean, yoki ushbu turlardan iborat array yoki string turidagi React elementi qaytarguncha davom etadi. Bu boshqa tarmoqqa tushishi mumkin. va server komponentlari Biz funksional komponentni chaqirishimizdan oldin ni e'tiborga olishimiz kerak. Bu server tomonida bajarilayotgani sababli, agar bu server komponenti bo'lsa, funksional komponentni kutishimiz mumkin! Server komponentlarining sirli tomoni shundaki, biz ularni serverda orqali kutishimiz mumkin va ular bizga React elementini qaytaradi. Keyinchalik, biz uni yoki ga uzatib, klientga yuborilishi mumkin bo'lgan string yoki string’lar oqimiga render qilishimiz mumkin. Haqiqatan ham, bizning funksiyamiz shuni amalga oshiradi: u rekursiv ravishda barcha asinxron narsalarni kutmoqda, natijada elementlar daraxtini (JavaScript obyekti) ishlab chiqaradi va uning barcha ma'lumotlar qaramliklari hal qilinadi. Oddiy obyektlar bilan ishlash Nihoyat, agar obyekt React elementi bo'lmasa, demak, u oddiy obyekt ekanligini bilamiz, shuning uchun biz rekursiv ravishda funksiyamizni obyekt ichidagi har bir qiymatga chaqiramiz va natijani qaytaramiz. Odatda, obyekt faqat props’larni o'z ichiga oladi, shuning uchun tarmog'ida, biz shunchaki har bir prop qiymatiga rekursiv ravishda funksiyamizni chaqiramiz va natijani qaytaramiz, bu esa _render props_ kabi pattern’lar orqali props sifatida berilishi mumkin bo'lgan har qanday komponentlarni samarali tarzda ochadi, bu haqida 5-bobda muhokama qilingan. Minimal RSCs Renderer Shu bilan, bizning minimal RSCs renderer’imiz tugadi. Bu mukammal emas, lekin yaxshi boshlanishdir. Biz uni server komponentlarimizni React elementlariga render qilish uchun ishlatishimiz mumkin, keyin esa ularni klientlarga yuboramiz. Bu jarayonni yakunlagach, biz uni yoki ga uzatyapmiz, yoki hatto uni seriyalashtirib, to'g'ridan-to'g'ri brauzerga yuborishimiz mumkin. Klient tomonida React uni render qilishi mumkin, chunki bu, asosan, React tushunishi mumkin bo'lgan React elementlaridan iborat daraxtdir. Biroq, bu jarayonda hal qilishimiz kerak bo'lgan yana bir muammo bor: _seriyalashtirish_.",
    "url": "/books/fluent-react/react-server-components/under-the-hood/page",
    "category": "books",
    "tags": [
      "fluent-react",
      "tutorial",
      "guide",
      "react",
      "javascript",
      "frontend",
      "react",
      "mumkin",
      "biz",
      "uchun",
      "bir",
      "uni",
      "agar",
      "string",
      "server",
      "rekursiv",
      "har",
      "yoki",
      "ravishda",
      "uning",
      "elementi"
    ]
  },
  {
    "id": "book-fluent-react-server-side-react-creating-server-rendering-page",
    "title": "React'da SSR'ni O'zimiz Yaratamiz: Client-Only Ilovani Kengaytirish",
    "content": "Serverda renderlash jarayonini yaratish Agar sizda avvaldan mavjud bo'lgan faqat klient(client-only) React ilovasi bo'lsa, unga qanday qilib server tomonda render qilishni qo'shish haqida o'ylayotgan bo'lishingiz mumkin. Yaxshiyamki, mavjud React ilovasiga serverda render qilishni qo'shish nisbatan oson. Bir yondashuv sifatida serverda render qilish uchun Next.js yoki Remix kabi serverda render qilish freymvorklaridan foydalanishdir. Bu freymvorklar, albatta, server tomonidan render qilingan React ilovalarini yaratishning eng yaxshi usuli bo'lsa-da, bunday abstraksiyalar, bizning bu serverda renderlash jarayonining asosiy mexanizmlar qanday ishlashiga bo'lgan qiziqishimizni orttirishi va u bilan tanishishga undashi mumkin. Agar siz qiziquvchan inson bo'lsangiz va faqat klientga mo'ljallangan React ilovasiga serverda render qilishni qanday qo'shish haqida qiziqsangiz, yoki freymvorklar buni qanday amalga oshirayotganini bilmoqchi bo'lsangiz, mavzuni o'qishda davom etishingiz mumkin. Yana bir bor eslatib o'tamiz, ehtimol bu narsalarni siz \"production\" muhitida ishlatmassiz, biroq bularni shunchaki qiziqish uchun va ta'lim maqsadlarida ko'proq o'rganamiz. \"Client-only\" React ilovasiga server renderlashni o'zimiz qo'shamiz Agar sizda faqat klient-tomoni React ilova bo'lsa, unga qanday qilib server render qilishni qo'shishingiz mumkin. Birinchi navbatda, loyiha ildizida _server.js_ faylini yaratasiz. Ushbu fayl sizning serveringiz kodini o'z ichiga oladi: Ushbu misolda, biz _Express_'dan foydalanib, _./build_ katalogidan statik fayllarga xizmat ko'rsatadigan server yaratmoqdamiz va keyin React ilovamizni serverda render qilmoqdamiz. Biz, shuningdek, React ilovamizni HTML satriga render qilish va uni klientga yuboriladigan javobga kiritish uchun dan foydalanmoqdamiz. Ushbu misolda, bizning faqat klientga mo'ljallangan React ilovamizda, _build_ deb nomlangan katalogga JavaScript to'plam paketini natija sifatida chiqaradigan turli xil skripti mavjud bo'lishini faraz qilamiz. Bu _hidratsiyalash_ uchun muhimdir. Barcha qism tayyor bo'lgach, serverni ishga tushirish uchun quyidagi buyruqni ishlatamiz: Ushbu buyruqni ishga tushirganda, server 3000-portda ishga tushishi va konsolga xabarini chiqarishi kerak. Ushbu qadamlar bilan endi bizda serverda render qilingan React ilovasi bor. Ushbu \"ichki ishlash mexanizmiga zimdan qarash\" yondashuvi orqali, biz serverda render qilish qanday ishlashini va bu bizning React ilovalarimizga qanday foyda keltirishini chuqurroq tushunamiz. Agar brauzerni ochib, http://localhost:3000 ga tashrif buyursak, serverda render qilingan ilovani ko'rishimiz mumkin. Bu bo'sh dokument o'rniga haqiqiy HTML markup’ini ko'rsatishi kerak bo'lgan ushbu sahifaning manba kodini ko'rish orqali, serverda render qilinganligini tasdiqlashimiz mumkin. HTML Markup To'liq HTML markup quyidagicha ko'rinishga ega bo'lishi kerak: Ushbu HTML markup klientga yuboriladi. U bizning React ilovamiz uchun to'liq render qilingan HTML’ni o'z ichiga oladi, bu esa qidiruv tizimlari tomonidan indekslanishi va sekin yoki ishonchsiz internet aloqasiga ega foydalanuvchilar uchun samaraliroq foydalanish imkoniyati qulayligini ta'minlaydi. Bu, o'z navbatida, bizning React ilovamiz uchun SEO va yaxshilangan foydalanish imkoniyati qulayliklarini ta'minlaydi. Hidratsiyalash Serverda render qilingan natija foydalanuvchilarga yetib borishi bilan, hidratsiyalash jarayoni bizning klient to'plam paketimizni fayl oxirida teg bilan yuklashimizda ro'y beradi. Avval muhokama qilganimizdek hidratsiyalash - bu serverda yaratilgan va klientga yuborilgan statik HTML’ga event listener’larni va boshqa JavaScript funksiyalarini biriktirish jarayoni ekanligini ta'kidlagan edik. Hidratsiyalashning maqsadi, serverda render qilingan ilovaga brauzerda yuklangandan keyin to'liq interaktiv bo'lish imkonini berishdir. Agar biz ilovamizning klient tomonidagi to'plam paketining hidratsiyalash qadamini o'rganmoqchi bo'lsak, quyidagi kabi ko'rinishda bo'ladi: Server tomonda render qilish va klientni hidratsiyalash bilan ilovamiz to'liq interaktiv holatga keladi va foydalanuvchi kiritishlariga javob bera oladi, ma'lumotlarni yuklaydi va DOM’ni zarur bo'lganda yangilaydi.",
    "url": "/books/fluent-react/server-side-react/creating-server-rendering/page",
    "category": "books",
    "tags": [
      "fluent-react",
      "tutorial",
      "guide",
      "react",
      "javascript",
      "frontend",
      "render",
      "serverda",
      "react",
      "uchun",
      "ushbu",
      "qanday",
      "server",
      "html",
      "mumkin",
      "qilingan",
      "bizning",
      "agar",
      "qilish",
      "bilan",
      "klientga"
    ]
  },
  {
    "id": "book-fluent-react-server-side-react-dont-roll-your-own-page",
    "title": "Nega SSR uchun Freymvork Ishlatish Kerak? O'zingiz Ixtiro Qilmang",
    "content": "O'zingiz ixtiro qilmang React ilovasi uchun maxsus serverda render qilishni yaratish murakkab va ko'p vaqt talab qiluvchi vazifa bo'lishi mumkin. React serverda render qilish uchun ba'zi API’larni taqdim etsa ham, o'zingiz noldan butunlay maxsus yechim yaratish turli muammolar va samarasizliklarga olib kelishi mumkin. Ushbu bo'limda biz nima uchun Next.js va Remix kabi mavjud freymvorklarga tayangan holda ishlash, o'z serveringizni yaratishga qaraganda afzal ekanligini ko'rib chiqamiz: Kutilmagan holatlarni va murakkabliklarni boshqarish React ilovalari juda murakkablashishi mumkin va serverda render qilishni amalga oshirishda turli xil kutilmagan holatlar(edge cases) va murakkabliklarni hal qilish talab etiladi. Bularga asinxron ma'lumot olishni boshqarish(data fetching), kodni bo'lib yuklash(code splitting) va React’ning turli xil lifecycle’larini boshqarish kiradi. Next.js yoki Remix kabi freymvorklarni ishlatish orqali siz bu murakkabliklarni o'zingiz hal qilish zaruriyatidan qutulasiz, chunki bu freymvorklar ko'plab umumiy kutilmagan holatlar uchun o'z yechimlariga ega. Xavfsizlik muammosi Bunday kutilmagan holatlardan biri xavfsizlikdir. Server ko'plab klientlar so'rovlarini qayta ishlaganda, bir klientning maxfiy ma'lumotlari boshqa klientga beixtiyor tarqalib ketmasligiga ishonch hosil qilish juda muhim. Bu yerda Next.js, Remix va Gatsby kabi freymvorklar ushbu xavotirlarni boshqarishda bebaho yordam berishi mumkin. Aytaylik, klient A serverga murojaat qiladi va ularning ma'lumotlari server tomonidan keshlanadi. Agar server bu keshlangan ma'lumotni tasodifan klient B’ga yuborsa, maxfiy ma'lumotlar fosh bo'lishi mumkin. Ushbu misolni ko'rib chiqaylik: Ushbu kodda foydalanuvchi ma'lumotlarini keshlash uchun mo'ljallangan, ammo u barcha so'rovlar uchun dan qat'i nazar umumiydir. Har safar ga so'rov yuborilganda, server ’ni tekshiradi va agar keshda ma'lumot mavjud bo'lsa, mos kelishi yoki mos kelmasligidan qat'i nazar keshdagi ma'lumotlarni qaytaradi. Agar keshda ma'lumot bo'lmasa, uni olish, keshlash va qaytarish jarayonini bajaradi. Bu shuni anglatadiki, agar ketma-ket va ga ikkita so'rov yuborilsa, ikkinchi so'rov birinchi foydalanuvchining ma'lumotlarini olishi mumkin, bu esa katta xavfsizlik muammosidir. Xavfsizroq keshlash strategiyasi Keshni har bir foydalanuvchiga alohida bog'lash uchun bilan bog'liq holda keshlash yaxshiroq strategiya bo'lar edi. Buni amalga oshirishning bir usuli, ni kalit sifatida ishlatadigan obyekt yordamida keshlangan ma'lumotlarni saqlashdir. Agar o'z yechimimizni yaratishga urinadigan bo'lsak, inson xatosi xavfi doimo mavjud bo'ladi. Katta jamoalar tomonidan yaratilgan freymvorklarga tayanadigan bo'lsak, bu xavf kamayadi. Ushbu freymvorklar xavfsizlikni hisobga olgan holda ishlab chiqilgan va maxfiy ma'lumotlarning to'g'ri boshqarilishini ta'minlaydi. Ishlash samaradorligini optimizatsiya qilish Freymvorklar odatiy holda ko'plab ishlash samaradorligi optimizatsiyalari bilan birga keladi. Ushbu optimizatsiyalar avtomatik kodni bo'lib yuklash, serverda render qilish va keshlashni o'z ichiga olishi mumkin. Maxsus(custom) server tomonida render qilish yechimini yaratish bu optimizatsiyalarni dastlabki holda o'z ichiga olmaydi va ularni amalga oshirish murakkab hamda ko'p vaqt talab qilishi mumkin. Masalan, Next.js 13 va undan oldingi versiyalarda sahifalarga asoslangan kodni bo'lib yuklash(code-splitting), ishlash samaradorligini sezilarli darajada yaxshilashi mumkin. Har bir sahifa avtomatik tarzda o'ziga xos to'plam paketiga ajratiladi va faqat sahifa so'ralganda yuklanadi. Bu dastlabki to'plam paket hajmini kamaytirib, birinchi baytni yuborish vaqtini (TTFB) yaxshilashga yordam beradi. Dasturchi bilan ishlash qulayligi va unumdorligi Maxsus server tomonida render qilish yechimini yaratish murakkab va ko'p vaqt talab qilishi mumkin. Next.js yoki Remix kabi freymvorklardan foydalanish orqali dasturchilar ilova uchun funksiyalar va imkoniyatlar yaratishga e'tibor qaratishlari mumkin, serverning asosiy infrastrukturasini boshqarish haqida qayg'urmasdan. Bu unumdorlikni oshiradi va umumiy dasturchi bilan ishlash qulayligini yaxshilaydi. Eng yaxshi amaliyotlar va konvensiyalar Next.js yoki Remix kabi freymvorklardan foydalanish loyihangizda eng yaxshi amaliyotlar va konvensiyalarni qo'llashga yordam beradi. Ushbu freymvorklar eng yaxshi amaliyotlarni hisobga olgan holda ishlab chiqilgan va ularning konvensiyalariga rioya qilish orqali ilovangiz mustahkam poydevorga asoslangan holda yaratilishini ta'minlashingiz mumkin. Next.js va Remix kabi mavjud freymvorklar tomonidan taqdim etilgan afzalliklar va optimizatsiyalarni hisobga olganda, React ilovasi uchun alohida bir server tomonda render qilish yechimini yaratish maqbul yondashuv emasligi aniq bo'ladi. Ushbu freymvorklardan foydalanish orqali siz ishlab chiqish vaqtini tejashingiz, eng yaxshi amaliyotlarga rioya qilinishini ta'minlashingiz va ularning tegishli jamoalari tomonidan taqdim etilgan doimiy yangilanishlar va qo'llab-quvvatlashdan foyda olishingiz mumkin.",
    "url": "/books/fluent-react/server-side-react/dont-roll-your-own/page",
    "category": "books",
    "tags": [
      "fluent-react",
      "tutorial",
      "guide",
      "react",
      "javascript",
      "frontend",
      "mumkin",
      "uchun",
      "qilish",
      "ushbu",
      "render",
      "next",
      "holda",
      "server",
      "remix",
      "kabi",
      "ishlash",
      "freymvorklar",
      "react",
      "yaratish",
      "bir"
    ]
  },
  {
    "id": "book-fluent-react-server-side-react-hydration-page",
    "title": "React'da Hidratsiya (Hydration) va Davom Ettiruvchanlik (Resumability)",
    "content": "Hidratsiya (Hydration) Hidratsiya — bu serverda yaratilgan va klientga yuborilgan statik HTML’ga event listener’larni va boshqa JavaScript funksiyalarini biriktirish jarayonini ifodalovchi atama. Hidratsiyaning maqsadi, server tomonida render qilingan ilovaning brauzerda yuklangandan so'ng to'liq interaktiv holatga o'tishini ta'minlashdir, bu foydalanuvchilarga tez va silliq ishlash qulayligini taqdim etadi. React ilovasida hidratsiya jarayoni React ilovasida hidratsiya jarayoni klient serverdan render qilingan React ilovasini yuklagandan so'ng boshlanadi. Keyin quyidagi qadamlar sodir bo'ladi: - Klient to'plam paketini yuklash: Brauzer statik HTML’ni render qilayotganda, u ilovaning kodini o'z ichiga olgan JavaScript to'plam paketini ham yuklaydi va tahlil qiladi. Ushbu paket React komponentlarini va ilovaning funksionalligi uchun zarur bo'lgan boshqa kodlarni o'z ichiga oladi. - Event listener’larni biriktirish: JavaScript to'plam paketi yuklanganidan so'ng, React statik HTML’ni “hidratsiya” qiladi, DOM elementlariga event listener’larni va boshqa dinamik funksiyalarni biriktirish orqali. Bu odatda dan funktsiyasi yordamida amalga oshiriladi, bu esa ildiz React komponenti va DOM konteynerini argument sifatida oladi. Hidratsiya asosan statik HTML’ni to'liq interaktiv React ilovasiga aylantiradi. Hidratsiya jarayonida muhim nuqta Hidratsiya jarayoni tugagandan so'ng, ilova to'liq interaktiv holatga keladi va foydalanuvchining interaktivlik kiritishlariga javob bera oladi, ma'lumotlarni olib kelishi va kerak bo'lganda DOM’ni yangilashi mumkin. Hidratsiya davomida React statik HTML’dagi DOM elementlarining strukturasini JSX orqali aniqlangan React komponentlarining strukturasi bilan moslashtiradi. React komponentlari tomonidan yaratilgan struktura, statik HTML strukturasi bilan mos kelishi juda muhimdir. Agar mos kelmasa, React event listener’larni to'g'ri biriktirish imkoniyatiga ega bo'lmaydi va qaysi React elementi qaysi DOM elementiga to'g'ri kelishini bilmaydi, bu esa ilovaning kutilganidek ishlamasligiga olib keladi. Server tomonda renderlash va hidratsiyani birlashtirib, dasturchilar tez yuklanadigan va silliq, interaktiv foydalanuvchi bilan ishlash qulayligini taqdim etadigan veb-ilovalarni yaratishlari mumkin. Hidratsiyaning salbiy jihatlari Hidratsiya server tomonidan render qilingan HTML’ni interaktiv qilishning yaxshi usuli bo'lsa-da, ba'zilar hidratsiyani keraksiz darajada sekin deb tanqid qiladilar, ko'pincha davom ettiruvchanlik qobiliyati(resumability)ni ustun muqobil sifatida keltiradilar (rasmga qarang). Keling, bu masalani biroz o'rganamiz. !Hidratsiya Hidratsiya jarayonida biz React ilovasini serverda render qilamiz va keyin render qilingan natijani klientga jo'natamiz. Biroq, bu vaqt davomida hech narsa interaktiv emas. Bu nuqtadan boshlab, brauzerimiz klient to'plam paketini yuklashi, event listener’larni biriktirishi va samarali ravishda klientni “qayta render” qilishi kerak. Bu ko'p ish va ba'zida foydalanuvchi uchun kontent paydo bo'lgan vaqti bilan foydalanuvchi saytdan foydalanish imkoniyati o'rtasida kechikish yuzaga kelishi mumkin. Davom ettiruvchanlik qobiliyati (Resumability) Boshqa tomondan, Davom ettiruvchanlik qobiliyati biroz boshqacha ishlaydi (rasmga qarang). !Resumability _Davom ettiruvchanlik qobiliyati_ bilan, butun ilova serverda render qilinadi va brauzerga uzluksiz uzatishlik(stream) tarzida jo'natiladi. Dastlabki markup bilan birga, barcha interaktiv xatti-harakatlar ham seriyalangan holda klientga yuboriladi. Klient, shu tariqa, interaktiv bo'lish uchun zarur bo'lgan barcha ma'lumotlarga ega bo'ladi va shu bilan server qoldirgan joydan davom etishi mumkin. U hidratsiya qilishi (ya'ni, event listener’larni biriktirishi va sahifani klient tomonida render qilishi) shart emas, aksincha server bergan ma'lumotlarni deserializatsiya qilib, mos ravishda javob berishi mumkin. Hidratsiya bosqichini o'tkazib yuborish interaktivlik uchun sarflanadigan vaqtni (TTI) tezlashtirishi va foydalanuvchi bilan ishlash qulayligini yaxshilashi mumkin. Davom ettiruvchanlik qobiliyatining o'lchovli afzalliklari bor, ammo muhandislik jamoasida \"buni amalga oshirish murakkabligi foydasiga arziydimi yoki yo'qmi?\" degan savol tug'ilishi mumkin. Haqiqatan ham, bu hidratsiyadan ko'ra murakkabroq yondashuvdir va afzalliklari xarajatlarni oqlaydimi yoki yo'qmi hali aniq emas: ha, interaktivlikka o'tish vaqti bir necha millisekundga tezlashadi, lekin \"resumability\" texnikasini amalga oshirish murakkabligiga arziydimi? Bu savol hali ham React jamoasida qizg'in muhokamada.",
    "url": "/books/fluent-react/server-side-react/hydration/page",
    "category": "books",
    "tags": [
      "fluent-react",
      "tutorial",
      "guide",
      "react",
      "javascript",
      "frontend",
      "hidratsiya",
      "react",
      "render",
      "interaktiv",
      "bilan",
      "html",
      "mumkin",
      "statik",
      "event",
      "listener",
      "larni",
      "davom",
      "ettiruvchanlik",
      "server",
      "klient"
    ]
  },
  {
    "id": "book-fluent-react-server-side-react-limitations-of-client-side-rendering-page",
    "title": "Klient Tomonda Renderlash Cheklovlari: SEO, Performance va Xavfsizlik",
    "content": "Klient tomonda render qilishning cheklovlari 2013-yilda ochiq manba dastur sifatida chiqarilgandan beri React yordamida foydalanuvchi interfeyslarini yaratish davom etmoqda. Natijada, ushbu yondashuv bilan bog'liq bir qator cheklovlar paydo bo'ldi. Bu cheklovlar vaqt o'tishi bilan ko'proq ishlarni server tomoniga ko'chirishga olib keldi. SEO (Qidiruv tizimlari uchun optimallashtirish) Klient tomonida render qilishning asosiy cheklovlaridan biri, qidiruv tizimi botlari kontentni to'g'ri indekslay olmasligi mumkin emas, chunki ularning ba'zilari JavaScriptni bajarishmaydi yoki bajaradiganlari ham biz kutgandek ishlamaydi. Qidiruv tizimi botlarining turli xil yondashuvlarini hisobga olib, ularning qanday ishlashi ko'pchilik omma uchun aniq bo'lmaganligi tufayli, _faqat klient_ tomonida render qilish orqali yaratilgan veb-sayt yoki ilova qamrovi biroz noma'lum bo'lib qoladi. 2015-yilda Search Engine Land nashrida chop etilgan maqola qidiruv tizimlarining turli xil tajribalar yordamida _faqat klient_ tomonida yaratilgan ilovalar bilan qanday ishlashini sinab ko'rishni maqsad qilgan edi. Maqolada quyidagilar aytilgan: <Callout type=\"info\"Biz bir qator sinovlar o'tkazdik va Google turli xil yondashuvlar bilan JavaScript’ni bajarish va indekslash imkoniyatiga ega ekanligini tekshirdik. Shuningdek, Google butun sahifani ko'rsatish va DOM’ni o'qish orqali dinamik yaratilgan kontentni indekslashi mumkinligini tasdiqladik. </CalloutBu maqola bo'yicha Google va Bing _faqat klient_ tomonidagi (client-only) veb-saytlarni indekslash uchun yetarli darajada takomillashganligi aniqlanadi, lekin bu aslida keng va noma'lum texnologiyalar okeanidagi bir tadqiqotning natijasi hisoblanadi. \"Client-only\" ilovalarda mavjud ba'zi xavflar Shunday qilib, zamonaviy qidiruv tizimlari bilan _faqat klient_ tomonidagi ilovalar yaxshi ishlashi mumkin bo'lsa-da, server tomonida bo'lmaganligi tufayli biroz xavf bor. An'anaviy veb-ilovalarda, foydalanuvchi yoki qidiruv tizimi boti sahifani olish uchun so'rov yuborganda, server sahifaning HTML kodini ishlab chiqaradi va uni qaytaradi. HTML’da barcha kontent, havolalar va ma'lumotlar mavjud bo'lib, bu qidiruv tizimi botlariga sahifani o'qish va indekslashni osonlashtiradi, chunki sahifaning barcha mazmuni shunchaki matndan, ya'ni markup’dan iborat bo'ladi. Biroq, React kabi kutubxona yoki freymvork yordamida yaratilgan klient tomonida render qilinadigan ilovada, server deyarli bo'sh HTML faylni qaytaradi, uning yagona vazifasi o'sha serverda yoki boshqa alternativ serverda joylashgan JavaScript faylini yuklashdan iborat. JavaScript fayli keyin yuklanadi va brauzerda bajariladi, bu esa sahifa kontentini dinamik ravishda ko'rsatadi. Ushbu yondashuv tabiiy ilovalarnikiga o'xshash silliq foydalanuvchi bilan ishlash qulayligini taqdim etadi, lekin qidiruv tizimlari uchun optimallashtirish (SEO) va ishlash samaradorligi(performance) borasida bir kamchiligi bor: biz birinchi so'rovda odamlar uchun foydali bo'lgan hech qanday narsani yuklamaymiz, balki sahifa yuklanishi bilan darhol butun saytni ishga tushiradigan JavaScript faylini yuklash uchun boshqa so'rov yuborishimiz kerak bo'ladi. Bu \"tarmoq sharsharasi\"(network waterfall) deb ataladi. Shunday qilib, _faqat klient_ tomonida render qilishning yana bir kamchiligi ishlash samaradorligidir. Endi bu haqda gaplashamiz. Ishlash samaradorligi (Performance) Klient tomonida render qilinadigan ilovalar ayniqsa sekin tarmoqlar yoki kuchsiz qurilmalarda ishlash muammolariga duch kelishi mumkin. JavaScript’ni yuklash, tahlil qilish va bajarish kerak bo'lgani uchun, kontentni render qilishda sezilarli kechikishlar yuzaga kelishi mumkin. Bu \"interaktivlik vaqti\" juda muhim ko'rsatkich bo'lib, u foydalanuvchi ishtiroki va sahifani samaradorlik ko'rsatkichi(bounce rates)ga bevosita ta'sir qiladi (foydalanuvchilar sahifani tark etish tezligiga o'xshaydi). Foydalanuvchilar sahifa yuklanishi uchun uzoq vaqt talab qilsa, sahifani tark etishlari mumkin va bu xatti-harakat sahifaning SEO reytingiga ham salbiy ta'sir qilishi mumkin. Bundan tashqari, agar qurilma kam quvvatli bo'lib, minimal protsessor imkoniyatlariga ega bo'lsa, faqat klient tomonida render qilish foydalanuvchining xafsalasini pir qilishi mumkin. Buning sababi, qurilma JavaScript’ni tezda bajarish uchun yetarli hisoblash quvvatiga ega bo'lmasligi mumkin, bu esa ilovaning sekin va javobsiz bo'lishiga olib keladi. Agar biz ushbu JavaScript’ni serverda bajarsak va klientga minimal ma'lumot yoki markup’ni yuborsak, kam quvvatli qurilmalar ko'p ish qilishi shart emas va shu sababli foydalanuvchi bilan ishlash qulayligi yaxshilanadi. Keng miqyosda, klient tomonida render qilinadigan ilovalarda SEO va ishlash samaradorligi bilan bog'liq muammolar veb standartlari va eng yaxshi amaliyotlarga rioya qilishning ahamiyatini ko'rsatadi. Shuningdek, kontentni yuqori samarali va foydalanish imkoniyati qulay bo'lgan tarzda yetkazib berish uchun server tomonida render qilish yoki statik saytlar yaratish kabi ishonchli alternativlarning zarurligini ta'kidlaydi, ayniqsa kontentga boy saytlar yoki ilovalar uchun. Progressiv yaxshilanish tamoyili Progressiv yaxshilanish tamoyili asosiy kontent va funksionallikni barcha brauzerlarga yetkazishni nazarda tutadi, takomillashgan xususiyatlar esa yaxshilanish sifatida ko'rib chiqiladi va alternativlar bilan yaxshi mos keladi. Kontentning asosiy tub qismini server tomonida render qilish orqali barcha foydalanuvchilar va qidiruv tizimlari JavaScript bajarilishidan qat'i nazar, asosiy kontent va funksiyaga kirish imkoniyatiga ega bo'lishini ta'minlagan bo'lasiz. Keyin, klient tomonidagi JavaScript interaktivlikni qo'shish, animatsiyaga boy bo'lgan va boshqa takomillashgan funksiyalarni qo'shib foydalanuvchi bilan ishlash qulayligini yaxshilaydi, bu brauzerlar va qurilmalar bunga tayyor bo'lganda amalga oshiriladi. Barcha tajribani faqat klient tomonidagi JavaScriptga bog'lash hech qanday ma'noga ega emas, chunki bu vebning asl dizayni emas. JavaScript’ning roli veb sahifani _yaxshilashdan_ iborat, veb sahifani _o'zi bo'lish_ emas. Keling, ushbu misolni ko'rib chiqaylik: Yuqoridagi misolda biz API orqali ma'lumotlarni klient tomonida olib kelib, ularni render qilmoqdamiz. Bu klient tomonida ekanligini hook’idan foydalanayotganimizdan bilamiz, chunki hooki faqat brauzerda (klientda) bajariladi. Ma'lumotlar hook’ida saqlanadi va sahifa yuklangandan so'ng ma'lumotlar API orqali olinadi. Klient tomonida render qilishning jiddiy cheklovlari Bu uslubning jiddiy cheklovlaridan biri shundaki, ba'zi qidiruv tizimi botlari ushbu kontentni ko'ra olmasligi mumkin, agar biz server tomonida render qilishni amalga oshirmasak. Bunday holatda, ular bo'sh ekran yoki vaqtinchalik muqobil xabarini ko'rishi mumkin, bu esa saytdagi SEO natijalariga salbiy ta'sir o'tkazishi mumkin. Yana bir keng tarqalgan muammo — tarmoq sharsharalari (network waterfalls). Bu holatda dastlabki sahifa yuklanishi brauzer tomonidan yuklanishi, tahlil qilinishi va bajarilishi kerak bo'lgan JavaScript miqdori bilan bloklanadi. Tarmoq ulanishi cheklangan resurs bo'lgan holatlarda, bu veb-sayt yoki ilovani sezilarli vaqt davomida to'liq javobsiz holga keltirishi mumkin. Yuqoridagi misolda biz tashqi API (https://api.example.com/data) orqali ma'lumotlarni olish uchun so'rov yubormoqdamiz. Ushbu so'rov dastlabki JavaScript to'plam paketimiz yuklanib, tahlil qilinib, bajarilgandan so'ng amalga oshiriladi va bu faqat dastlabki HTML yuklangandan keyin sodir bo'ladi. Bu tarmoq sharsharasiga olib keladi va samaradorlik past bo'ladi. Agar biz buni tasavvur qilmoqchi bo'lsak, shunday ko'rinishda bo'lardi: !Ma'lumotni olish so'rovi Server tomonida render qilish orqali yaxshiroq natijaga erishish Server-tomonli renderlash bilan biz yaxshiroq natijaga erishishimiz va foydalanuvchilarga darhol foydali mazmundagi kontentni ko'rish imkonini berishimiz mumkin, diagrammani quyidagicha o'zgartirgan holda. _HTML’ni yuklash (to'liq UI, ma'lumot serverda olingan holda)_ Darhaqiqat, dastlabki yuklanishda foydalanuvchi uchun foydali bo'lgan ma'lumotlar mavjud, chunki biz ma'lumotlarni oldindan olib, komponentni serverda render qilganmiz. Bu yerda hech qanday tarmoq sharsharasi yo'q va foydalanuvchi barcha kerakli ma'lumotlarni darhol oladi. Bu server-tomonda renderlashning foydali jihatidir. React 18 versiyasi va yuklama hajmlari React 18 versiyasidan boshlab, React va React DOM paketlarining hajmi mos ravishda 6.4 kB va 130.2 kB ni tashkil qiladi. Ushbu hajmlar dokumentatsiyamiz yozilgan paytdagi eng yangi versiya uchun berilgan bo'lib, siz hozirda foydalanayotgan React versiyasi va konfiguratsiyasiga qarab o'zgarishi mumkin. Bu shuni anglatadiki, foydalanish(production) muhitida ham foydalanuvchilar faqat React uchun (ya'ni, React + React DOM) taxminan 136 kB JavaScript yuklab olishlari kerak bo'ladi, undan keyin esa ilovaning qolgan kodini yuklash, tahlil qilish va bajarish jarayoni boshlanadi. Bu, ayniqsa, sekin ishlaydigan qurilmalar va tarmoqlarda dastlabki sahifa yuklanishini sekinlashtirishi va potensial ravishda foydalanuvchilarning noroziligiga olib kelishi mumkin. Bundan tashqari, faqat klient tomonda ishlaydigan ilovalarda React DOM’ga ega bo'lmaguncha foydalanuvchi interfeysi bo'lmaydi. Shuning uchun, foydalanuvchilar avval React va React DOM’ning yuklanishini kutishga majbur bo'lishadi. Server Tomonida Render Qilishning Afzalligi Bundan farqli ravishda, serverda render qilingan ilova dastlabki JavaScript yuklanishidan oldin foydalanuvchiga tayyorlangan HTML kodni yuboradi, bu esa foydalanuvchilarga birinchi navbatda foydali kontentni darhol ko'rish imkonini beradi. Keyin esa kerakli JavaScript dastlabki sahifa yuklanishidan keyin yuklanadi, va bu jarayon \"hidratsiya\" deb nomlanadi. Bunga keyingi bo'limlarda to'xtalamiz. Dastlab tayyorlangan HTML’ni uzluksiz uzatuvchan(streaming) shaklida yuborish va keyin JavaScript yordamida DOM’ni hidratsiya qilish foydalanuvchilarga ilova bilan tezroq muloqot qilish imkonini beradi, natijada yaxshiroq foydalanuvchi bilan ishlash qulayligi yuzaga keladi: ilova darhol foydalanuvchiga tayyor bo'ladi, ular esa har qanday qo'shimcha narsalarni yuklab olishni kutishlariga hojat qolmaydi — ular kerak yoki kerak emasligidan qat'i nazar. Xavfsizlik (Security) Faqat klient tomonda render qilish, ayniqsa, nozik ma'lumotlar bilan ishlaganda xavfsizlik muammolariga olib kelishi mumkin. Buning sababi shundaki, ilovaning barcha kodi klientning brauzeriga yuklanadi va bu esa uni xakerlik hujumlariga, masalan, cross-site request forgery(CSRF)’ga nisbatan zaif holatga keltirib qo'yadi. CSRF muammosi va uni oldini olish CSRF haqida juda chuqur kirishmasdan, unga qarshi kurashishning keng tarqalgan usuli - foydalanuvchilarga veb-sayt yoki veb-ilovalarni taqdim etadigan server ustidan nazoratga ega bo'lishdir. Agar biz ushbu serverni nazorat qilsak, biz serverdan ishonchli manba sifatida klientga mos anti-CSRF tokenlarini yuborishimiz mumkin, so'ngra klient bu tokenlarni forma yoki shunga o'xshash usulda serverga qaytaradi, bu esa so'rovning to'g'ri klientdan kelayotganini tasdiqlash imkonini beradi. Bu CSRF’ga qarshi kurashishning keng tarqalgan usullaridan biridir. Agar biz nazorat qiladigan statik sayt serveridan faqat klient tomonda ishlaydigan ilovalarga xizmat ko'rsatish texnik jihatdan mumkin bo'lsa-da va shu yo'l bilan CSRF’ga qarshi choralar ko'rsak, bu hali ham veb-saytni taqdim etishning eng yaxshi usuli emas, chunki biz ilgari muhokama qilgan boshqa ijobiy va salbiy jihatlari (trade-offs) mavjud. Agar biz serverni nazorat qilsak, unda nega server tomonida render qilish(SSR)ni qo'shmasligimiz kerak? Ba'zi xulosalar Oxir-oqibat, biz shuni aytmoqchimiz: - Agar biz server tomonga kirish imkoniga ega bo'lmasak, lekin jamoada faqat klient tomoni kodini qo'llab-quvvatlaydigan joyda ishlasak va kodimiz qayergadur joylanadigan bo'lsa, bu yerda o'ziga xos CSRF xavflari mavjud. - Agar biz server tomonga kirish imkoniga ega bo'lsak va agar bizning veb-saytimiz yoki veb-ilovamiz hali ham faqat klient tomonda bo'lsa, CSRF’ga qarshi juda yaxshi choralar ko'rishimiz mumkin va buni atrofidagi xavflar yo'qoladi. - Agar biz server tomonga kirish imkoniga ega bo'lsak va agar bizning veb-saytimiz yoki veb-ilovamiz hali ham faqat klient tomonda bo'lsa, bu uchun server tomonida render qilishni qo'shish uchun kuchli dalil mavjud, chunki biz serverga kirish imkoniga egamiz, bu esa SEO va ishlash bo'yicha boshqa foydalarini taqdim etadi. Akkountdan pul yechish misoli Keling, amaliy misolni ko'rib chiqaylik: Ushbu kodda funksiyasi pulni yechish uchun faraziy server tomonidagi manzilga so'rov yuboradi. Agar ushbu manzil so'rovning kelish manzilini to'g'ri tekshirmasa va hech qanday anti-CSRF tokenini talab qilmasa, CSRF xavfi paydo bo'lishi mumkin. Kelib chiqishi mumkin bo'lgan CSRF xavflari Hujumkor yomon niyatli veb-sahifa yaratishi mumkin, bu sahifa foydalanuvchini tugmachani bosishga undaydi, bu tugma foydalanuvchining nomidan havolasiga so'rov yuboradi, bu esa foydalanuvchining hisobidan ruxsatsiz pul yechishlarga olib kelishi mumkin. Buning sababi shundaki, brauzer avtomatik ravishda so'rovda cookie-fayllarni qo'shadi, ularni server foydalanuvchini autentifikatsiya qilish uchun ishlatadi. Agar server so'rovning kelish manzilini validatsiya qilmasa, u so'rovni qayta ishlashga va mablag'larni hujumkorning hisobiga o'tkazishga aldanishi mumkin. Agar ushbu komponent klient tomonda render qilinsa, bu CSRF hujumlariga nisbatan zaif bo'lishi mumkin, chunki server va klient o'rtasida umumiy yoki maxfiy shart yo'q. Boshqacha aytganda, klient va server bir-birini tanimaydi. Bu esa hujumkorga mablag'larni o'g'irlash yoki ilovaning ma'lumotlarini manipulyatsiya qilish imkonini beradi. Agar biz serverda render qilishdan foydalansak, ushbu xavfsizlik muammolarini hal qilishimiz mumkin bo'lardi. Buning uchun server tomonidan maxsus maxfiy token yaratilgan holda komponentni serverda render qilamiz, so'ngra maxfiy tokenni o'z ichiga olgan HTML’ni klientga yuboramiz. Klient esa ushbu tokenni yana ushbu serverga qaytaradi, bu esa xavfsiz ikki tomonlama shartnoma o'rnatadi. Bu serverga so'rovning oldindan avtorizatsiya qilingan to'g'ri klientdan kelayotganini tasdiqlashga imkon beradi va noma'lum, ehtimoliy yomon niyatli hujumkorni hujumini oldini oladi.",
    "url": "/books/fluent-react/server-side-react/limitations-of-client-side-rendering/page",
    "category": "books",
    "tags": [
      "fluent-react",
      "tutorial",
      "guide",
      "react",
      "javascript",
      "frontend",
      "mumkin",
      "render",
      "klient",
      "server",
      "uchun",
      "biz",
      "tomonida",
      "yoki",
      "bilan",
      "javascript",
      "agar",
      "veb",
      "esa",
      "ushbu",
      "react"
    ]
  },
  {
    "id": "book-fluent-react-server-side-react-page",
    "title": "Server Tomonda React: SSR, Hidratsiya va API'lar",
    "content": "Server tomonda React (Server-side React) React yaratilganidan beri sezilarli darajada rivojlandi. Garchi u dastlab klient tomonidagi(client-side) kutubxona sifatida boshlangan bo'lsa-da, vaqt o'tishi bilan server tomonida render qilish (SSR) talabi oshdi. Ushbu bobda biz buni qanday tushunish mumkinligini va Reactning faqat klient (client-only React) tomonidagi versiyasidan farqlarini ko'rib chiqamiz hamda React ilovalarimizni qanday yaxshilash mumkinligini o'rganamiz. Oldingi boblarda muhokama qilganimizdek, React dastlab Meta tomonidan samarali va kengayuvchan foydalanuvchi interfeyslarini yaratish zarurati tufayli ishlab chiqilgan. 3-bobda bu qanday qilib virtual DOM orqali amalga oshirilishini ko'rib chiqdik, bu esa dasturchilarga UI komponentlarini osonlik bilan yaratish va boshqarish imkonini berdi. React’ning klient tomonidagi yondashuvi butun veb orqali tezkor va javob beradigan foydalanuvchi tajribalarini taqdim etdi. Biroq, veb rivojlanishda davom etar ekan, klient tomonida render qilishning cheklovlari yanada yaqqolroq ko'rina boshladi.",
    "url": "/books/fluent-react/server-side-react/page",
    "category": "books",
    "tags": [
      "fluent-react",
      "tutorial",
      "guide",
      "react",
      "javascript",
      "frontend",
      "react",
      "server",
      "klient",
      "tomonidagi",
      "qanday",
      "tomonda",
      "side",
      "dastlab",
      "client",
      "bilan",
      "tomonida",
      "render",
      "ssr",
      "bobda",
      "mumkinligini"
    ]
  },
  {
    "id": "book-fluent-react-server-side-react-recap-page",
    "title": "Server Tomonda React Xulosasi: SSR, Hidratsiya va API'lar",
    "content": "Bo'limni qisqacha takrorlash Xulosa qilib aytganda, server tomondan render qilish va hidratsiya veb-ilovalarining ishlashi, foydalanuvchi bilan ishlash qulayligi va SEO ko'rsatkichlarini sezilarli darajada yaxshilaydigan kuchli texnikalar hisoblanadi. React server tomondan render qilish uchun va kabi keng API to'plamini taqdim etadi, ularning har biri o'zining kuchli tomonlari va kamchiliklariga ega. Ushbu API’larni tushunish va ilova hajmi, server muhiti va dasturchi bilan ishlash qulayligi kabi omillarga asoslanib to'g'ri API’ni tanlash orqali siz React ilovangizni server va klient tomoni uchun optimizatsiya qilishingiz mumkin. Ushbu bob davomida ko'rib chiqqanimizdek, kichik ilovalar uchun mos bo'lgan oddiy va tushunarli server tomonda render qilish API’sidir. Biroq, uning sinxronlik xususiyati va event loop’ni bloklash potensiali sababli u katta ilovalar uchun eng samarali variant bo'lmasligi mumkin. Boshqa tomondan, ancha rivojlangan va moslashuvchan API bo'lib, render qilish jarayonini yaxshiroq boshqarish imkonini beradi va boshqa Node.js oqimlari bilan yaxshiroq integratsiyalashadi, bu esa uni katta ilovalar uchun ko'proq mos keladigan tanlovga aylantiradi. Takrorlash uchun savollar Endi siz React’da server tomonda render qilish va hidratsiya haqida puxta tushunchaga ega bo'ldingiz, bilimlaringizni ba'zi savollar bilan sinab ko'rish vaqti keldi. Agar siz ushbu savollarga ishonch bilan javob bera olsangiz, bu React mexanizmini yaxshi tushunishingizdan dalolat beradi va mavzularni davom ettirishda o'zingizni qulay his qilishingiz mumkin. Agar javob bera olmasangiz, biroz ko'proq o'qib chiqishni tavsiya qilamiz, lekin bu sizning tajribangizga salbiy ta’sir qilmaydi. 1. _React ilovasida server tomondan render qilishning asosiy afzalligi nimada?_ 2. _React’da hidratsiya qanday ishlaydi va nima uchun muhim?_ 3. _Davom ettiruvchanlik qobiliyati(Resumability) nima? Nima uchun u hidratsiyadan ustun ekanligi ta'kidlanadi?_ 4. _Faqat klient tomonida render qilishning asosiy afzalliklari va kamchiliklari nimalardan iborat?_ 5. _React’da va API’larining asosiy farqlari nimada?_ Keyingi bo'lim Server tomonda render qilish va hidratsiyani puxta o'zlashtirganingizdan so'ng, React dasturlash olamida yanada takomillashgan mavzularni o'rganishga tayyormiz. Keyingi bobda biz concurrent React (bir vaqtning o'zida bajariladigan React) mavzusiga sho'ng'iymiz. Veb-ilovalar tobora murakkablashib borar ekan, asinxron harakatlarni boshqarish muhim ahamiyat kasb etadi. Concurrent React’dan qanday foydalanishni o'rganib, siz murakkab ma'lumotlar bilan oson ishlay oladigan yuqori samaradorlikka ega, ko'lamdor va foydalanuvchi uchun qulay ilovalar yaratishingiz mumkin. Shunday ekan, tayyor turing va React ko'nikmalaringizni oshirishga hozirlaning!",
    "url": "/books/fluent-react/server-side-react/recap/page",
    "category": "books",
    "tags": [
      "fluent-react",
      "tutorial",
      "guide",
      "react",
      "javascript",
      "frontend",
      "react",
      "server",
      "uchun",
      "render",
      "api",
      "qilish",
      "bilan",
      "ilovalar",
      "tomondan",
      "hidratsiya",
      "siz",
      "mumkin",
      "tomonda",
      "ega",
      "ushbu"
    ]
  },
  {
    "id": "book-fluent-react-server-side-react-renderToPipeableStream-page",
    "title": "React'da `renderToPipeableStream` API'si: Streaming SSR Tahlili",
    "content": "API’si — bu React 18’da joriy qilingan server tomonidagi rendering API’si bo'lib, katta hajmdagi React ilovalarini samaraliroq va moslashuvchanroq tarzda Node.js oqimiga o'tkazish imkonini beradi. Bu \"stream\" qaytaradi va uni javob (response) obyektiga uzatish mumkin. HTML qanday render qilinishini yaxshiroq boshqarish va boshqa Node.js oqimlari bilan yaxshiroq integratsiyani ta'minlash imkonini beradi. Bundan tashqari, u React’ning \"concurrent\" xususiyatlarini, jumladan, Suspense’ni to'liq qo'llab-quvvatlaydi, bu esa server tomonidagi renderlash davomida asinxron ma'lumotlarni olishni yaxshiroq boshqarish imkonini ochib beradi. Stream bo'lganligi sababli, u tarmoq orqali uzluksiz uzatish holatida bo'lishi mumkin, ya'ni HTML qismlari bloklanmagan holda asinxron va yig'ilib boruvchi tarzda tarmoq orqali klientlarga yuboriladi. Bu tezkorroq TTFB (birinchi baytga erishish vaqti) va umuman yaxshiroq ishlash samaradorligi ko'rsatkichlarini ta'minlaydi. Oldingi server kodimizni yordamida qayta yozish uchun quyidagicha o'zgartirish qilamiz: Keling, ni chuqurroq o'rganamiz, uning xususiyatlari, afzalliklari va qo'llanilish holatlari haqida muhokama qilamiz. Shuningdek, ushbu API’ni React ilovalaringizda qanday amalga oshirishni yaxshiroq tushunishingizga yordam berish uchun bir qancha kod namunalari va misollarni taqdim etamiz. Bu qanday ishlaydi ham funksiyasiga o'xshab, deklarativ tarzda tasvirlangan React elementlari daraxtini oladi va uni HTML satriga aylantirish o'rniga, Node.js oqimi(stream)ga aylantiradi. Node.js stream — bu Node.js ishchi muhiti(runtime environment) asosidagi fundamental tushuncha bo'lib, samarali tarzda ma'lumotlarni qayta ishlash va boshqarishni ta'minlaydi. Oqimlar ma'lumotlarni bir maromda, bo'laklarga bo'lib ishlash imkoniyatini beradi, bu esa barcha ma'lumotlar to'plamini bir vaqtning o'zida xotiraga yuklamasdan amalga oshiriladi. Bu yondashuv katta satrlar yoki xotiraga sig'maydigan yoki tarmoq orqali uzatilishi mumkin bo'lmagan ma'lumotlar oqimlari bilan ishlashda ayniqsa foydali bo'ladi. Node.js oqimlari (Node.js streams) Asosan, Node.js oqimi manba va manzil o'rtasida uzluksiz uzatilayotgan ma'lumotlar oqimini ifodalaydi. Bu ma'lumotlar oqadigan truboprovod kabi tasavvur qilinishi mumkin, yo'lda turli xil operatsiyalar qo'llaniladi va ma'lumotlar qayta ishlanadi. Node.js oqimlari tabiati va ma'lumotlar oqimi yo'nalishiga qarab to'rtta turga bo'linadi: 1. O'qiladigan oqimlar (Readable streams): O'qiladigan oqimlar ma'lumotlar manbasini ifodalaydi, undan ma'lumot o'qishingiz mumkin. U , va kabi event’larni tarqatadi. O'qiladigan oqimlarga fayldan ma'lumot o'qish, HTTP so'rovini qabul qilish yoki maxsus generator yordamida ma'lumot yaratish misollar kiradi. React’ning funksiyasi HTML oqimini o'qishingiz va uni Express’dagi javob obyektiga o'xshash yoziladigan oqimga chiqarishingiz mumkin bo'lgan o'qiladigan oqimni qaytaradi. 2. Yoziladigan oqimlar (Writable streams): Yoziladigan oqimlar ma'lumotlar yozilishi mumkin bo'lgan manzilni ifodalaydi. U va kabi metodlar orqali oqimga ma'lumot yuborish imkonini beradi. Agar manzil ko'proq ma'lumotlarni qabul qila oladigan bo'lsa, yoziladigan oqimlar event’ini, yozish paytida xatolik yuz berganida esa event’ini tarqatadi. Yoziladigan oqimlarning misoli sifatida Express’dagi javob obyektini keltirish mumkin. 3. Ikki tomonlama oqimlar (Duplex streams): Dupleks(ikki tomonlama) oqimlar ham o'qiladigan, ham yoziladigan oqimni bir vaqtning o'zida ifodalaydi. Bu ikki tomonlama ma'lumotlar oqimini ta'minlaydi, ya'ni oqimdan o'qish va unga yozish imkonini beradi. Dupleks oqimlar odatda tarmoq soketlari yoki ma'lumotlar ikki yo'nalishda oqishi kerak bo'lgan aloqa kanallari uchun qo'llaniladi. 4. Transform oqimlar (Transform streams): Transform oqimlar — bu ma'lumotlar oqimi orqali o'tayotganda ularni qayta ishlaydigan dupleks oqimning maxsus turi. U kiruvchi ma'lumotlarni o'qiydi, ularni qayta ishlaydi va qayta ishlangan ma'lumotlarni chiquvchi natija sifatida taqdim etadi. Transform oqimlar siqish, shifrlash, siqilgan ma'lumotlarni yechish yoki ma'lumotlarni tahlil qilish kabi vazifalarni bajarish uchun ishlatilishi mumkin. Node.js oqimlarining kuchli xususiyatlaridan biri oqimlar orasida ma'lumotni ulash (piping qilish) imkoniyatidir. Piping usuli o'qiladigan oqimning chiqishini yoziladigan oqimning kirishiga ulashga imkon beradi va bu ma'lumotlar oqimini uzluksiz amalga oshirishni ta'minlaydi. Bu usul ma'lumotlarni boshqarish jarayonini ancha soddalashtiradi va xotira sarfini kamaytiradi. Haqiqatan ham, React’da server tomonida oqim orqali ishlov berish shunday amalga oshiriladi. Node.js oqimlari ortiqcha bosim(backpressure)ni boshqarishni ham qo'llab-quvvatlaydi. Ortiqcha bosim — bu ma'lumotlarni qayta ishlash vaqtida yuz beradigan muammo bo'lib, u ma'lumotlar bufer ortida yig'ilib qolishini ifodalaydi. Yoziladigan oqim yetarlicha tez ma'lumotlarni qayta ishlay olmaganda, o'qiladigan oqim event’larini tarqatishni to'xtatadi va bu ma'lumotlar yo'qotilishining oldini oladi. Yoziladigan oqim ko'proq ma'lumotlarni qabul qilishga tayyor bo'lganida, event’ini chiqaradi va o'qiladigan oqim event’larini tarqatishni davom ettiradi. Ko'p chuqurlashmasdan va mavzudan chetlashmagan holda aytganda, Node.js oqimlari katta hajmdagi ma'lumotlar to'plamlarini, faylga kirish/chiqish operatsiyalarini, tarmoq aloqalarini samarali tarzda boshqarish va xotira tejamkor usulda amalga oshirish uchun kuchli abstraksiya hisoblanadi. qanday ishlaydi React’da komponentlarni yoziladigan oqimga aylantirishning maqsadi server tomonidan qayta ishlangan ilovalarning birinchi baytning kelishi vaqti (TTFB) samaradorligini oshirishdir. HTML markup’ini to'liq yaratilib, klientga yuborilishini kutish o'rniga, ushbu usullar serverga tayyor bo'lgan har bir bo'lak HTML javobini ketma-ket yuborishni boshlashga imkon beradi va shu bilan umumiy kechikishni kamaytiradi. funksiyasi React’ning server renderer’ining bir qismi bo'lib, u React ilovasini Node.js oqimiga oqib chiqish orqali streaming usulida uzluksiz uzatishlikni ta'minlash maqsadida render qilishni qo'llab-quvvatlash uchun mo'ljallangan. Bu “Fizz” deb ataladigan server renderer arxitekturasining bir qismidir. <Callout type=\"info\"Ushbu bo'limda biz React’ning texnik tafsilotlariga chuqur kirib boramiz va ular vaqt o'tishi bilan o'zgarishi mumkin. Yana bir bor ta'kidlaymizki, bu ta’limiy maqsadlar uchun va o'quvchining qiziqishini qondirish uchundir. O'qiyotgan paytingizda bu React dasturini amalga oshirish tafsilotlariga to'liq mos kelmasligi mumkin, ammo yozish paytida bu qanday ishlashi haqida yaxshi tasavvurga ega bo'lish uchun yetarlicha yaqin. Bu, ehtimol siz foydalanish muhitida ishlatadigan narsa emasdir va React’dan qanday foydalanishni bilish uchun muhim emas, balki bu faqat ta'lim va qiziqish uchundir. </CalloutServer render qilish jarayonini umumiy kontekstdan chetga chiqmasdan, qisqacha va sodda qilib tushuntirib o'tamiz: So'rov(request) yaratish funksiyasi kiritish sifatida render qilinishi kerak bo'lgan React elementlarini va ixtiyoriy parametrlar obyektini oladi. Keyin u funksiyasi yordamida so'rov obyektini yaratadi. Bu so'rov obyekti React elementlari, resurslar, javob holati va format kontekstini qamrab oladi. Ishni boshlash So'rov yaratib bo'lgandan so'ng, funksiyasi argument sifatida so'rovni qabul qilib, chaqiriladi. Bu funksiya render qilish jarayonini boshlaydi. Render qilish jarayoni asinxron bo'lib, kerak bo'lganda to'xtatilishi va davom ettirilishi mumkin, bu yerda React’ning Suspense xususiyati qo'llaniladi. Agar komponent Suspense hududi bilan o'ralgan bo'lsa va u qandaydir asinxron operatsiyani (masalan, ma'lumotlarni olib kelish) boshlasa, ushbu komponent (va ehtimol uning sheriklari) mazkur operatsiya tugaguncha \"to'xtatilishi\" mumkin. Komponent to'xtatilgan paytda u odatda yuklanish indikatori yoki boshqa o'rinbosar kabi \"fallback\", ya'ni zaxira, holatda ko'rsatilishi mumkin. Operatsiya tugaganidan so'ng, komponent qayta tiklanadi va yakuniy holatda render qilinadi. Suspense - bu React’ga server tomonida renderlash paytida asinxron ma'lumotlarni olish va \"lazy loading\" texnikasi orqali samaraliroq boshqarish imkonini beruvchi kuchli xususiyatdir. Bu yondashuv orqali foydalanuvchiga darhol mazmunli sahifa ko'rsatish va keyinchalik ma'lumotlar mavjud bo'lganda uni bosqichma-bosqich boyitish imkoniyati yaratiladi. Bu foydalanuvchi bilan ishlash qulayligini yaxshilash uchun qo'llanilishi mumkin bo'lgan samarali texnikadir. O'tkaziluvchan(pipeable) oqimni qaytarish funksiya va metodlarini o'z ichiga olgan obyektni qaytaradi. metodi render qilingan natijani yoziladigan oqimga (masalan, Node.js’dagi HTTP javob obyekti) o'tkazish uchun ishlatiladi. metodi esa qolgan barcha I/O operatsiyalarni bekor qilish va barcha qolgan ma'lumotlarni klient tomonidan render qilinadigan rejimga o'tkazish uchun ishlatilishi mumkin. Belgilangan joy(destination)ga o'tkazish metodi belgilangan joy oqimi bilan chaqirilganda, u ma'lumotlar oqimi allaqachon boshlanganini tekshiradi. Agar boshlanmagan bo'lsa, qiymatini ga o'rnatadi va funksiyasini so'rov va belgilangan joy bilan chaqiradi. Shuningdek, belgilangan joy oqimning , va event’lari uchun ishlov beruvchilarni o'rnatadi. Oqim hodisa(stream event)larini boshqarish event’i ishlov beruvchisi belgilangan joy oqimi ko'proq ma'lumotlarni qabul qilishga tayyor bo'lganda ma'lumot oqimini davom ettirish uchun funksiyasini qayta chaqiradi. va event’lari ishlov beruvchilari belgilangan joy oqimida xatolik yuz berganda yoki oqim muddatidan oldin yopilganda render qilish jarayonini to'xtatish uchun funksiyasini chaqiradi. Render qilishni bekor qilish Qaytarilgan obyektning metodi render qilish jarayonini to'xtatish uchun biror sabab bilan chaqirilishi mumkin. Bu modulidan so'rov va sabab bilan funksiyasini chaqiradi. va paketlari Ushbu funksiyalarni haqiqiy implementatsiyasida progressiv render qilish, xatolarni boshqarish va React server renderer’ining qolgan qismi bilan integratsiya kabi murakkabroq logika mavjud. Ushbu funksiyalar uchun kod va paketlarida joylashgan. xususiyatlari xususiyatlariga quyidagilar kiradi: - Uzluksiz uzatishlik (Streaming): o'tkaziluvchan Node.js oqimini qaytaradi, bu esa uni javob obyektiga o'tkazish imkonini beradi. Bu serverga butun sahifa render qilinmasdan turib HTML’ni klientga yuborishni boshlash imkonini beradi, bu esa katta ilovalar uchun tezroq foydalanuvchi bilan ishlash qulayligini va yaxshiroq ishlashini ta’minlaydi. - Moslashuvchanlik: HTML’ni qanday render qilishni yanada ko'proq nazorat qilish imkonini beradi. U boshqa Node.js oqimlari bilan oson integratsiyalashishi mumkin, bu esa dasturchilarga render qilish pipeline’ini moslashtirish va samaraliroq server tomonida render qilish yechimlarini yaratish imkonini beradi. - Suspense’ni qo'llab-quvvatlash: React’ning bir vaqtning o'zida bajariladigan(concurrent) xususiyatlarini, jumladan Suspense’ni to'liq qo'llab-quvvatlaydi. Bu dasturchilarga server tomonida render qilish vaqtida asinxron ma'lumotlarni olib kelish va kerakli vaqtda yuklashni yanada samaraliroq boshqarish imkonini beradi, shuningdek, ma'lumotga bog'liq komponentlar faqat zarur ma'lumot mavjud bo'lganda render qilinishini ta'minlaydi. Qanday moslashadi Keling, ushbu API’ning afzalliklarini ko'rsatadigan kodga nazar tashlaymiz. Bizda kuchuk zotlari ro'yxatini ko'rsatadigan ilova bor. Ro'yxat API manzilidan ma'lumotlarni olib kelish orqali to'ldiriladi. Ushbu ilova serverda yordamida render qilinadi va keyin klientga yuboriladi. Avval, kuchuk zotlari ro'yxatini ko'rsatuvchi komponentimizni ko'rib chiqamiz: Endi esa umumiy ni ko'rib chiqamiz, bu komponentini o'z ichiga oladi: Diqqat qiling, bu yerda biz dan foydalanmoqdamiz, oldingi boblarda aytilganidek, faqat Suspense’ni qanday boshqarishini ko'rsatish uchun boshqa Suspense hududini qo'shmoqdamiz. Yaxshi, bularning hammasini birlashtirib, Express serverini yaratamiz: Ushbu kod bo'lagi yordamida biz so'rovga HTML oqimini qaytarish orqali javob bermoqdamiz. Biz yordamida komponentimizni oqimga render qilyapmiz va keyin shu oqimni javob obyektimizga uzatmoqdamiz. parametri yordamida qobiq tayyor bo'lgandan keyin oqimni javob obyektiga uzatamiz. Qobiq(Shell) - bu React ilovasi hidratsiya qilinishidan va Suspense hududlarida o'ralgan ma'lumotlarga bo'lgan qaramliklar hal qilinishidan oldin render qilingan HTML qismi. Bizning holatimizda qobiq - bu kuchuk zotlari API’dan olinmasdan oldin render qilingan HTML. Keling, ushbu kodni ishga tushirganda nima sodir bo'lishini ko'rib chiqaylik. Agar biz http://localhost:3000 ga tashrif buyursak, \"Dog Breeds\" sarlavhasi va Suspense zaxira \"Loading Dog Breeds…\" bilan sahifa paydo bo'ladi. Bu - kuchuk zotlari API’dan olingunga qadar render qilingan qobiq (shell). Ajoyib tomoni shundaki, agar HTML kodimizga React’ni qo'shmasak ham va sahifani hidratsiya qilmasak ham, Suspense zaxirasi o'rniga haqiqiy kuchuk zotlari API’dan kelgach avtomatik ravishda joylashtiriladi. Ma'lumotlar mavjud bo'lganda DOM’ni almashtirish klient tomonidagi React ishtirokisiz to'liq server tomonidan amalga oshiriladi! Bu qanday ishlashini batafsil tushunamiz <Callout type=\"info\"Yana bir bor aytib o'tamiz, biz bu yerda React implementatsiyasi tafsilotlariga chuqur kiryapmiz, lekin bu tafsilotlar vaqt o'tishi bilan o'zgarishi mumkin. Bu mashqning (va bu kitobning) maqsadi alohida implementatsiya tafsilotlariga ko'p urg'u berish emas, balki React’ning asosiy mexanizmini tushunib olishdir. Bu mexanizmni tushunish orqali biz React’ni yaxshiroq tushunamiz va o'z kunlik ishimizda amaliy vositalarga ega bo'lamiz. </CalloutAgar http://localhost:3000 ga tashrif buyursak, server “Dog Breeds” sarlavhasi va Suspense zaxira “Loading Dog Breeds…” bilan HTML qobiqqa javob beradi. Ushbu HTML quyidagicha ko'rinadi: Bu yerda qiziqarli holatni ko'rishimiz mumkin. elementini yaratilgan ID bilan (bu holda ) va HTML izohlari mavjud. Ushbu HTML izohlari qobiqning boshlanish va tugash joylarini belgilaydi. Ular Suspense hal qilingandan keyin ma'lumotlar joylashtiriladigan belgilar yoki “bo'sh joylar” sifatida ishlaydi. HTML’dagi elementlari, DOM iyerarxiyasida qo'shimcha darajani yaratmasdan, dokument subdaraxtlarini yaratish va tugunlarni ushlab turish imkonini beradi. Ular tugunlar guruhlarini boshqarish uchun yengil konteyner bo'lib xizmat qiladi, DOM manipulyatsiyasi paytida bajarilgan ish hajmini kamaytirish orqali ish faoliyatini yaxshilaydi. Shuningdek, elementi mavjud. Ushbu tegida deb nomlangan funksiya mavjud bo'lib, u qobiqni haqiqiy kontent bilan almashtirish uchun ishlatiladi. funksiyasi ikkita argumentni qabul qiladi: markerni o'z ichiga olgan elementining ID’si va zaxirani o'z ichiga olgan elementining ID’si. Funksiya, ma'lumotlar mavjud bo'lgandan keyin, markerni render qilingan UI bilan to'ldiradi va zaxirani olib tashlaydi. Ushbu funksiyaning minimallashtirilganligi unchalik qulay emas, lekin uni qayta ochishga va nima qilayotganini tushunishga harakat qilaylik. Agar biz shunday qilsak, quyidagi kodni ko'ramiz: Ushbu funksiyani tahlil qilamiz Funksiya ikkita argumentni qabul qiladi: va . Aniqrog'i, marker bu - render qilingan komponentlar mavjud bo'lganda joylashtiriladigan bo'shliqdir, va sibling(qo'shni element) bu - Suspense fallback, ya'ni zaxira xabaridir. Funksiya metodidan foydalanib, ma'lumotlar mavjud bo'lganda DOM’dan qo'shni elementni (fallback’ni) olib tashlaydi. Agar elementi mavjud bo'lsa, funksiya ishga tushadi. Bu funksiya o'zgaruvchisini hozirgi elementining oldingi qo'shni elementiga o'rnatadi. Funksiya, shuningdek, , va o'zgaruvchilarini ham ishga tushiradi. sikli DOM daraxtini kesib o'tish uchun ishlatiladi, va bu elementdan boshlanadi. Sikl davom etadi, toki elementi mavjud bo'lsa. Sikl ichida funksiya elementining izoh tuguni ( qiymati 8 ko'rsatilgan) ekanligini tekshiradi: - Agar elementi izoh tuguni bo'lsa, funksiya uning ma'lumotlarini (ya'ni, izoh matnini) tekshiradi. Bu ma'lumot ga teng bo'lsa, bu ichma-ich strukturaning oxirini bildiradi. Agar qiymati bo'lsa, sikl tugaydi, ya'ni kerakli struktura oxiri topilgan bo'ladi. Agar qiymati bo'lmasa, bu izoh tuguni ichma-ich strukturaning bir qismi ekanligini anglatadi va qiymati kamayadi. - Agar izoh tugunidagi ma'lumot ga teng bo'lmasa, funksiya uning , , yoki ekanligini tekshiradi. Bu qiymatlar yangi ichma-ich strukturaning boshlanishini bildiradi. Agar ushbu qiymatlardan birontasi topilsa, qiymati oshadi. Har bir iteratsiyada elementi (ya'ni, Suspense hududi) metodidan foydalanib uning ota tugunidan olib tashlanadi. Sikl davom etadi va DOM daraxtidagi keyingi qo'shni elementi bilan davom etadi. Sikl tugallangandan so'ng, funksiya qo'shni elementining barcha bolalarini DOM daraxtida elementining oldiga ko'chiradi va bunda metodidan foydalanadi. Bu jarayon DOM’ni elementi atrofida qayta tuzadi va Suspense zaxirasini o'rab turgan komponent bilan almashtiradi. Shundan so'ng, funksiya elementining ma'lumotini ga o'rnatadi, bu ehtimol keyinchalik ishlov berish yoki murojaat qilish uchun komponentni belgilash uchun ishlatiladi. Agar elementida xususiyati mavjud bo'lsa va u funksiya bo'lsa, funksiya ushbu metodni chaqiradi. Agar ba'zi qismni tushunish qiyin bo'lgan bo'lsa, xavotir olmang. Bularni qisqacha umumlashtirsak: bu funksiya React komponentlari ma'lumotga bog'liq bo'lganda ularga tayyor bo'lishini kutadi va tayyor bo'lgach, Suspense fallback(zaxira)’larini serverda render qilingan komponentlarga almashtiradi. Bu izoh tugunlarini aniq ma'lumot qiymatlari bilan ishlatadi va shu orqali komponentlar strukturasini aniqlaydi hamda DOM’ni shu asnoda manipulyatsiya qiladi. Bu HTML’da server tomonidan qo'shilgani uchun, yordamida ma'lumotlarni shunday oqimda uzatishimiz va brauzer React’ni bog'lamasdan yoki hidratsiya qilmasdan UI’ni mavjud bo'lganda ko'rsatishi mumkin. Shunday qilib, bizga serverda render qilishda ga nisbatan ancha ko'proq nazorat qilish imkoniyatini va quvvatni beradi.",
    "url": "/books/fluent-react/server-side-react/renderToPipeableStream/page",
    "category": "books",
    "tags": [
      "fluent-react",
      "tutorial",
      "guide",
      "react",
      "javascript",
      "frontend",
      "react",
      "render",
      "uchun",
      "bilan",
      "mumkin",
      "lumotlar",
      "lumotlarni",
      "html",
      "suspense",
      "ushbu",
      "qilish",
      "funksiya",
      "node",
      "beradi",
      "server"
    ]
  },
  {
    "id": "book-fluent-react-server-side-react-renderToReadableStream-page",
    "title": "React'da `renderToReadableStream`: Brauzer Oqimlari Bilan SSR",
    "content": "API’si Avvalgi ko'rib chiqqan API, , ichki mexamizmida Node.js stream(oqim)’idan foydalanadi. Ammo brauzerlar ham oqimlarni qo'llab-quvvatlaydi va brauzer oqim(stream)lari Node.js oqimidan biroz farq qiladi. Node.js oqimlari asosan server tomonidagi muhitda ishlash uchun yaratilgan bo'lib, fayllarni kirish-chiqish (file I/O), tarmoq kirish-chiqish (network I/O), yoki bir-biriga bog'liq oqimlarni boshqarish kabi operatsiyalarni amalga oshiradi. Ular Node.js muhiti tomonidan belgilangan maxsus API’ga amal qiladi va Node.js’ning asosiy qismida uzoq vaqtdan beri mavjud. Node.js oqimlarida o'qiladigan, yoziladigan, dupleks va transform oqimlari uchun alohida class’lar mavjud va oqimni boshqarish va ma'lumotlarga ishlov berish uchun , , va kabi event’lardan foydalanadi. Brauzer oqimlari esa veb brauzerlarda klient tomonidagi muhitda ishlash uchun mo'ljallangan. Ular ko'pincha tarmoq so'rovlaridan, media oqimidan yoki brauzer ichidagi boshqa ma'lumotlarni qayta ishlash vazifalaridan foydalanadi. Brauzer oqimlari WHATWG (Veb Gipermatn Ilovalari Texnologiya Ishchi Guruhi) tomonidan belgilangan Oqimlar standartiga amal qilib, veb orqali API’larni standartlashtirishga qaratilgan. Node.js oqimidan farqli o'laroq, brauzer oqimlari ma'lumotlar oqimini boshqarish va oqimdagi ma'lumotlarni qayta ishlash uchun , , va kabi metodlardan foydalanadi. Ular yanada standartlashtirilgan va promise asosida ishlaydigan API’ni taqdim etadi. Quyida brauzer muhiti uchun o'qiladigan oqim misoli keltirilgan: Node.js oqimlari va brauzer oqimlari ikkovi ham oqimli, ya'ni uzluksiz uzatiladigan ma'lumotlarni, boshqarish uchun mo'ljallangan bo'lsa-da, ular turli muhitlarda biroz boshqacha API’lar va standartlar bilan ishlaydi. Node.js oqimlari event’larga asoslangan va server tomonidagi operatsiyalar uchun juda moslashgan, brauzer oqimlari esa zamonaviy veb standartlariga mos promise asosida ishlaydi va klient tomonidagi operatsiyalar uchun moslashtirilgan. Ikkala muhitni qo'llab-quvvatlash uchun, React Node.js oqimlari uchun va brauzer oqimlari uchun API’larini taqdim etadi. API’si ga o'xshash, ammo brauzer uchun o'qiladigan oqimni qaytaradi, Node.js’ning native oqimidan farqli o'laroq.",
    "url": "/books/fluent-react/server-side-react/renderToReadableStream/page",
    "category": "books",
    "tags": [
      "fluent-react",
      "tutorial",
      "guide",
      "react",
      "javascript",
      "frontend",
      "uchun",
      "oqimlari",
      "node",
      "brauzer",
      "api",
      "foydalanadi",
      "oqimidan",
      "tomonidagi",
      "ishlash",
      "boshqarish",
      "ular",
      "veb",
      "oqim",
      "kabi",
      "qiladigan"
    ]
  },
  {
    "id": "book-fluent-react-server-side-react-renderToString-page",
    "title": "React'da `renderToString` API'si: Sinxron SSR Tahlili",
    "content": "API’si — bu React tomonidan taqdim etilgan server tomonidagi render qilish API'sidir, bu bizga React komponentini serverda HTML satriga render qilish imkonini beradi. Ushbu API sinxron ishlaydi va to'liq render qilingan HTML satrini qaytaradi, bu esa keyinchalik klientga javob sifatida yuborilishi mumkin. odatda server tomonidan render qilingan React ilovalarida ishlatiladi va bu, o'z navbatida, ishlash samaradorligi, SEO va foydalanish imkoniyati qulayligini yaxshilashga yordam beradi. Foydalanish dan foydalanish uchun paketidan funksiyasini import qilishingiz kerak. Keyin, siz ushbu funksiyani React komponenti bilan argument sifatida chaqirishingiz mumkin. Bu esa sizga to'liq render qilingan HTML’ni satr sifatida qaytaradi. Quyida dan foydalanib, oddiy React komponentini render qilish misoli keltirilgan: Ushbu misolda biz oddiy komponentini yaratamiz va uni funksiyasinining argumenti sifatida chaqiramiz. Funksiya to'liq render qilingan HTM’Lni qaytaradi, bu esa klientga yuborilishi mumkin. Bu qanday ishlaydi funksiyasi React elementlari daraxtidan o'tadi, ularni real DOM elementlarining satr ko'rinishiga o'giradi va nihoyat, satrni chiqaradi. Eslatib o'tish joiz, React’da quyidagicha o'girilib yoziladi: Bu natijada chiqadigan qiymat: Buni avvalgi boblarda muhokama qilganmiz, lekin biz endi qilishimiz kerak bo'lgan muhokama uchun buni eslatib o'tishimiz foydadan holi emas. Asosan, JSX quyidagi oqim orqali HTML’ga o'giriladi: API’si sinxron va blok qiluvchi bo'lib, ya'ni uni to'xtatib yoki pauza qilib bo'lmaydi. Agar komponentlar daraxti ko'p darajalarda chuqur bo'lsa, u ko'p jarayonni talab qilishi mumkin. Odatda server bir nechta klientlarga xizmat ko'rsatadi, shuning uchun har bir klient uchun chaqirilishi mumkin, agar biron bir turdagi kesh mavjud bo'lmasa, bu tezda event loop’ni to'sib qo'yishi va tizimga ortiqcha yuklama(overload) qilishi mumkin. Kod nuqtai nazaridan, bu ko'rinishni o'zgartiradi: Natijada, quyidagi HTML’ga aylantiriladi: React deklarativ bo'lgani sababli va React elementlari deklarativ abstraksiyalar sifatida, ularning daraxti boshqa har qanday daraxtga — bu holatda HTML elementlarining satr ko'rinishidagi daraxtga aylantirilishi mumkin. Kamchiliklari bir qancha afzalliklarga ega bo'lishiga qaramay, ayrim kamchiliklari ham mavjud Ishlash samaradorligi(Performance): - ning asosiy kamchiliklaridan biri katta React ilovalari uchun sekin bo'lishi mumkinligidir. Ushbu funksiya sinxron ravishda ishlaydi, bu esa event loop’ni bloklab, serverning javobsiz bo'lib qolishiga olib kelishi mumkin. Bu muammo ayniqsa yuqori trafikga ega bo'lgan ilovalarda dolzarb bo'ladi, chunki ko'p foydalanuvchilar serverga bir vaqtning o'zida murojaat qilishi mumkin. - Shuningdek, butunlay render qilingan HTML satrini qaytaradi, bu katta ilovalar uchun xotira sarfini oshirib, javob berish vaqtini sekinlashtirishi mumkin. Katta yuklama ostida bu holat server jarayonining to'xtashiga olib kelishi mumkin. Uzluksiz uzatishlik(streaming) qo'llab-quvvatlanmaydi - Boshqa cheklovlardan biri \"streaming\" imkoniyatining yo'qligidir. barcha HTML satrini avval to'liq generatsiya qilishi kerak, shundan keyingina klientga jo'natish mumkin bo'ladi. - Bu esa birinchi baytga (TTFB) erishish vaqtini sekinlashtiradi, ya'ni klient HTML’ni olishni boshlash uchun uzoqroq kutishga majbur bo'ladi. - Ushbu cheklov ayniqsa katta hajmdagi kontentga ega bo'lgan ilovalarda seziladi, chunki barcha HTML yaratilgunicha hech qanday kontent ko'rsatilmaydi. ga alternativlar Katta ilovalar yoki ning kamchiliklari muammo bo'lib qoladigan vaziyatlarda, React server tomonida render qilish uchun alternativ API’larni taklif etadi, masalan va kabi. Ushbu API’lar _Node.js stream_ yoki brauzer streamni qaytaradi, bu esa yaxshiroq ishlash samaradorligini va uzluksiz uzatishlik imkoniyatini ta'minlaydi. Biz bular haqida keyingi mavzularda batafsil to'xtalamiz",
    "url": "/books/fluent-react/server-side-react/renderToString/page",
    "category": "books",
    "tags": [
      "fluent-react",
      "tutorial",
      "guide",
      "react",
      "javascript",
      "frontend",
      "react",
      "mumkin",
      "html",
      "render",
      "uchun",
      "api",
      "ushbu",
      "esa",
      "server",
      "qilingan",
      "qaytaradi",
      "sifatida",
      "bir",
      "katta",
      "qilish"
    ]
  },
  {
    "id": "book-fluent-react-server-side-react-rise-of-server-rendering-page",
    "title": "Server Tomonda Renderlashning (SSR) Yuksalishi va Afzalliklari",
    "content": "Serverda renderlashning yuksalishi Ushbu sabablarga ko'ra, server tomonda render qilish veb-ilovalarining samaradorligi va foydalanuvchi bilan ishlash qulayligini yaxshilash uchun nisbatan afzal usul sifatida paydo bo'ldi. Server render qilish bilan ilovalar tezlik va foydalanish imkoniyati qulayligi uchun optimallashtirilishi mumkin, bu esa tezroq yuklanish vaqtlariga, yaxshiroq SEO’ga va foydalanuvchi jalb etishining oshishiga olib keladi. Serverda renderlashning foydalari Serverda render qilishning foydalarini yanada chuqurroq ko'rib chiqaylik. Ushbu foydalar darhol aniq bo'lishi kerak, chunki biz klient tomonda render qilishning cheklovlarini yanada yaxshiroq tushunamiz: - Birinchi muhim chizish uchun vaqt tezroq: Server dastlabki HTML markup’ini render qilib, uni klientga yuborishi mumkin, bu esa darhol ko'rsatilishi mumkin. Bu klient tomonda render qilish bilan taqqoslaganda, klient ilova render qilinishidan oldin JavaScript yuklanishi, tahlil qilinishi va bajarilishi uchun kutishi kerak, . - Serverda render qilish veb-ilovalarining foydalanish imkoniyati qulayligini yaxshilaydi: Sekin internet aloqalari yoki kuchsiz qurilmalar bilan foydalanuvchilar to'liq render qilingan HTML olishsa, yaxshiroq tajribaga ega bo'lishlari mumkin, klient tomonida JavaScript’ni yuklash va sahifani render qilishni kutish o'rniga. - Serverda render qilish veb-ilovalarining SEO’sini yaxshilaydi: Qidiruv tizimlari botlari saytingizni indekslaganda, ular to'liq render qilingan HTML’ni ko'rishlari mumkin, bu esa ularning kontenti va strukturasini tushunishini osonlashtiradi. - Serverda render qilish veb-ilovalarining xavfsizligini ham yaxshilaydi: Asosiy kontentni server tomonda render qilish orqali, barcha foydalanuvchilar va qidiruv tizimlariga fundamental kontent va funksiyalarga kirish imkonini berasiz, JavaScript bajarilishidan qat'iy nazar. Shundan so'ng, klient tomoni JavaScript foydalanuvchi bilan ishlash qulayligini yaxshilab, interaktivlik, yanada boy bo'lgan animatsiyalar va boshqa takomillashgan funksiyalarni qo'shishi mumkin. Statik HTML’ning cheklovlari Biroq, server tomonidan render qilingan HTML statikdir va interaktivlikni yo'qotadi, chunki dastlab hech qanday JavaScript yuklanmaydi. U event listener’lar yoki boshqa dinamik funksiyalarni o'z ichiga olmaydi. Foydalanuvchi interaktivligi va boshqa dinamik funksiyalarni tatbiq qilish uchun, statik HTML \"hidratsiya\" qilinishi kerak. Keyingi mavzuda hidratsiya atamasini yaxshiroq tushunamiz.",
    "url": "/books/fluent-react/server-side-react/rise-of-server-rendering/page",
    "category": "books",
    "tags": [
      "fluent-react",
      "tutorial",
      "guide",
      "react",
      "javascript",
      "frontend",
      "render",
      "qilish",
      "serverda",
      "server",
      "mumkin",
      "html",
      "tomonda",
      "bilan",
      "uchun",
      "klient",
      "javascript",
      "veb",
      "ilovalarining",
      "foydalanuvchi",
      "yaxshiroq"
    ]
  },
  {
    "id": "book-fluent-react-server-side-react-server-rendering-apis-in-react-page",
    "title": "React'ning Server Tomonda Renderlash (SSR) API'lari Tahlili",
    "content": "React’da server renderlash API’lari Oldingi bo'limda, biz Express va yordamida faqatgina klient-tomonida render qilingan React ilovasiga server render qilishni o'zimiz \"qo'lda\" amalga oshirdik. Xususan, biz funksiyasidan foydalanib, React ilovamizni HTML satriga render qildik. Bu React ilovasiga server render qilishning eng oddiy usuli. Biroq, React ilovalariga server render qilishning boshqa usullari ham mavjud. Keling, React tomonidan taqdim etilgan server render qilish API’lariga chuqurroq nazar tashlaylik va ularni qachon va qanday ishlatishni tushunaylik. Keling, API’sini batafsil ko'rib chiqaylik, uning ishlatilishini, afzalliklarini, kamchiliklarini va uni React ilovasida qachon mos ravishda ishlatish kerakligini o'rganaylik. Xususan, biz quyidagi savollarga javob izlaymiz: - Bu nima? - Bu qanday ishlaydi? - Bu bizning kundalik ishlatadigan React ilovalarimizga qanday mos keladi? Buni boshlash uchun, avvalo, bu nima ekanligini muhokama qilaylik.",
    "url": "/books/fluent-react/server-side-react/server-rendering-apis-in-react/page",
    "category": "books",
    "tags": [
      "fluent-react",
      "tutorial",
      "guide",
      "react",
      "javascript",
      "frontend",
      "react",
      "server",
      "render",
      "api",
      "biz",
      "qanday",
      "renderlash",
      "lari",
      "ilovasiga",
      "xususan",
      "qilishning",
      "keling",
      "qachon",
      "mos",
      "nima"
    ]
  },
  {
    "id": "book-fluent-react-server-side-react-when-to-use-what-page",
    "title": "React'da SSR: Qaysi API'ni Qachon Ishlatish Kerak?",
    "content": "Qachon qaysi API’dan foydalanish kerak ideal yechim emas, chunki u sinxron ishlaydi. Bu bir qancha sabablarga ko'ra muammoli: Tarmoq kirish-chiqish (I/O) asinxron bo'ladi Biz bajaradigan har qanday ma'lumotni olish operatsiyalari ma'lumotlar bazasidan, veb xizmatidan, fayl tizimidan va hokazolardan ma'lumot olishga bog'liq. Bu operatsiyalar ko'pincha asinxron tarzda amalga oshiriladi: ya'ni ular aniq diskret vaqt nuqtalarida boshlanib, yakunlanadi, bir vaqtning o'zida emas. sinxron ishlagani sababli, u asinxron so'rovlarning tugashini kutolmaydi va darhol brauzerga satrni jo'natadi. Bu server yakunlay olmasligini va klient dastlabki qobiqni ma'lumot yuklanishidan oldin olishini anglatadi, va ideal holatda server hidratsiyani tugatgan joydan boshlab ishlashni davom ettiradi. Bu tarmoq sharsharalari orqali ishlash muammolarini keltirib chiqaradi. Serverlar bir nechta klientlarga xizmat ko'rsatadi Agar chaqiradigan server satrga aylantirish bilan band bo'lsa va 30 ta klient unga yangi so'rov yuborsa, bu yangi klientlar server joriy ishini tugatishini kutishlariga to'g'ri keladi. sinxron ishlagani sababli, u tugagunga qadar bloklanadi. Serverlar va klientlar o'rtasidagi birdan ko'pga munosabatda (one-to-many relationship) bloklanish, klientlar kerak bo'lgandan ko'ra uzoqroq kutishlarini anglatadi. Yangi, oqimga asoslangan asinxron yondashuvlar Yangi API’lar bo'lgan va ushbu ikkala muammoni hal qiladi. brauzer uchun mos keladi, esa server muhiti uchun. Shunday qilib, agar \"serverda ishlatish uchun eng yaxshi API qaysi?\" degan savol tug'iladigan bo'lsa, javob foydalanish muhitiga bo'gliq holda yoki bo'ladi. Shuni aytish kerakki, API’lari hozirda eng yaxshilari bo'lib ko'rinayotgan bo'lsa-da, hozirgi paytda ushbu API’lar atrofida \"to'liq foydalanuvchi ssenariysi\" mavjud emas. Hozir mavjud bo'lgan ko'plab uchinchi tomon kutubxonalari ular bilan ishlamaydi, ayniqsa ma'lumot olish yoki CSS kutubxonalari bilan bog'liq holda. Chunki ular kontseptual ravishda serverda \"to'liq ishga tushirish\"ni talab qiladi, so'ngra ma'lumotlarni yaratadi va keyin o'sha ma'lumot bilan dasturni qayta render qilib, oqimdan foydalana boshlaydi. Ular dastur serverda hali to'liq yuklanmagan, ammo brauzerda qisman hidratsiya qilinishi kerak bo'lgan holatlarni qo'llab-quvvatlamaydi. React’dagi API’larning cheklanishi Bu React’dagi muammo: hozirgi yozish paytida React 18 versiyasida uchinchi tomon ma'lumotlarini oqim yoki qisman hidratsiyaga yordam beruvchi API’lar mavjud emas. React jamoasi yaqinda ga , , kabi yangi API’lar qo'shdi, ammo ular faqat React 19 versiyasi bilan taqdim etiladi. Ushbu API’lar mavjud bo'lsa ham, ni ishlatish imkoniyatini oshirish uchun hali ham bir nechta muhim API’lar yetishmaydi. Hozirgi vaqtda dan foydalanishning yagona haqiqiy imkoniyati - bu birinchi navbatda ni chaqirishdan oldin barcha kerakli ma'lumotlarni oldindan yuklash (yoki CSS kutubxonasi holatida, bilan ko'rsatilishi kerak bo'lgan barcha class’larni \"oldindan yozib olish\" uchun to'liq dasturni taqdim etish) bo'ladi. Bu esa asosan uning ustidan ustunliklarini yo'q qiladi va uni yana sinxron API’ga aylantiradi. Barcha jihatlarni hisobga olgan holda, bular murakkab mavzular bo'lib, loyihangizga va foydalanish holatlariga qarab qaysi API’larni ishlatishni aniqlash uchun ehtiyotkorlik bilan rejalashtirishni talab qiladi. Shunday qilib, javob yana \"bu, vaziyatga bog'liq\" yoki \"shunchaki freymvorkdan foydalanish\" va kengroq jamoatchilikka qaror qilishni topshirish bo'lishi mumkin.",
    "url": "/books/fluent-react/server-side-react/when-to-use-what/page",
    "category": "books",
    "tags": [
      "fluent-react",
      "tutorial",
      "guide",
      "react",
      "javascript",
      "frontend",
      "api",
      "liq",
      "bilan",
      "lar",
      "uchun",
      "react",
      "kerak",
      "ular",
      "server",
      "yangi",
      "yoki",
      "qaysi",
      "foydalanish",
      "emas",
      "sinxron"
    ]
  },
  {
    "id": "book-fluent-react-virtual-dom-document-fragments-page",
    "title": "Document Fragments: Virtual DOM'ning Asosi",
    "content": "Dokument fragmentlari (Document fragments) Ko'rib o'tganimizdek, DOM’ni to'g'ridan-to'g'ri manipulatsiya qilish keragidan ortiqcha ko'p ishlash muammosiga olib kelish mumkin, ayniqsa bu bir nechta o'zgarishlarni jalb qilganda. Har safar DOM yangilanganda, brauzer qayta joylashuvni hisoblash, UI’ni qayta chizish va ko'rinishni yangilash kabi jarayonlarni bajarishi mumkin, bu esa ilovaning sekinlashishiga olib kelishi mumkin. Dokument fragmentlari bu yerda yordamga keladi. _Dokument fragmenti_ - bu DOM tugunlarini o'z ichiga oluvchi yengil konteynerdir. Bu asosiy DOM’ga ta'sir qilmasdan, bir nechta o'zgarishlar kiritish uchun vaqtinchalik joy sifatida xizmat qiladi. Ishni tugatgach, dokument fragmentini DOM’ga qo'shishingiz mumkin, natijada faqat bitta reflow (qayta joylashuvlarni hisoblash jarayoni) va qayta chizish sodir bo'ladi. Dokument fragmentlari shu tarzda React’ning virtual DOM’iga juda o'xshashdir. Dokument fragmentining afzalliklari Dokument fragmentlari o'zgarishlarni guruhlab yangilash imkonini beruvchi yengil konteyner bo'lib, ular samaradorlik tomonidan bir nechta afzalliklarni taqdim etadi: - Yangilashlarni guruhlash (Batched updates): Ayni vaqtda ishlab turgan DOMs’ga bir nechta individual yangilanishlar kiritish o'rniga, barcha o'zgarishlarni dokument fragmentida birlashtirish mumkin. Bu o'zgarishlar sonidan qat'iy nazar, faqat bitta reflow va qayta chizish amalga oshiriladi. - Xotira samaradorligi (Memory efficiency): Tugun(Node)lar dokument fragmentiga qo'shilganda, ular hozirgi ota-ona elementlaridan o'chirib yuboriladi. Bu, ayniqsa, dokumentning katta qismlarini qayta tartiblashda xotira sarfini optimallashtirishga yordam beradi. - Ortiqcha renderlashdan qochish (No redundant rendering): Dokument fragmenti ayni paytdagi aktiv dokument daraxtining bir qismi bo'lmaganligi sababli, undagi o'zgarishlar aktiv dokumentga ta'sir qilmaydi, va stillar va skriptlar dokument fragmenti real DOM’ga qo'shilmaguncha qo'llanilmaydi. Bu esa ortiqcha stillarni qayta hisoblashlar va skript bajarilishlaridan qochish imkonini beradi. Sodda ro'yxat misoli Keling, bir nechta ro'yxat elementlarini bir ro'yxatga qo'shish kerak bo'lgan holatni ko'rib chiqamiz: Bu misolda 100 ta ro'yxat elementi birinchi navbatda dokument fragmentiga qo'shiladi. Faqat barcha elementlar qo'shilgandan keyingina, fragment asosiy ro'yxatga qo'shiladi. Bu aktiv(live) DOM’ga 100 ta alohida yangilanish o'rniga bitta yangilanishni keltirib chiqaradi. Shu tariqa, dokument fragmentlari DOM bilan samarali ishlash uchun bir nechta o'zgarishlarni birlashtirishga imkon beradi va bu bilan ko'p vaqt talab qiladigan qayta joylashuvlar (reflow) va qayta chizishlar (repaint) sonini kamaytiradi. Veb-ilovalarning optimal samaradorligini ko'zlagan dasturchilar uchun dokument fragmentlarini ishlatish yanada silliqroq interaktivlik va tezroq render bo'lishni ta'minlaydi. Virtual DOM va fragmentlar React’ning virtual DOM’i dokument fragmenti konsepsiyasining takomillashgan talqiniga o'xshaydi. Mana, qisqacha bog'lanish: - Guruhlab yangilanishlar (Batched updates): Dokument fragmentlari kabi, React ham bir nechta o'zgarishlarni guruhlab, birlashtiradi. Har bir state yoki props o'zgarishida bevosita DOM’ni o'zgartirish o'rniga, React o'zgarishlarni avval virtual DOM’ga to'playdi. - Samarali farqlar (Efficient diffs): React so'ngra joriy virtual DOM va real DOM o'rtasidagi farqlarni (\"diffs\") aniqlaydi. Bu \"diffing\" jarayoni, dokument fragmentlari DOM manipulyatsiyalarini kamaytirgani kabi, faqat zarur o'zgarishlar amalga oshirilishini ta'minlaydi. - Yagona render (Single render): Farqlar aniqlangandan so'ng, React real DOM’ni yagona to'plamga yig'ib yangilash orqali o'zgartiradi, bu to'liq to'ldirilgan dokument fragmentini bittada qo'shish holatiga o'xshaydi. Bu qimmatli reflow’lar va qayta chizishlarni minimallashtiradi. Xulosa qilib aytganda, dokument fragmentlari DOM’ni yangilashdan oldin o'zgarishlarni guruhlash va optimallashtirishning bir usulini taqdim etsa, React’ning virtual DOM’i bu jarayonni yanada takomillashtirib, butun ilovaning UI qismi bo'ylab o'zgarishlarni to'plab bittada yangilaydi. Shunday qilib, renderlashda maksimal samaradorlikka erishiladi. Bundan tashqari, React ushbu jarayonni odatdagi dasturchilar uchun texnik tafsilot sifatida yashirib, bizni bu haqida qayg'urishdan ozod qiladi va ilovani yaratishda diqqatni ko'proq ilovamizning ishlab chiqishiga qaratishimizga imkon beradi. Endi virtual DOM qanday ishlashini batafsilroq ko'rib chiqamiz.",
    "url": "/books/fluent-react/virtual-dom/document-fragments/page",
    "category": "books",
    "tags": [
      "fluent-react",
      "tutorial",
      "guide",
      "react",
      "javascript",
      "frontend",
      "dom",
      "dokument",
      "bir",
      "qayta",
      "fragmentlari",
      "zgarishlarni",
      "react",
      "virtual",
      "nechta",
      "mumkin",
      "zgarishlar",
      "uchun",
      "faqat",
      "reflow",
      "ning"
    ]
  },
  {
    "id": "book-fluent-react-virtual-dom-efficient-updates-page",
    "title": "React Virtual DOM: Diffing Algoritmi va Samarali Yangilanishlar",
    "content": "Samarador yangilanishlar React komponentining state yoki props’lari o'zgarganda, React yangilangan foydalanuvchi interfeysini ifodalovchi yangi React elementlar daraxtini yaratadi. Bu yangi daraxt keyingi yangilanishlarni amalga oshirish uchun zarur bo'lgan minimal o'zgarishlarni aniqlash maqsadida oldingi daraxt bilan solishtiriladi. Bu jarayon \"diffing algorithm\"(farqlash algoritmi) yordamida amalga oshiriladi. Diffing(farqlash) algoritmi \"Diffing\" algoritmi yangi React elementlar daraxtini oldingi daraxt bilan taqqoslaydi va ular orasidagi farqlarni aniqlaydi. Bu rekursiv solishtirish hisoblanadi. Agar tugun o'zgargan bo'lsa, React real DOM’dagi mos tugunni yangilaydi. Agar tugun qo'shilgan yoki o'chirilgan bo'lsa, React real DOM’ga yangi tugunni qo'shadi yoki uni o'chiradi. \"Diffing\" jarayoni daraxtdagi qaysi qismlar o'zgarganligini aniqlash uchun yangi daraxtni eski daraxt bilan tugun bo'yicha solishtirishni o'z ichiga oladi. Diffing algoritmining ishlash jarayoni React’ning \"diffing\" algoritmi yuqori darajada optimizatsiya qilingan bo'lib, real DOM’da amalga oshirilishi kerak bo'lgan o'zgarishlar sonini minimal darajada bo'lishligini ta'minlaydi. Algoritm quyidagicha ishlaydi: - Agar ikkita daraxt(tree)ning ildiz(root) darajasidagi tugun(node)lari farq qilsa, React butun daraxtni yangisiga almashtiradi. - Agar ildiz darajasidagi tugunlar bir xil bo'lsa, React o'zgargan bo'lsa, tugunning atributlarini yangilaydi. - Agar tugunning farzandlari boshqacha bo'lsa, React faqat o'zgargan farzandlarni yangilaydi. React butun ichki daraxtlarni qayta yaratmaydi, faqat o'zgargan tugunlarni yangilaydi. - Agar tugunning farzandlari bir xil, lekin ularning tartibi o'zgargan bo'lsa, React real DOM’dagi tugunlarni qayta yaratmasdan tartibni o'zgartiradi. - Agar tugun daraxtdan olib tashlangan bo'lsa, React uni real DOM’dan olib tashlaydi. - Agar daraxtga yangi tugun qo'shilgan bo'lsa, React uni real DOM’ga qo'shadi. - Agar tugunning turi o'zgargan bo'lsa (masalan, dan ga), React eski tugunni olib tashlaydi va yangi turdagi tugunni yaratadi. - Agar tugunning props’i mavjud bo'lsa, React uni tugunni almashtirish kerakmi yoki yo'qligini bilish uchun ishlatadi. Bu komponentlarning state’ini qayta sozlash kerak bo'lganda foydali bo'lishi mumkin. React’ning \"diffing\" algoritmi juda samarali bo'lib, real DOM’ni tez va minimal o'zgarishlar bilan yangilash imkonini beradi. Bu React ilovalarini ishlash samaradorligini yaxshilaydi va murakkab, dinamik foydalanuvchi interfeyslarini yaratishni osonlashtiradi. Keraksiz qayta render qilishlar React’ning \"diffing\" algoritmi real DOM’ni samarali yangilashda o'zgarishlarni minimallashtirish orqali muhim rol o'ynaydi. Ammo dasturchilar duch kelishi mumkin bo'lgan umumiy muammo mavjud: keraksiz qayta render qilishlar (unnecessary rerenders). React’ning ishlash tabiati Bu React’ning ishlash usuli: agar komponentda state o'zgarsa, React komponentni va uning barcha avlodlarini qayta render qiladi. Qayta render qilish deganda, React har bir funksional komponentni rekursiv ravishda chaqirib, ularning har biriga props’larini argument sifatida o'tkazadi. React ota komponentning state yoki props’lari o'zgarganda uning farzandlarini ham chetlab o'tmaydi va barcha funksional komponentlarni qayta chaqiradi. Buning sababi shundaki, React qaysi komponentlar o'zgargan komponentning state’iga bog'liq ekanligini bilmaydi, shuning uchun foydalanuvchi interfeysi bir xil bo'lishini ta'minlash uchun ularning barchasini qayta render qilish kerak bo'ladi. Bu katta va murakkab foydalanuvchi interfeyslari bilan ishlaganda sezilarli performance muammolarini keltirib chiqarishi mumkin. Masalan, quyidagi kodda ning state’i o'zgarganida har safar qayta render qilinadi, hatto ga uzatilayotgan props o'zgarmagan bo'lsa ham: Ushbu misolda: - da nomli state o'zgaruvchisi mavjud bo'lib, har safar tugma bosilganda qiymati oshiriladi - esa deb nomlangan statik prop’ni qabul qiladi. Bu prop o'zgarmagani uchun, ideal holatda, ning state’i o'zgarganda qayta render qilinmasligi kerak edi. - Ammo, React’ning standart xatti-harakati tufayli, qayta render qilinganda, ham qayta render bo'ladi, ya'ni har safar state o'zgarganda. - Bu samarasiz, chunki dagi state’ga bog'liq emas - ning props va state’i o'zgarmaganligi sababli, qayta render qilish keraksiz edi: ehtimol, u avvalgi natijani qaytargan bo'lar edi, shuning uchun bu behuda harakat bo'ldi. Bu masala, ayniqsa, katta ilovalarda optimizatsiya qilishni talab qiladi, chunki ko'plab komponentlar keraksiz ravishda qayta render qilinishi mumkin, bu esa ishlash samaradorligi muammolariga olib kelishi mumkin. Ushbu masalani hal qilish komponentlar orasidagi qayta render qilishlarni boshqarish, komponentlar ierarxiyasidagi yuqori darajadagi state yoki props o'zgarishlari natijasida ortiqcha qayta renderlarni oldini olish orqali amalga oshiriladi. Komponentlarni to'g'ri strukturalash va React’ning optimizatsiyalash vositalari, masalan, va kabi xususiyatlardan oqilona foydalanish orqali dasturchilar qayta render qilishlarni yaxshiroq boshqarishlari va ilovalarning yuqori ishlash samaradorligini saqlab qolishlari mumkin. Bu mavzuni kelasi boblarda batafsilroq ko'rib chiqamiz.",
    "url": "/books/fluent-react/virtual-dom/efficient-updates/page",
    "category": "books",
    "tags": [
      "fluent-react",
      "tutorial",
      "guide",
      "react",
      "javascript",
      "frontend",
      "react",
      "qayta",
      "render",
      "state",
      "agar",
      "lsa",
      "ning",
      "diffing",
      "dom",
      "real",
      "props",
      "yangi",
      "uchun",
      "algoritmi",
      "zgargan"
    ]
  },
  {
    "id": "book-fluent-react-virtual-dom-how-virtual-dom-works-page",
    "title": "Virtual DOM va React Elementlari: React Qanday Ishlaydi?",
    "content": "Virtual DOM qanday ishlaydi Virtual DOM — bu real DOM’ning kamchiliklarini kamaytirishga yordam beradigan bir texnika. Xotirada DOM'ning virtual ko'rinishidagi talqinini yaratib, real DOM’ga bevosita o'zgartirishlar kiritmasdan, avval ushbu virtual talqinda o'zgartirishlar amalga oshiriladi. Bu dokument fragmentlariga o'xshash tarzda ishlaydi. Bu usul orqali freymvork yoki kutubxona real DOM’ni yanada samarali va tezkor usulda yangilash imkoniyatiga ega bo'ladi va brauzerning sahifaning joylashuvlarini qayta hisoblash yoki elementlarni qayta chizish bilan bog'liq jarayonlariga aralashmaslikka yordam beradi. Virtual DOM, shuningdek, elementlar va ularning yangilanishlarini yaratish jarayonini ham yaxshilaydi, turli brauzerlardagi real DOM’ning farqlarini abstraksiyalagan holda bir xil API taqdim etadi. Masalan, boshqa runtime’da funksiyasi boshqacha ishlashi mumkin, ammo JSX va virtual DOM yordamida bu farqlar ahamiyatga ega bo'lmaydi. Bu esa dasturchilarga turli brauzerlar va platformalarda bir xil ishlaydigan veb-ilovalarni yaratishni osonlashtiradi. React virtual DOM’dan foydalanuvchi interfeyslarini yaratish uchun foydalanadi. Ushbu bo'limda biz React’ning virtual DOM ishlash mexanizmini ko'rib chiqamiz. React elementlari (React Elements) React’da foydalanuvchi interfeyslari React elementlari daraxti sifatida ifodalanadi. Bu elementlar komponent yoki HTML elementning yengil talqinlari bo'lib, ular funksiyasi yordamida yaratiladi va murakkab foydalanuvchi interfeyslarini yaratish uchun bir-birining ichiga joylashtirilishi mumkin. Quyidagi misol React elementini yaratishni ko'rsatadi: Bu kod elementini yaratadi, uning atributi va tekst kontenti . Agar biz orqali ushbu elementni ko'rsak, u quyidagicha ko'rinadi: Bu React elementi talqinidir. React elementlari React ilovasining eng kichik qurilish bloklari hisoblanadi va ular ekranda nima paydo bo'lishi kerakligini tasvirlaydi. Har bir element JavaScript obyekti bo'lib, u o'ziga tegishli komponentni va kerakli props yoki atributlarni tasvirlaydi. Yuqorida keltirilgan kod blokida React elementi bir nechta xususiyatlarga ega obyekt sifatida ko'rsatilgan. Ular quyidagicha izohlanadi: xususiyati Bu React tomonidan obyektning haqiqiy React elementi ekanligini tekshirish uchun ishlatiladigan maxsus belgidir (symbol). Bu holda, u qiymatiga ega. elementning turiga qarab boshqa qiymatlarni ham qabul qilishi mumkin: - : Element React fragment’ni ifodalaganda. - : Element React portal’ni ifodalaganda. - : Element React profiler’ni ifodalaganda. - : Element React context provayderni ifodalaganda. Umuman olganda, React elementining turini aniqlovchi belgidir. Keyingi bo'limlarda bu turdagi belgilar haqida batafsilroq ma'lumot beriladi. xususiyati Ushbu xususiyat element ifodalagan komponentning turini ko'rsatadi. Masalan, bu holda qiymati bo'lib, bu DOM elementi, ya'ni \"host komponent\" ekanligini bildiradi. React elementining xususiyati string yoki funksiya (yoki class, lekin class’lardan foydalanish asta-sekin bekor qilinmoqda) bo'lishi mumkin. Agar u string bo'lsa, u HTML teg nomini ifodalaydi, masalan, , , va hokazo. Agar bu funksiya bo'lsa, u xos(custom) React komponentni ifodalaydi, bu asosan JSX qaytaradigan JavaScript funksiyasidir. Bu yerda xos komponent turi bilan yaratilgan elementga misoli: Bu holda, ning xususiyati bo'lib, bu xos komponentni belgilovchi funksiya hisoblanadi. ning React elementi sifatidagi obyekt ko'rinishi quyidagicha bo'ladi: Bu yerda qiymati funksiyasi bo'lib, bu element ifodalagan komponentning turi hisoblanadi, va tarkibida komponentga uzatilgan parametrlar mavjud . Agar React elementining xususiyati funksiya bo'lsa, u funksiyani elementning i bilan chaqiradi va qaytgan qiymat elementning i sifatida ishlatiladi. Masalan, yuqoridagi holatda qaytarilgan qiymat elementi bo'ladi. Shu tarzda React xos komponentlarni render qiladi: React elementlar bilan ishlashda oddiy qiymatlar(masalan, tekst tugunlarini)ga erishmagunicha imkon qadar chuqur kirib boradi, yoki bo'lgan holatda hech narsa render qilinmaydi. Bu yerda string turidagi element misoli: Bu holda, ning qiymati bo'lib, bu HTML teg nomini bildiruvchi string’dir. React ushbu string turdagi elementga duch kelganda, mos keluvchi HTML elementni yaratib, uning ichida bolalarini(children) render qiladi. xususiyati Ushbu xususiyat ota komponentga asosiy DOM tuguniga murojaat qilish uchun havolani talab qilish imkonini beradi. Odatda, bu to'g'ridan-to'g'ri DOM’ni manipulyatsiya qilish zarur bo'lgan holatlarda ishlatiladi. Bu holatda qiymati bo'ladi. xususiyati Ushbu xususiyat komponentga berilgan barcha atributlar va props’larni o'z ichiga olgan obyektdir. Bu holatda, u ikkita xususiyatga ega: va . elementning class nomini belgilaydi, va esa elementning kontentini o'z ichiga oladi. xususiyati Ushbu xususiyatga, faqat React’ning foydalanishga oid bo'lmagan (nonproduction) versiyalarida kirish mumkin bo'lib, React tomonidan ushbu elementni yaratgan komponentni kuzatish uchun ichki tomondan ishlatiladi. Ushbu ma'lumot, elementning props’lari yoki state’lari o'zgarganda qaysi komponent yangilanishi kerakligini aniqlash uchun ishlatiladi. Bu yerda xususiyatining ishlatilishi misoli: Ushbu misolda, komponenti \"Hello, world!\" teksti bilan elementini ifodalovchi React elementini yaratadi. Ushbu elementning xususiyati komponentini yaratgan komponentiga o'rnatiladi. React ushbu ma'lumotni, agar komponenti state’ni yangilasa yoki yangi props’larni olsa, qaysi komponent yangilanishi kerakligini aniqlash uchun ishlatadi. Bunday holda, React komponentini va unga tegishli elementni yangilaydi. Shuni ta'kidlash joizki, xususiyati React’ning ichki ishlash tafsilotiga oid narsadir va uni dasturiy kodda ishonchli manba sifatida foydalanish tavsiya etilmaydi. xususiyati React elementi obyektining xususiyati element haqida qo'shimcha ma'lumotlarni saqlash uchun o'zining ichki foydalanishi uchun ishlatiladi. dagi xususiyatlar va qiymatlar umumiy API’ning bir qismi emas va ular dasturiy kodda to'g'ridan-to'g'ri foydalanilmasligi kerak. Quyida xususiyatining qanday ko'rinishga ega bo'lishi mumkinligi haqida misol keltirilgan: Ko'rib turganingizdek, turli xususiyatlarni o'z ichiga oladi, masalan, , , , , , , , , va . Ushbu xususiyatlar React tomonidan elementning state’i va context’ini kuzatish uchun ishlatiladi. Masalan, development rejimida element qayerda yaratilganligini aniqlash uchun fayl nomi va qator raqamini kuzatish uchun ishlatiladi, bu esa debug qilishda yordam beradi. Avvalroq aytib o'tilganidek, elementni yaratgan komponentni kuzatish uchun ishlatiladi, va komponentga uzatilgan props’larni saqlash uchun mo'ljallangan. Yana bir bor, React’ning ichki ishlash tafsilotiga oid narsadir va dastur kodida to'g'ridan-to'g'ri foydalanilmasligi lozim. Shu sababli, ushbu mavzuni chuqurlashtirmaslikni ma'qul topamiz.",
    "url": "/books/fluent-react/virtual-dom/how-virtual-dom-works/page",
    "category": "books",
    "tags": [
      "fluent-react",
      "tutorial",
      "guide",
      "react",
      "javascript",
      "frontend",
      "react",
      "dom",
      "ushbu",
      "uchun",
      "xususiyati",
      "ning",
      "element",
      "virtual",
      "yoki",
      "elementning",
      "bir",
      "ishlatiladi",
      "masalan",
      "lib",
      "elementi"
    ]
  },
  {
    "id": "book-fluent-react-virtual-dom-intro-virtual-dom-page",
    "title": "React Virtual DOM: Kirish va Asosiy Konsepsiyalar",
    "content": "Virtual DOM’ga kirish Virtual DOM, xuddi DOM kabi, JavaScript obyekti sifatida modellashtirilgan HTML dokumentidir: bu \"Document Object Model\" (DOM) atamasining to'g'ridan-to'g'ri ma’nosi ham shudir. DOM’ning o'zi brauzerning kodni bajarilish vaqti(runtime)da ishlatiladigan dokument modelidir. Virtual DOM esa ushbu modelning yengil nusxasi(lightweight) bo'lib, muhim farqi shundaki, real DOM obyektlaridan tashkil topgan bo'lsa, virtual DOM oddiy JavaScript obyektlaridan tashkil topadi va ular DOM’ni tavsiflash uchun xizmat qiladi. Bu yondashuv veb dasturchilarga foydalanuvchi interfeyslarini yanada samarali va tezkor tarzda yaratishga yordam beradi, bu bobda buni batafsil ko'rib chiqamiz. React’da, biz interfeysda biror o'zgarish bo'lishligini kiritganimizda, masalan, yoki boshqa bir mexanizm orqali, avval virtual DOM yangilanadi, so'ngra real DOM virtual DOM’dagi o'zgarishlarga mos ravishda yangilanadi. Ushbu jarayon _reconciliation_ (moslashtirish) deb ataladi, bu haqida ham keyingi bobda batafsil o'rganamiz. Avval virtual DOM’ni yangilashning sababi shundaki, real DOM’ni yangilash biroz sekin va ko'p resurs talab qilishi mumkin. Keyingi qismda buni batafsil ko'rib chiqamiz, lekin qisqacha aytganda, real DOM’da har safar o'zgarish qilganimizda, brauzer sahifa joylashuvini qayta hisoblashga, ekranni qayta chizishga va boshqa vaqt talab qiluvchi jarayonlarni bajarishga majbur bo'ladi. Masalan, biror elementning qiymatini o'qish hatto qayta joylashish jarayoni(reflow)ni ishga tushirishi mumkin, bu brauzerning dokumentning butun yoki qisman joylashuvini qayta hisoblash jarayoni(recalculation)dir, bu esa ishlash samaradorligi(performance)ga salbiy ta'sir ko'rsatishi mumkin: Boshqa tomondan, virtual DOM’ni yangilash juda tez bo'ladi, chunki u haqiqiy sahifa tartibida hech qanday o'zgarish qilmaydi. Buning o'rniga, bu oddiy JavaScript obyekti bo'lib, uni turli algoritmik yondashuvlar orqali tez va samarali tarzda boshqarish mumkin, bu esa JavaScript dvigatelining ishlash samaradorligini oshirishga yordam beradi va uni brauzerlar va boshqa muhitlarda ishlashdan xalos etadi va buni mustaqil qiladi. Virtual DOM’ga o'zgartirishlar kiritilganda, React eski va yangi versiyalari o'rtasidagi farqlarni aniqlash uchun _diffing algoritmidan_ foydalanadi. Bu algoritm real DOM’ni yangilash uchun kerak bo'lgan minimal o'zgarishlar to'plamini aniqlaydi va bu o'zgarishlar optimallashtirilgan va yangilanishlarni guruhlash(batch updating)lar orqali amalga oshiriladi, shu tariqa performance oshiriladi. Ushbu bobda biz virtual DOM va real DOM o'rtasidagi farqlarni, real DOM’ning kamchiliklarini va virtual DOM’ning foydalanuvchi interfeyslarini yaxshiroq yaratishga qanday yordam berishini o'rganamiz. Shuningdek, React virtual DOM’ni ishlashini qanday amalga oshirgani va samarali yangilanishlar uchun qanday algoritmlar ishlatilishini ko'rib chiqamiz.",
    "url": "/books/fluent-react/virtual-dom/intro-virtual-dom/page",
    "category": "books",
    "tags": [
      "fluent-react",
      "tutorial",
      "guide",
      "react",
      "javascript",
      "frontend",
      "dom",
      "virtual",
      "real",
      "javascript",
      "uchun",
      "react",
      "boshqa",
      "mumkin",
      "qayta",
      "qanday",
      "ning",
      "esa",
      "ushbu",
      "samarali",
      "yordam"
    ]
  },
  {
    "id": "book-fluent-react-virtual-dom-page",
    "title": "React'da Virtual DOM: Kirish va Asosiy Konsepsiyalar",
    "content": "Virtual DOM o'zi nima? Ushbu bobda biz virtual DOM (vDOM deb ham ataladi) tushunchasini chuqur o'rganamiz va uning React’da qanday ahamiyatga ega ekanini ko'rib chiqamiz. Shuningdek, React virtual DOM’ni qanday qilib veb-ilovalarni yaratishni oson va samarali qilish uchun ishlatishini ham o'rganamiz. Veb-ilovalar tobora murakkablashgani sari, \"real DOM\"ni boshqarish ham shunga mos ravishda qiyinlashib boradi. Real DOM bilan ishlash jarayoni murakkab va xatolarga moyil bo'lib, biz bu haqida 1-bobda qisqacha to'xtalgandik. React’ning virtual DOM’i bu muammoga yechim beradi. Ushbu bob davomida biz React’ning virtual DOM’ini qanday ishlashi, real DOM’ga nisbatan afzalliklari va qanday amalga oshirilishi haqida tushunchaga ega bo'lamiz. Shuningdek, React qanday qilib real DOM ustida ishlashni optimallashtirishini va bularning hammasi qanday o'zaro bog'liq ekanini muhokama qilamiz. Kod misollari va batafsil tushuntirishlar orqali virtual DOM’ning React’dagi rolini o'rganamiz va uning afzalliklaridan foydalanib, mustahkam va samarali veb-ilovalarni qanday yaratishni bilib olamiz. Qani, unda boshladik!",
    "url": "/books/fluent-react/virtual-dom/page",
    "category": "books",
    "tags": [
      "fluent-react",
      "tutorial",
      "guide",
      "react",
      "javascript",
      "frontend",
      "dom",
      "virtual",
      "react",
      "qanday",
      "real",
      "biz",
      "ham",
      "rganamiz",
      "veb",
      "ning",
      "ushbu",
      "bobda",
      "uning",
      "ega",
      "ekanini"
    ]
  },
  {
    "id": "book-fluent-react-virtual-dom-pitfalls-of-real-dom-page",
    "title": "Real DOM'ning Kamchiliklari: Performance va Brauzerlararo Moslik",
    "content": "Real DOM’ning ayrim kamchiliklari Real DOM'ning bir qancha kamchiliklari bor, bu esa yuqori samarador veb-ilovani yaratishni qiyinlashtirishi mumkin. Bu kamchiliklardan ba'zilari ishlash samaradorligiga doir muammolari, brauzerlararo moslik va xavfsizlik zaifliklarini o'z ichiga oladi, bu yerda DOM’ni to'g'ridan-to'g'ri o'zgartirish, cross-site scripting (XSS) zaifliklarini keltirib chiqarishi mumkin. Performance (Ishlash samaradorligi) Real DOM bilan bog'liq eng katta muammolardan biri uning performance muammosidir. DOM’da o'zgarish yuz berganda, masalan, element qo'shish yoki olib tashlash, yoki elementning teksti yoki atributlarini o'zgartirishda, brauzer joylashuv(layout)larni qayta hisoblash va o'zgargan qismlarni qayta chizish kerak bo'ladi. Bu jarayon katta va murakkab veb-sahifalar uchun sekin va resurslarni ko'p iste'mol qiluvchan bo'lishi mumkin. ishlatishning kamchiliklari Oldin aytib o'tilganidek, DOM elementining xususiyatini o'qish oddiy operatsiya kabi ko'rinishi mumkin, lekin aslida brauzer tomonidan joylashuvni qimmatli bo'lgan qayta hisoblashga olib kelishi mumkin. Buning sababi, hisoblangan xususiyat(computed property) bo'lib, u element va uning avlodlarining joylashuviga bog'liq bo'ladi, bu esa brauzerga aniq qiymatni qaytarishdan oldin joylashuv ma'lumotlari yangilanmaganligini ta'minlash zaruriyatini tug'diradi. Eng yomon holatda, xususiyatini o'qish Big O notatsiyasida (O(n)) sifatida baholanadi. Buning sababi, bu xususiyatga kirish brauzerda reflow, ya'ni qayta joylashish, jarayonini keltirib chiqarishi mumkin, bu esa sahifadagi bir nechta elementlar uchun joylashuv pozitsiyalarini qayta hisoblashni o'z ichiga oladi. Bu kontekstda (n) reflow tomonidan ta'sir qilingan va o'zgartirilgan DOM elementlarining sonini anglatadi. Bevosita xususiyatga kirish tez bo'lsa-da, reflow kabi bog'langan side effect’lar sahifadagi elementlar soni bilan operatsiyaning ko'payishiga olib kelishi mumkin. dan foydalanishning afzalligi Agar biz kabi joylashuv xususiyatlariga kirish orqali keltirilishi mumkin bo'lgan reflow’dan qochmoqchi bo'lsak, biz operatsiyani samaraliroq qilish uchun ma'lum usullarni qo'llashimiz mumkin. Bu yerda, usulidan foydalanish bir yondashuv bo'lib, bu joylashuv o'qishni va yozishni birlashitirishi mumkin: dan foydalangan holda, biz bir martada bir nechta joylashuv xususiyatlarini olishimiz mumkin, bu esa bir nechta reflow’larni keltirib chiqarish ehtimolligini kamaytiradi. Qo'shimcha ravishda, o'qish va yozish operatsiyalarini alohida to'plab, birlashtirish orqali, biz _layout thrashing_(joylashuvni ortiqcha keraksiz qayta hisoblash va chizib chiqish)ni minimallashtirishimiz mumkin, bu esa tez-tez takrorlanuvchi aralash joylashuv xususiyatlarini o'qish va yozishdan kelib chiqadigan muhim bo'lmagan qayta hisoblashlarni anglatadi (rasmga qarang). Bu _thrashing_ veb-sahifaning ishlash samaradorligini sezilarli darajada pasaytirishi mumkin, bu esa foydalanuvchi bilan ishlash qulayligi(UX)ni sustlashuviga olib kelishi mumkin. Joylashuv xususiyatlariga strategik kirish va operatsiyalarimizni birlashtirish orqali, biz veb-sahifalarimizni silliq(smooth) va tez javob beruvchan(responsive) qilishimiz mumkin. !Layout thrashing image Reflow muammolari va Biroq, ham, agar kutilayotgan joylashuv o'zgarishlari bo'lsa, reflow’ni keltirib chiqarishi mumkin. Bu yerda performance’ning kaliti brauzerga joylashuvni qayta hisoblashga majburlashlar sonini minimallashtirishdir va qachonki buni amalga oshirsak, kerakli ma'lumotni bir marta olishga harakat qilishimiz kerak. React bularning barchasini biz uchun virtual DOM orqali real DOM operatsiyalari o'rtasidagi o'rta qatlam sifatida ishlatadi. Quyidagi misolni ko'rib chiqaylik, bu yerda oddiy HTML dokumenti va bitta elementi mavjud: Ushbu dokumentni brauzerda yuklaganimizda va dasturchi konsolini ochganimizda, elementining xususiyati konsolga yozilganini ko'rishimiz mumkin. Biroq, biz ko'rmaydigan narsa, brauzerning qiymatini hisoblash uchun bajargan ishlaridir. Bu jarayonni tushunish uchun, biz dasturchi vositalari(developer tools)dagi \"Performance panel\"idan foydalangan holda brauzerning faoliyatlarining vaqt jadvalini yozib olishimiz mumkin. Buni amalga oshirganda, brauzer dokumentni yuklab va chizib chiqish jarayonida bir necha joylashuv va ularni chizish operatsiyalarini bajarayotganini ko'rishimiz mumkin. Xususan, biz kodda ni o'qish bilan bog'liq ikkita joylashuv operatsiyasini ko'rishimiz mumkin. Har bir joylashuv operatsiyasini yakunlash uchun bir muncha vaqt talab etiladi (bu holatda, taxminan 2 ms), garchi ular faqat xususiyatning qiymatini o'qiyotgan bo'lsa ham. Buning sababi, brauzer o'zining joylashuv ma'lumotlarini yangilanishini ta'minlashi kerak, shunda u to'g'ri qiymatni qaytarishi mumkin, bu esa dokumentning to'liq joylashuv’ini bajarishni talab qiladi. Garchi 2 millisekund ko'p narsa bo'lib ko'rinmasa-da, bu vaqt dokument kengayganda katta sonlarga aylanadi. API’si Umuman olganda, biz kabi joylashuv’ga bog'liq xususiyatlarni ishlatayotganda ehtiyot bo'lishimiz kerak, chunki ular kutilmagan performance muammolarini keltirib chiqarishi mumkin. Agar biz bunday xususiyatlarning qiymatini bir necha marta o'qib va ishlatishimiz kerak bo'lsa, biz kerakli bo'lmagan joylashuv qayta hisoblashlarini chaqirishni oldini olish uchun qiymatni o'zgaruvchida saqlashni o'ylab ko'rishimiz kerak. Buning o'rniga, biz API’sidan foydalanib, xususiyatni o'qishni keyingi animatsiya freymiga kechiktirishimiz mumkin, bu paytda brauzer zarur joylashuv hisob-kitoblarini amalga oshirib olgan bo'ladi. Ro'yxat elementi misoli Real DOM bilan bog'liq tasodifiy uchrashi mumkin bo'lgan performance muammolarini yanada yaxshiroq tushunish uchun, keling, bir nechta misollarni ko'rib chiqaylik. Quyidagi HTML dokumentini ko'rib chiqamiz: Faraz qilaylik, biz JavaScript yordamida ro'yxatga yangi element qo'shmoqchimiz. Biz quyidagi kodni yozishimiz mumkin: Biz bu yerda o'rniga dan foydalanayotganimizga e'tibor bering, chunki: - Biz ID’ni bilamiz - Biz performance ijobiy va salbiy jihatlari, ya'ni ishlash samaradorligini ijobiy va salbiy jihatlarini bilamiz Keling, davom etamiz. Ushbu kod \"list\" ID'ga ega elementini tanlaydi, yangi elementini yaratadi, uning kontenti ga o'zgaradi va uni ro'yxatga qo'shadi. Bu kodni ishga tushirganimizda, brauzer yangi elementni ko'rsatish uchun joylashuvni qayta hisoblaydi, uni qayta chizib chiqadi va sahifaning o'zgargan qismlarini yangilaydi. Bu jarayon katta ro'yxatlar uchun sekin va ko'p resurs talab qilishi mumkin. Masalan, agar bizda 1,000 ta elementdan iborat ro'yxat bo'lsa va biz ro'yxat oxiriga yangi element qo'shmoqchi bo'lsak, biz quyidagi kodni yozishimiz mumkin: Ushbu kodni ishga tushirganda, brauzer layout’ni qayta hisoblaydi, uni qayta chizib chiqadi va butun ro'yxatni yangilaydi, atigi bittagina element qo'shilgan bo'lsa ham. Bu sekin ishlaydigan qurilmalarda yoki katta ro'yxatlarda ko'p vaqt va resurslarni talab qilishi mumkin. Ushbu muammoni yanada yaxshiroq tushuntirish uchun quyidagi misolni ko'rib chiqamiz: Bu misolda, bizda uchta elementdan iborat ro'yxat va bosilganda ikkinchi elementni ajratib ko'rsatuvchi tugma mavjud. Tugma bosilganda, brauzer layout’ni qayta hisoblash va butun ro'yxatni qayta chizib chiqib, yangi elementni ko'rsatish uchun dizaynni yangilashi kerak, garchi faqatgina bitta element o'zgargan bo'lsa ham. Bu foydalanuvchilar uchun sezilarli kechikish yoki ularni hafsalasini pir qiladigan turli miltillash(flicker)lar keltirib chiqarishi mumkin. Real DOM kamchiliklarini bartaraf etuvchi ba'zi texnikalar va Virtual DOM Umuman olganda, real DOM’ning ishlash muammolari biz uchun muhim qiyinchiliklarni tug'dirishi mumkin, ayniqsa, katta va murakkab veb sahifalar bilan ishlashda. Ushbu muammolarni bartaraf etish uchun ba'zi texnikalar mavjud, masalan, selektorlarni optimizatsiya qilish, event delegation’lardan foydalanish, DOM operatsiyalarini o'qish va yozish yangilanishlarini guruhlash yoki CSS animatsiyalaridan foydalanish, lekin ularni amalga oshirish murakkab va qiyin bo'lishi mumkin. Natijada, ko'pchiligimiz ushbu muammolarni hal qilish uchun virtual DOM’ga murojaat qilamiz. Virtual DOM bizdan real DOM’ning murakkabliklarini abstraksiya qilib, ya'ni bizdan yashirib, UI’ni yanada samarali va tezkor yaratish imkonini beradi. Millisekundlar millionlar olib keladi Ammo, bir necha millisekundni tejab qolish muhimmi? Protsessor yoki CPU ishlash samaradorligi har qanday dastur muvaffaqiyatiga katta ta'sir ko'rsatishi mumkin bo'lgan muhim omil sanaladi. Bugungi raqamli davrda foydalanuvchilar tez va moslashuvchan veb-saytlarni kutadilar, shuning uchun biz, veb dasturchilar sifatida, CPU samaradorligini birinchi o'ringa qo'yishimiz zarur. Bu haqida ko'proq qiziqqanlar bo'lsa, Google’ning veb-ishlab chiqish blogida chop etilgan Milliseconds make millions maqolasini o'qib chiqishlari mumkin. To'g'ridan-to'g'ri DOM manipulyatsiyasi, bu reflow (joylashuvni qayta hisoblash) va repaint (sahifani qayta chizish) jarayonlariga sabab bo'lishi, bu esa CPU foydalanishini va ishlov berish vaqtini oshirishi mumkin, natijada foydalanuvchilar uchun qimmatli bo'lgan kechikishlar va hatto ilovalarning ishlamay qolishiga olib kelishi mumkin. Bu, ayniqsa, kuchsiz qurilmalarda, masalan, smartfonlar yoki planshetlarda muammoli bo'lishi mumkin, chunki bunday qurilmalar cheklangan ishlov berish quvvati yoki cheklangan xotiraga ega bo'lishi mumkin. Dunyoning ko'plab qismlarida foydalanuvchilar eski yoki kam qobiliyatli qurilmalarda veb-ilovalarimizga kirishlari mumkin, bu esa muammoni yanada kuchaytirishi mumkin. CPU samaradorligini birinchi o'ringa qo'yish orqali biz keng turdagi qurilmalarda, ularning ishlov berish quvvatidan yoki xotirasidan qat'iy nazar, foydalanuvchilarga kirish mumkin bo'lgan ilovalarni yaratishimiz mumkin. Bu esa foydalanuvchilarni ko'proq jalb qilishga, konversiya darajalarini oshirishga va nihoyat, yanada muvaffaqiyatli onlayn dunyoda ishtirok etishlik darajasini oshishini ta'minlashga olib kelishi mumkin. Reactning virtual DOM’i CPU ishlashi tomonidan ancha samarador bo'lgan veb-ilovalarni qurishga imkon berdi; uning samarali renderlash algoritmlaridan foydalanish ishlov berish vaqtlarini minimallashtirishga va umumiy samaradorlikni oshirishga yordam beradi. Brauzerlararo o'zaro moslik Real DOM bilan mavjud yana bir muammo brauzerlararo o'zaro moslikdir. Turli brauzerlar dokumentlarni turlicha modellashtiradi, bu esa veb ilovalarda nomutanosibliklar va xatolarga olib kelishi mumkin. Bu muammo React ommaga taqdim qilinganda juda keng tarqalgan edi, hozir esa ancha kam uchraydi. Biroq, bu muammo dasturchilarga turli brauzerlar va platformalar o'rtasida muammosiz ishlaydigan veb ilovalarni yaratishni qiyinlashtirdi. Brauzerlararo o'zaro moslik bilan bog'liq asosiy muammolardan biri shundaki, ayrim DOM elementlari va atributlari barcha brauzerlarda bir xilda qo'llab-quvvatlanmasligi mumkin. Natijada, biz maqsad qilgan barcha platformalarda ilovalarning va uning funksiyalarini to'g'ri ishlashini ta'minlash uchun qo'shimcha vaqt va kuch sarflashimiz kerak edi. React SyntheticEvent Bu muammo React tomonidan o'zining sintetik event tizimi yordamida bartaraf etiladi. — bu brauzerlarning native event’larini o'rab olgan bir qoplama bo'lib, turli brauzerlar o'rtasida bir xillikni ta'minlash uchun mo'ljallangan. U brauzerlar o'rtasidagi nomutanosibliklarni quyidagi mexanizmlar yordamida bartaraf etadi: Birlashtirilgan interfeys Sof(Vanilla) JavaScript’da brauzer event’larini boshqarish nomutanosibliklar tufayli murakkab bo'lishi mumkin. Masalan, event xususiyatlariga kirish brauzerlarga qarab farq qilishi mumkin. Ba'zilari dan, boshqalari esa dan foydalanishi mumkin. bu turli-xilliklarni abstraksiyalaydi, event’lar bilan o'zaro mutanosiblikni ta'minlash uchun bir xil usulni taqdim etadi va dasturchilarni har bir brauzerga moslab kod yozish majburiyatidan ozod etadi: Brauzerlarning native event’larini o'z qobig'iga o'rab uni tizimlashtirgani uchun, React dasturchilarni native brauzer event tizimlaridagi ko'plab noaniqliklar va o'ziga xos xususiyatlardan himoya qiladi. Event delegation Event listener’larni to'g'ridan-to'g'ri elementlarga qo'shish o'rniga, React event’larni ildiz darajasi(root level)da tinglaydi. Bu yondashuv eski brauzerlarda ba'zi event’lar ma'lum elementlarda mavjud bo'lmasligi bilan bog'liq muammolarni osonlik bilan chetlab o'tadi. Kross-funksional yaxshilanishlar (Cross-functional enhancements) Native brauzer event’larida turli input elementlarida ba'zi event’larni qanday boshqarish borasida nomuvofiqliklar mavjud. E'tiborga molik misol - event’i: 1. Oddiy JavaScript’da, event’ining xatti-harakati input turlariga qarab farq qiladi: - uchun, ba'zi brauzerlarda event’i, qiymat o'zgarganidan so'ng darhol emas, balki input maydoni fokusni yo'qotganida, ishga tushishi mumkin. - uchun, bu har safar biron bir tanlanganda ishga tushishi mumkin, hatto bu oldingi bilan bir xil bo'lsa ham. - Boshqa holatlarda, ayniqsa eski brauzerlarda, event’i ma'lum bir elementlarida barcha foydalanuvchi interaktivliklarida ishonchli ishlamasligi mumkin. 2. React’ning tizimi event’ining ushbu input elementlari bo'yicha xatti-harakatini normallashtiradi. React’da: - Matn kiritish uchun event’i ( ) har bir bosish bilan doimiy ravishda ishga tushadi, bu real vaqtda fikr-mulohazalar(feedback) beradi. - uchun, yangi tanlanganda ishonchli ravishda ishga tushadi. - React, shuningdek, boshqa form elementlarida event’ining muvofiqligini ta'minlaydi. Bunday qilish orqali, React dasturchilarni ushbu native event bilan bog'liq nomutanosibliklar bilan shug'ullanishdan ozod qiladi, va bular bilan tashvishlanmasdan, diqqat-e'tiboringizni dasturni yozishga qaratish imkonini beradi. Native event’larga kirish Agar dasturchilar original brauzer event’ini olishlari kerak bo'lsa, buni orqali olishlar mumkin, bu esa abstraksiyaning foydalaridan voz kechmasdan moslashuvchanlikni ta'minlaydi Aslida, barqaror event tizimlarini taqdim etadi, native brauzer event’laridagi xususiyatlar va turli-xilliklarni bartaraf etadi. Bu React’ning virtual DOM’dan foydalanishining alohida bir usuli bo'lib, UI’ni ishlab chiqishda qulayliklar taqdim etadi. Hozirgacha biz DOM bilan to'g'ridan-to'g'ri ishlashning performance’ga ta'sir qiladigan muammolari va brauzerlararo o'zaro muvofiqlik muammolarini qanday keltirib chiqarishi haqida muhokama qildik. Endi, ushbu muammolarni yanada samarali tarzda hal qilish usulini ko'rib chiqamiz - bu dokument fragmentlari(document fragments)dan foydalanish, bu React’ning virtual DOM’ini tushunish uchun mahalliy tayanch sifatida qaralishi mumkin.",
    "url": "/books/fluent-react/virtual-dom/pitfalls-of-real-dom/page",
    "category": "books",
    "tags": [
      "fluent-react",
      "tutorial",
      "guide",
      "react",
      "javascript",
      "frontend",
      "mumkin",
      "uchun",
      "event",
      "dom",
      "biz",
      "bir",
      "bilan",
      "joylashuv",
      "qayta",
      "esa",
      "brauzer",
      "veb",
      "react",
      "real",
      "yoki"
    ]
  },
  {
    "id": "book-fluent-react-virtual-dom-real-dom-page",
    "title": "Real DOM nima? Tuzilishi va Manipulyatsiyasi",
    "content": "Real DOM HTML sahifasi veb brauzerga yuklanganda, u tahlil qilinadi(parsing) va tugunlar(nodes) va obyektlardan iborat daraxtga aylantiriladi — bu obyekt modeli bo'lib, DOM deb ataladi: bu shunchaki katta JavaScript obyekti. DOM — bu veb sahifaning jonli namoyandasi, ya'ni foydalanuvchilar sahifa bilan o'zaro aloqada bo'lar ekan, doimiy ravishda yangilanadi. Real DOM misoli Bu yerda oddiy HTML sahifasi uchun real DOM misoli keltirilgan: DOM’ning tugunlari Ushbu misolda, real DOM sahifadagi har bir HTML elementi uchun tugunlardan iborat daraxtga o'xshash struktura bilan tasvirlangan. Bu yerda daraxt strukrurasi qanday ko'rinishda bo'lishi mumkinligi haqida misol keltirilgan, bu tushunishni osonlashtirish uchun juda soddalashtirilgan. Real DOM’da har bir tugunda ko'pgina xususiyatlar va metodlar mavjud. Shunga qaramay, bu dokumentni obyekt sifatida qanday modellashtirishni tushunishimizga yordam beradi: bilan DOM manipulyatsiyasi Daraxtdagi har bir tugun HTML elementini ifodalaydi va uni JavaScript orqali manipulyatsiya qilish imkonini beruvchi xususiyatlar va metodlarni o'z ichiga oladi. Masalan, biz metodidan foydalanib, real DOM’dan ma'lum bir tugunni olishimiz va uning ichidagi kontentini o'zgartirishimiz mumkin: Ushbu misolda, biz metodi orqali class’iga ega bo'lgan elementini olamiz. Keyin, elementning kontentini xususiyatini ga o'rnatish orqali o'zgartiramiz. Bu sahifada tekstini ga o'zgartiradi. Bu juda murakkab ko'rinmaydi, ammo bu yerda e'tiborga olish kerak bo'lgan bir nechta narsalar mavjud. Birinchidan, biz real DOM’dan elementni olish uchun metodidan foydalanmoqdamiz. Ushbu metod CSS selektorini argument sifatida qabul qiladi va selektorga mos keladigan birinchi elementni qaytaradi. Ushbu holatda, biz class selektorini ishlatmoqdamiz, bu class’iga ega bo'lgan elementiga mos keladi. va Bu yerda bir oz xavf mavjud, chunki metodi real DOM’da CSS selektorlari asosida elementlarni tanlash uchun kuchli vosita bo'lsa-da, bu metodning potensial ishlash muammosi shundaki, katta va murakkab dokumentlarda ishlaganda bu sekin bo'lishi mumkin. Ushbu metod dokumentning yuqorisidan boshlab, kerakli elementni topish uchun pastga qarab o'tishi kerak, bu esa ko'proq vaqt talab qiladigan jarayon bo'lishi mumkin. Biz ni CSS selektori bilan chaqirganimizda, brauzer unga mos keladigan elementlar uchun butun dokument daraxtini qidirishi kerak. Bu, ayniqsa, dokument katta va murakkab strukturaga ega bo'lsa, qidirish sekin bo'lishini anglatadi. Bundan tashqari, brauzer selektorni o'zini baholashi kerak, bu esa selektorning qiyinligiga qarab murakkab jarayon bo'lishi mumkin. Aksincha, CSS selektorlari kabi validatsiyani talab qilmaydi va atributlari takrorlanmas(unique) bo'lishi tufayli aniqlik darajasini oshiradi, shuning uchun bu odatda samaraliroqdir. Murakkablik va ishlash samaradorligi Murakkablikni Big O notatsiyasi yordamida o'lchaganda, zamonaviy brauzerlarda (O(1)) ga yaqin hisoblanadi, chunki ular ID→element xaritalash uchun samarali hashing mexanizmlarini, masalan, hash jadvallarini qo'llashi mumkin. Idealdagi hash jadvali qidirishlari o'rtacha (O(1)) hisoblanadi, ammo eng yomon holatlarda, masalan, hash to'qnashuv(collision)larida, qidirish uzoqroq bo'lishi mumkin. Brauzerlar ID takrorlanmas bo'lishligini qat'iy ravishda amalga oshirmagani sababli, bu hash to'qnashuvlarining sodir bo'lishi ehtimoli katta. Shunga qaramay, zamonaviy brauzerlarda takomillashgan(advanced) hashing funksiyalari va o'lchov strategiyalari bilan bunday holatlar kamdan-kam uchraydi. <Callout type=\"info\"Big O notatsiyasi _Computer science_'da yaxshi bo'lmaganlar va ehtimol Big O’ni tushunmaydiganlar uchun, bu dasturchilar tomonidan kodning tez yoki sekin ishlashini baholash uchun ishlatiladigan qulay vositadir, ayniqsa kod ishlashi kerak bo'lgan ma'lumotlar miqdori oshganda. Aslida, Big O notatsiyasi algoritmlarning yuqori darajadagi tushunilishini ta'minlaydi, bunda vaqt murakkabligi (_time complexity_, ya'ni bajarilish vaqti kiritilish(input) hajmiga qarab qanday o'sadi) va joy murakkabligi (_space complexity_, ya'ni xotira hajmi kiritilish hajmiga qarab qanday o'sadi) nazarda tutiladi. Odatda bu quyidagi shakllarda ifodalanadi: (O(1)), (O(n)), (O(n log n)) yoki (O(n²)), bu yerda (n) — kiritilish hajmini bildiradi. Shunday qilib, dasturchilar kod \"samarali\" yoki \"kengayuvchan\" deb gapirganda, ular odatda shu Big O qiymatlari haqida gapirishadi, bu esa algoritmlarni vaqt va joy murakkabligi kamroq bo'lganini ta'minlash uchun mo'ljallangan bo'ladi. Bu esa dasturiy ta'minot ko'proq ma'lumot bilan ishlaganda ham samarador bo'lib qolishini kafolatlaydi. </Calloutning afzalligi Shuningdek, ID’lar takrorlanmas bo'lgani sababli, ular bir sahifada bir nechta qayta ishlatiladigan komponentlar uchun juda ham mos kelavermaydi. Aynan shu yerda ning afzalligi namoyon bo'ladi, chunki u bir xil class nomiga ega bo'lgan bir nechta elementlarni tanlash uchun ishlatilishi mumkin. Shu bilan birga, keng turdagi CSS selektorlarini qabul qilishi mumkin va uning murakkabligi o'zgaruvchan bo'ladi. Eng yomon holatda, bu usul DOM’ning butun strukturasini tekshirishi kerak bo'lishi mumkin, natijada uning murakkabligi (O(n)) bo'lib, bu yerda (n) DOM’dagi elementlar sonini bildiradi. Biroq, element DOM daraxtining avvalrog'ida topilsa, vaqt murakkabligi (O(n))’dan kichik bo'lishi mumkin. Ammo shuni yodda tutish kerakki, selektorlarni tahlil qilish va validatsiya qilishing qo'shimcha hisoblashning resurs talab qilishi ham mavjud. Shuningdek, va o'rtasidagi ishlash tezligi farqi kichik dokumentlarda yoki dokument daraxtining muayyan qismlarida elementlarni qidirishda unchalik sezilmasligi mumkin. Ammo katta va murakkab dokumentlarda bu farq yaqqol ko'rinadi. Virtual DOM ishlatishning samaradorligi Ba'zilar ushbu \"CPU samaradorligi\" argumenti haqida o'ylash haddan tashqari bo'rttirib yuborilgan, deb ta'kidlashlari mumkin va bunga ahamiyat berish kerak emas deb o'ylashadi. Bu to'g'ri bo'lishi yoki bo'lmasligi mumkin, ammo hech kim React’ning virtual DOM orqali logikani komponentlarga ajratib, o'zgaruvchan DOM’da state’ni boshqarish zaruratini bartaraf qilishdagi qo'shimcha qiymatini inkor eta olmaydi. DOM’ni o'zgaruvchan deb atashimizning sababi, uni foydalanuvchi bilan o'zaro interaktivligi, tarmoq so'rovlari, klient tomoni skriptlari va boshqa event’lar kabi ko'plab omillar ta'sirida doimiy ravishda o'zgarib turishi bilan bog'liq. React esa, virtual DOM orqali bizni ushbu muhitdan himoya qiladi. Biz bu nozik tafsilotlarga chuqur kirib borayapmiz, chunki React bilan haqiqatan ham mukammal ishlash uchun DOM’ning umumiy murakkabligini tushunish juda muhimdir. DOM bilan oqilona ishlash oddiy ish emas va React bilan biz tanlovga egamiz: o'zimiz DOM orqali bu mina maydonida harakat qilib, ba'zan minaga qadam bosamizmi yoki virtual DOM yordamida DOM’ni xavfsiz boshqarish uchun qo'shimcha vositadan foydalanamizmi. Elementlarni tanlashda ba'zi kichik nozik jihatlarni muhokama qildik, ammo DOM bilan to'g'ridan-to'g'ri ishlashning xavf-xatarlari haqida chuqurroq to'xtalish imkoniyatiga ega bo'lmadik. Keling, buni tezda ko'rib chiqib, React’ning virtual DOM bilan bizga taqdim etadigan qiymatini to'liq tushunaylik.",
    "url": "/books/fluent-react/virtual-dom/real-dom/page",
    "category": "books",
    "tags": [
      "fluent-react",
      "tutorial",
      "guide",
      "react",
      "javascript",
      "frontend",
      "dom",
      "uchun",
      "bilan",
      "mumkin",
      "bir",
      "lishi",
      "real",
      "yerda",
      "ushbu",
      "biz",
      "kerak",
      "ning",
      "orqali",
      "ammo",
      "yoki"
    ]
  },
  {
    "id": "book-fluent-react-virtual-dom-recap-page",
    "title": "Virtual DOM Xulosasi: Asosiy Tushunchalar va Takrorlash",
    "content": "Bo'limni qisqacha takrorlash Ushbu bob davomida biz veb dasturlashda real DOM va virtual DOM o'rtasidagi farqlar hamda React’da virtual DOM’dan foydalanishning afzalliklarini o'rganib chiqdik. Dastlab, real DOM haqida gaplashdik va uning sekin renderlash va turli brauzerlararo o'zaro mos kelishi kabi cheklovlari borligini muhokama qildik. Bu holat dasturchilarga turli platformalarda bir xil ishlaydigan veb ilovalarni yaratishda qiyinchilik tug'dirishi mumkin. Buni tasvirlash uchun biz real DOM API’laridan foydalanib oddiy veb sahifa yaratish misolini ko'rib chiqdik va sahifaning murakkabligi oshgani sayin bu API’larni boshqarish qiyinlashib borishini ko'rdik. Keyinchalik, virtual DOM’ga o'tib, uning qanday qilib real DOM cheklovlarini hal qilishi haqida so'z yuritdik. React virtual DOM’dan foydalanib, real DOM’ga kerakli yangilanishlar sonini minimallashtirib, renderlash vaqti tomonidan qimmatli bo'lgan, performance muammosini qanday kamaytirishi haqida tushuntirdik. React elementlardan foydalanib, virtual DOM’ni oldingi versiyasi bilan solishtirishi va real DOM’ni yangilashning eng samarali usulini hisoblash jarayonini ko'rib chiqdik. Virtual DOM afzalliklarini ko'rsatish uchun biz React komponentlaridan foydalanib xuddi shu oddiy veb sahifani yaratish misolini ko'rib chiqdik. Ushbu yondashuvni real DOM yondashuvi bilan taqqoslab, sahifa murakkabligi oshgani sari React komponentlarining yanada ixcham va boshqarishga osonroq ekanligini ko'rdik. Shuningdek, va o'rtasidagi farqlarni ko'rib chiqdik va JSX yordamida komponentlarni qanday yaratish mumkinligini o'rgandik. JSX HTML’ga o'xshash sintaksisni taqdim etib, virtual DOM strukturasini tushunishni osonlashtiradi. Oxirgi qismda esa React \"diffing\" algoritmining keraksiz qayta render qilishlarga olib kelishi mumkinligi haqida gapirdik. Bu ayniqsa katta va murakkab foydalanuvchi interfeyslarida jiddiy performance muammolariga olib kelishi mumkin. Biz bu masalani 5-bobda React’ning va xususiyatlaridan foydalanib qanday optimizatsiya qilish mumkinligini o'rganamiz. Umuman olganda, bu bobda veb dasturlashda virtual DOM’dan foydalanishning afzalliklari haqida va React bu konsepsiyadan foydalanib veb ilovalarni yaratishni qanday oson va samarali qilishini o'rgandik. Takrorlash uchun savollar Quyidagi savollarga javob berib, mavzularni yaxshiroq tushunganingizni tekshirib ko'ring: 1. _DOM nima va u virtual DOM bilan qanday taqqoslanadi?_ 2. _Document fragmentlar nima va ular React’ning virtual DOM’iga o'xshash va farqli jihatlari qanday?_ 3. _DOM bilan bog'liq muammolar qanday?_ 4. _Virtual DOM foydalanuvchi interfeys yangilanishlarini qanday tezroq bajaradi?_ 5. _React renderlash qanday ishlaydi? Ushbu jarayondan qanday potensial muammolar kelib chiqishi mumkin?_ Keyingi bo'lim Kelasi 4-bobda React reconciliation va uning Fiber arxitekturasi haqida chuqurroq o'rganamiz.",
    "url": "/books/fluent-react/virtual-dom/recap/page",
    "category": "books",
    "tags": [
      "fluent-react",
      "tutorial",
      "guide",
      "react",
      "javascript",
      "frontend",
      "dom",
      "virtual",
      "qanday",
      "react",
      "real",
      "veb",
      "haqida",
      "foydalanib",
      "chiqdik",
      "biz",
      "rib",
      "bilan",
      "takrorlash",
      "ushbu",
      "dan"
    ]
  },
  {
    "id": "book-fluent-react-virtual-dom-virtual-dom-vs-real-dom-page",
    "title": "Virtual DOM va Real DOM Farqi: `React.createElement` vs `document.createElement`",
    "content": "Virtual DOM va Real DOM o'rtasidagi farq funksiyasi va DOM’ning ichki o'rnatilgan metodi ikkalasi ham yangi elementlarni yaratishda o'xshash; ammo, React elementlarini yaratadi, esa DOM tugunlarini yaratadi. Ular implementatsiya, ya'ni amalga oshirish, jihatidan juda farq qiladi, ammo konseptual jihatdan bir xil funksiyani bajaradi. — bu React tomonidan taqdim etilgan funksiya bo'lib, xotirada yangi virtual element yaratadi. — DOM API tomonidan taqdim etilgan metod bo'lib, xotirada yangi element yaratadi, lekin u DOM’ga yoki boshqa o'xshash API’lar yordamida qo'shilmaguncha real DOM’ga ulanmaydi. Ikkala funksiya ham birinchi argument sifatida teg nomlarini qabul qiladi, ammo qo'shimcha argumentlar sifatida props va children’ni qabul qiladi. va ga misol Quyida ikkala usul yordamida elementi qanday yaratilishini taqqoslaymiz: React'da virtual DOM va real DOM konseptual jihatdan o'xshash, chunki ikkalasi ham elementlarning daraxtga o'xshash strukturani ifodalaydi. React komponenti render qilinayotganda, React yangi virtual DOM daraxtini yaratadi, uni avvalgi virtual DOM daraxti bilan taqqoslaydi va eski daraxtni yangi daraxtga moslashtirish uchun minimal o'zgarishlarni hisoblaydi. Bu jarayon _reconciliation process_, ya'ni _moslashtirish jarayoni_, deb nomlanadi. Reconciliation jarayoni misoli Quyidagi misolda, React komponentida bu jarayon qanday ishlashini ko'rsatamiz: Yuqoridagi komponentni quyidagicha ham ifodalash mumkin: chaqiruvlarida, birinchi argument HTML teg nomi yoki React komponentining nomi, ikkinchi argument xususiyatlar obyektini (yoki xususiyatlar bo'lmasa qiymatini) bildiradi, va qolgan argumentlar bola elementlar sifatida xizmat qiladi. Komponent dastlab render qilinganda, React quyidagi kabi virtual DOM daraxtini yaratadi: Button bosilganda, React yangi virtual DOM daraxtini yaratadi, bu yangi ko'rinishda bo'ladi: Keyin React bu yangi va eski daraxtlarni taqqoslab, faqat elementi tarkibidagi kontentni yangilash kerakligini aniqlaydi va faqat shu qismni real DOM’da yangilaydi. Virtual DOM’dan foydalanish React’ga real DOM’ga samarali yangilanishlarni kiritish imkonini beradi. Bu yondashuv React’ni boshqa kutubxonalar bilan mos ishlashiga ham yordam beradi, hatto ular to'g'ridan-to'g'ri DOM’ni manipulyatsiya qilayotgan bo'lsa ham.",
    "url": "/books/fluent-react/virtual-dom/virtual-dom-vs-real-dom/page",
    "category": "books",
    "tags": [
      "fluent-react",
      "tutorial",
      "guide",
      "react",
      "javascript",
      "frontend",
      "dom",
      "react",
      "virtual",
      "yangi",
      "yaratadi",
      "real",
      "ham",
      "xshash",
      "qiladi",
      "ammo",
      "yoki",
      "argument",
      "sifatida",
      "daraxtini",
      "farq"
    ]
  }
]