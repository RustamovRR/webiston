# Sikllar

Shartli koâ€˜rsatmalarni tushunish uchun biz JavaScript interpretatorini manba kodingiz boâ€˜ylab tarmoqlanuvchi yoâ€˜ldan bormoqda deb tasavvur qilgan edik. **Sikl koâ€˜rsatmalari** esa, kodingizning maâ€™lum qismlarini takrorlash uchun oâ€˜sha yoâ€˜lni oâ€˜z-oâ€˜ziga qaytarib bogâ€˜laydigan koâ€˜rsatmalardir. JavaScript'da beshta sikl koâ€˜rsatmasi mavjud: `while`, `do/while`, `for`, `for/of` (va uning `for/await` varianti) hamda `for/in`. Keyingi quyi boâ€˜limlar har birini navbatma-navbat tushuntiradi. Sikllarning keng tarqalgan qoâ€˜llanilishidan biri â€” bu massiv elementlari boâ€˜ylab iteratsiya qilishdir. Â§7.6-boâ€˜limda bu turdagi sikllar batafsil muhokama qilinadi va `Array` klassi tomonidan taâ€™riflangan maxsus sikl metodlari yoritiladi.

## `while`

Xuddi `if` koâ€˜rsatmasi JavaScript'ning asosiy shartli koâ€˜rsatmasi boâ€˜lgani kabi, `while` koâ€˜rsatmasi ham JavaScript'ning asosiy siklidir. U quyidagi sintaksisga ega:

``` js
while (expression)
    statement
```

`while` koâ€˜rsatmasini bajarish uchun interpretator avval `expression`'ni baholaydi. Agar ifodaning qiymati _falsy_ boâ€˜lsa, interpretator sikl tanasi vazifasini bajaruvchi `statement`'ni oâ€˜tkazib yuboradi va dasturdagi keyingi koâ€˜rsatmaga oâ€˜tadi. Boshqa tomondan, agar ifoda _truthy_ boâ€˜lsa, interpretator `statement`'ni bajaradi va takrorlaydi, yaâ€™ni siklning boshiga qaytib, `expression`'ni qaytadan baholaydi. Buni boshqacha aytganda, interpretator `expression` _truthy_ boâ€˜lib turar ekan, `statement`'ni takroran bajaradi. Eâ€™tibor bering, `while(true)` sintaksisi yordamida cheksiz sikl yaratish mumkin.

Odatda, JavaScript'ning bir xil amalni qayta-qayta bajarishini hech kim xohlamaydi. Deyarli har bir siklda, siklning har bir iteratsiyasida bir yoki bir nechta oâ€˜zgaruvchi oâ€˜zgaradi. Oâ€˜zgaruvchilar oâ€˜zgargani sababli, `statement`'ni bajarish orqali amalga oshiriladigan harakatlar siklning har bir aylanishida farq qilishi mumkin. Bundan tashqari, agar oâ€˜zgaruvchan oâ€˜zgaruvchi yoki oâ€˜zgaruvchilar `expression`'da ishtirok etsa, ifodaning qiymati ham siklning har bir aylanishida farqli boâ€˜lishi mumkin. Bu muhim; aks holda, _truthy_ boâ€˜lib boshlangan ifoda hech qachon oâ€˜zgarmas edi va sikl hech qachon tugamas edi!

Quyida 0 dan 9 gacha boâ€˜lgan sonlarni chiqaradigan `while` sikliga misol keltirilgan:

``` js
let count = 0;
while(count < 10) {
    console.log(count);
    count++;
}
```

Koâ€˜rib turganingizdek, `count` oâ€˜zgaruvchisi 0 dan boshlanadi va sikl tanasi har safar ishlaganda inkrement qilinadi. Sikl 10 marta bajarilgandan soâ€˜ng, ifoda `false` boâ€˜ladi (yaâ€™ni, `count` oâ€˜zgaruvchisi endi 10 dan kichik boâ€˜lmaydi), `while` koâ€˜rsatmasi yakunlanadi va interpretator dasturdagi keyingi koâ€˜rsatmaga oâ€˜tishi mumkin. Koâ€˜pgina sikllar `count` kabi hisoblagich oâ€˜zgaruvchisiga ega. `i`, `j` va `k` oâ€˜zgaruvchi nomlari odatda sikl hisoblagichlari sifatida ishlatiladi, garchi kodni tushunishni osonlashtirsa, yanada tavsiflovchi nomlardan foydalanish kerak.

## `do/while`

`do/while` sikli `while` sikliga juda oâ€˜xshaydi, faqat unda sikl ifodasi siklning boshida emas, balki oxirida tekshiriladi. Bu shuni anglatadiki, sikl tanasi **har doim kamida bir marta** bajariladi. Uning sintaksisi quyidagicha:

``` js
do
    statement
while (expression);
```

`do/while` sikli oâ€˜zining "qarindoshi" `while`'ga qaraganda kamroq qoâ€˜llaniladi â€” amalda, biror siklning kamida bir marta bajarilishini aniq xohlash holati unchalik koâ€˜p uchramaydi.

Quyida `do/while` sikliga misol keltirilgan:

``` js
function printArray(a) {
    let len = a.length, i = 0;
    if (len === 0) {
        console.log("Empty Array");
    } else {
        do {
            console.log(a[i]);
        } while(++i < len);
    }
}
```

`do/while` sikli va oddiy `while` sikli oâ€˜rtasida bir nechta sintaktik farqlar mavjud. Birinchidan, `do` sikli ham `do` kalit soâ€˜zini (sikl boshlanishini belgilash uchun), ham `while` kalit soâ€˜zini (sikl oxirini belgilash va sikl shartini kiritish uchun) talab qiladi. Shuningdek, `do` sikli har doim nuqtali vergul bilan yakunlanishi shart. `while` siklida esa, agar sikl tanasi jingalak qavslar ichiga olingan boâ€˜lsa, nuqtali vergul kerak boâ€˜lmaydi.

## `for`

`for` koâ€˜rsatmasi `while` koâ€˜rsatmasidan koâ€˜ra koâ€˜pincha qulayroq boâ€˜lgan sikl tuzilmasini taqdim etadi. `for` koâ€˜rsatmasi keng tarqalgan biror andozaga (`pattern`) mos keladigan sikllarni soddalashtiradi. Koâ€˜pchilik sikllar qandaydir hisoblagich oâ€˜zgaruvchisiga ega boâ€˜ladi. Bu oâ€˜zgaruvchi sikl boshlanishidan oldin initsializatsiya qilinadi va siklning har bir iteratsiyasidan oldin tekshiriladi. Nihoyat, hisoblagich oâ€˜zgaruvchisi sikl tanasining oxirida, oâ€˜zgaruvchi qayta tekshirilishidan sal oldin, inkrement qilinadi yoki boshqacha tarzda yangilanadi. Bu turdagi siklda initsializatsiya, tekshiruv va yangilash sikl oâ€˜zgaruvchisining uchta hal qiluvchi amali hisoblanadi. `for` koâ€˜rsatmasi bu uch amalning har birini ifoda sifatida kodlaydi va bu ifodalarni sikl sintaksisining aniq bir qismiga aylantiradi:

``` js
for(initialize ; test ; increment)
    statement
```

`initialize`, `test` va `increment` â€” bu sikl oâ€˜zgaruvchisini initsializatsiya qilish, tekshirish va inkrement qilish uchun masâ€™ul boâ€˜lgan uchta ifodadir (nuqtali vergullar bilan ajratilgan). Ularning barchasini siklning birinchi qatoriga joylashtirish `for` sikli nima qilayotganini tushunishni osonlashtiradi va sikl oâ€˜zgaruvchisini initsializatsiya qilish yoki inkrement qilishni unutish kabi xatolarning oldini oladi.

`for` sikli qanday ishlashini tushuntirishning eng oddiy yoâ€˜li â€” uning ekvivalent `while` siklini koâ€˜rsatishdir:[^2]

``` js
initialize;
while(test) {
    statement
    increment;
}
```

Boshqacha aytganda, `initialize` ifodasi sikl boshlanishidan oldin bir marta baholanadi. Foydali boâ€˜lishi uchun bu ifoda qoâ€˜shimcha taâ€™sirga ega boâ€˜lishi kerak (odatda tayinlash). JavaScript, shuningdek, `initialize`'ning oâ€˜zgaruvchi eâ€™lon qilish koâ€˜rsatmasi boâ€˜lishiga ham ruxsat beradi, shunda sikl hisoblagichini bir vaqtning oâ€˜zida ham eâ€™lon, ham initsializatsiya qilish mumkin. `test` ifodasi har bir iteratsiyadan oldin baholanadi va sikl tanasining bajarilishi yoki bajarilmasligini nazorat qiladi. Agar `test` _truthy_ qiymatga baholansa, sikl tanasi boâ€˜lgan `statement` bajariladi. Nihoyat, `increment` ifodasi baholanadi. Yana, foydali boâ€˜lishi uchun bu ham qoâ€˜shimcha taâ€™sirga ega ifoda boâ€˜lishi kerak. Odatda, u yo tayinlash ifodasi boâ€˜ladi, yo `++` yoki `--` operatorlaridan foydalanadi.

Biz 0 dan 9 gacha boâ€˜lgan sonlarni `for` sikli yordamida quyidagicha chiqarishimiz mumkin. Uni oldingi boâ€˜limda koâ€˜rsatilgan ekvivalent `while` sikli bilan solishtirib ko'ring:

``` js
for(let count = 0; count < 10; count++) {
    console.log(count);
}
```

Albatta, sikllar bu oddiy misoldan ancha murakkabroq boâ€˜lishi mumkin va baâ€™zan siklning har bir iteratsiyasida bir nechta oâ€˜zgaruvchi oâ€˜zgaradi. Bu holat JavaScript'da vergul operatori keng qoâ€˜llaniladigan yagona joydir; u bir nechta initsializatsiya va inkrement ifodalarini `for` siklida ishlatishga yaroqli yagona ifodaga birlashtirish yoâ€˜lini taqdim etadi:

``` js
let i, j, sum = 0;
for(i = 0, j = 10 ; i < 10 ; i++, j--) {
    sum += i * j;
}
```

Hozirgacha barcha sikl misollarimizda sikl oâ€˜zgaruvchisi sonli boâ€˜ldi. Bu juda keng tarqalgan, lekin majburiy emas. Quyidagi kod bogâ€˜langan roâ€˜yxat (`linked list`) maâ€™lumotlar tuzilmasi boâ€˜ylab harakatlanish va roâ€˜yxatdagi oxirgi obyektni (yaâ€™ni, `next` xossasiga ega boâ€˜lmagan birinchi obyektni) qaytarish uchun `for` siklidan foydalanadi:

``` js
function tail(o) {                          // `o` bogâ€˜langan roâ€˜yxatining "dumini" qaytarish
    for(; o.next; o = o.next) /* boâ€˜sh */ ; // `o.next` "truthy" boâ€˜lsa, harakatlanish
    return o;
}
```

Eâ€™tibor bering, bu kodda `initialize` ifodasi yoâ€˜q. `for` siklidan uchta ifodaning har qanday turi tushirib qoldirilishi mumkin, lekin ikkita nuqtali vergul talab qilinadi. Agar `test` ifodasini tushirib qoldirsangiz, sikl cheksiz takrorlanadi va `for(;;)` cheksiz sikl yozishning `while(true)` kabi yana bir usulidir.

[^2]: Â§5.5.3-boâ€˜limda `continue` koâ€˜rsatmasini koâ€˜rib chiqqanimizda, bu `while` sikli `for` siklining aniq ekvivalenti emasligini koâ€˜ramiz.

## `for/of`

ES6 yangi sikl koâ€˜rsatmasini kiritdi: `for/of`. Bu yangi turdagi sikl `for` kalit soâ€˜zidan foydalanadi, lekin u oddiy `for` siklidan butunlay farq qiladigan sikl turidir. (U, shuningdek, Â§5.4.5-boâ€˜limda tasvirlanadigan eskiroq `for/in` siklidan ham butunlay farq qiladi.)

`for/of` sikli **iteratsiya qilinadigan (`iterable`)** obyektlar bilan ishlaydi. Biror obyektning iteratsiya qilinadigan boâ€˜lishi aynan nima ekanligini 12-bobda tushuntiramiz, lekin bu bob uchun massivlar, satrlar, toâ€˜plamlar (`Set`) va xaritalar (`Map`) iteratsiya qilinadigan ekanligini bilish kifoya: ular `for/of` sikli yordamida aylanib yoki iteratsiya qilib chiqishingiz mumkin boâ€˜lgan elementlar ketma-ketligi yoki toâ€˜plamini ifodalaydi.

Mana, masalan, sonlar massivining elementlari boâ€˜ylab aylanib chiqish va ularning yigâ€˜indisini hisoblash uchun `for/of`'dan qanday foydalanishimiz mumkin:

``` js
let data = [1, 2, 3, 4, 5, 6, 7, 8, 9], sum = 0;
for(let element of data) {
    sum += element;
}
sum // => 45
```

Yuzaki qaraganda, sintaksis oddiy `for` sikliga oâ€˜xshaydi: `for` kalit soâ€˜zidan keyin sikl nima qilishi kerakligi haqidagi tafsilotlarni oâ€˜z ichiga olgan qavslar keladi. Bu holda, qavslar ichida oâ€˜zgaruvchi eâ€™loni (yoki allaqachon eâ€™lon qilingan oâ€˜zgaruvchilar uchun shunchaki oâ€˜zgaruvchi nomi), undan keyin `of` kalit soâ€˜zi va bu holdagi `data` massivi kabi iteratsiya qilinadigan obyektga baholanadigan ifoda keladi. Barcha sikllardagi kabi, `for/of` siklining tanasi ham qavslardan keyin, odatda jingalak qavslar ichida keladi.

Hozirgina koâ€˜rsatilgan kodda, sikl tanasi `data` massivining har bir elementi uchun bir marta ishga tushadi. Sikl tanasi har safar bajarilishidan oldin, massivning navbatdagi elementi `element` oâ€˜zgaruvchisiga tayinlanadi. Massiv elementlari birinchisidan oxirgisiga qarab tartib bilan iteratsiya qilinadi.

Massivlar "jonli" iteratsiya qilinadi â€” iteratsiya davomida kiritilgan oâ€˜zgarishlar iteratsiya natijasiga taâ€™sir qilishi mumkin. Agar biz oldingi kodni sikl tanasi ichiga `data.push(sum);` qatorini qoâ€˜shish orqali oâ€˜zgartirsak, u holda cheksiz sikl yaratgan boâ€˜lamiz, chunki iteratsiya hech qachon massivning oxirgi elementiga yeta olmaydi.

### `for/of` va obyektlar

Obyektlar standart holatda iteratsiya qilinadigan (`iterable`) emas. Oddiy obyekt ustida `for/of`'dan foydalanishga urinish `runtime`'da `TypeError` xatoligiga sabab boâ€˜ladi:

``` js
let o = { x: 1, y: 2, z: 3 };
for(let element of o) { // `o` obyekti iteratsiya qilinadigan boâ€˜lmagani uchun TypeError yuzaga keladi
    console.log(element);
}
```

Agar obyektning xossalari boâ€˜ylab iteratsiya qilmoqchi boâ€˜lsangiz, `for/in` siklidan (Â§5.4.5-boâ€˜limda tanishtiriladi) foydalanishingiz yoki `for/of`'ni `Object.keys()` metodi bilan birga ishlatishingiz mumkin:

``` js
let o = { x: 1, y: 2, z: 3 };
let keys = "";
for(let k of Object.keys(o)) {
    keys += k;
}
keys // => "xyz"
```

Bu ishlaydi, chunki `Object.keys()` obyektning xossa nomlari massivini qaytaradi, massivlar esa `for/of` bilan iteratsiya qilinadi. Shuni ham yodda tutingki, obyekt kalitlarining bu iteratsiyasi yuqoridagi massiv misolidagidek "jonli" emas â€” sikl tanasida `o` obyektiga kiritilgan oâ€˜zgarishlar iteratsiyaga taâ€™sir qilmaydi.

Agar sizga obyektning kalitlari qiziq boâ€˜lmasa, ularning mos qiymatlari boâ€˜ylab quyidagicha iteratsiya qilishingiz ham mumkin:

``` js
let sum = 0;
for(let v of Object.values(o)) {
    sum += v;
}
sum // => 6
```

Va agar sizga obyekt xossalarining ham kalitlari, ham qiymatlari qiziq boâ€˜lsa, `for/of`'ni `Object.entries()` va destrukturizatsiya orqali tayinlash bilan birga ishlatishingiz mumkin:

``` js
let pairs = "";
for(let [k, v] of Object.entries(o)) {
    pairs += k + v;
}
pairs // => "x1y2z3"
```

`Object.entries()` massivlar massivini qaytaradi, bunda har bir ichki massiv obyektning bir xossasi uchun kalit/qiymat juftligini ifodalaydi. Biz bu kod misolida oâ€˜sha ichki massivlarni ikkita alohida oâ€˜zgaruvchiga "ochib olish" (`unpack`) uchun destrukturizatsiya orqali tayinlashdan foydalandik.

### `for/of` va satrlar

ES6'da satrlar belgima-belgi iteratsiya qilinadi:

``` js
let frequency = {};
for(let letter of "mississippi") {
    if (frequency[letter]) {
        frequency[letter]++;
    } else {
        frequency[letter] = 1;
    }
}
frequency // => {m: 1, i: 4, s: 4, p: 2}
```

Eâ€™tibor bering, satrlar UTF-16 belgisi boâ€˜yicha emas, balki **Unicode kod nuqtasi (`codepoint`)** boâ€˜yicha iteratsiya qilinadi. "I â¤ï¸ ðŸˆ" satrining `.length` xossasi 5 ga teng (chunki ikkita emoji belgisining har birini ifodalash uchun ikkita UTF-16 belgisi kerak boâ€˜ladi). Lekin agar siz bu satrni `for/of` bilan iteratsiya qilsangiz, sikl tanasi uch marta ishga tushadi, yaâ€™ni uchta kod nuqtasi â€” "I", "â¤ï¸", va "ðŸˆ" â€” uchun bir martadan.

### `for/of` hamda `Set` va `Map`

ES6'ning tayyor ichki oâ€˜rnatilgan `Set` va `Map` klasslari iteratsiya qilinadigan (`iterable`) hisoblanadi. `Set`'ni `for/of` bilan iteratsiya qilganingizda, sikl tanasi toâ€˜plamning har bir elementi uchun bir martadan ishga tushadi. Siz matn satridagi unikal soâ€˜zlarni chiqarish uchun quyidagi kabi koddan foydalanishingiz mumkin:

``` js
let text = "Na na na na na na na na Batman!";
let wordSet = new Set(text.split(" "));
let unique = [];
for(let word of wordSet) {
    unique.push(word);
}
unique // => ["Na", "na", "Batman!"]
```

`Map`'lar qiziqarli holatdir, chunki `Map` obyekti uchun iterator `Map` kalitlarini yoki `Map` qiymatlarini emas, balki kalit/qiymat juftliklarini iteratsiya qiladi. Iteratsiyaning har bir aylanishida iterator birinchi elementi kalit, ikkinchi elementi esa unga mos qiymat boâ€˜lgan massivni qaytaradi. `m` `Map`'i berilgan boâ€˜lsa, siz uning kalit/qiymat juftliklarini quyidagicha iteratsiya qilishingiz va destrukturizatsiya qilishingiz mumkin:

``` js
let m = new Map([[1, "one"]]);
for(let [key, value] of m) {
    key   // => 1
    value // => "one"
}
```

### `for/await` bilan asinxron iteratsiya

ES2018 **asinxron iterator** deb nomlanuvchi yangi iterator turini va asinxron iteratorlar bilan ishlaydigan `for/of` siklining **`for/await` sikli** deb nomlanuvchi variantini kiritdi.

`for/await` siklini tushunish uchun 12 va 13-boblarni oâ€˜qishingiz kerak boâ€˜ladi, lekin uning kodda qanday koâ€˜rinishi quyidagicha:

``` js
// Asinxron iteratsiya qilinadigan oqimdan qismlarni (`chunks`) oâ€˜qish va ularni chiqarish
async function printStream(stream) {
    for await (let chunk of stream) {
        console.log(chunk);
    }
}
```

## `for/in`

`for/in` sikli `for/of` sikliga juda oâ€˜xshaydi, faqat `of` kalit soâ€˜zi `in`'ga oâ€˜zgartirilgan. `for/of` sikli `of`'dan keyin iteratsiya qilinadigan (`iterable`) obyektni talab qilsa, `for/in` sikli `in`'dan keyin har qanday obyekt bilan ishlay oladi. `for/of` sikli ES6'da yangi, lekin `for/in` JavaScript'ning dastlabki davrlaridanoq uning bir qismi boâ€˜lgan (shuning uchun ham uning sintaksisi tabiiyroq eshitiladi).

`for/in` koâ€˜rsatmasi belgilangan obyektning **xossa nomlari** boâ€˜ylab aylanib chiqadi. Uning sintaksisi quyidagicha koâ€˜rinadi:

``` js
for (variable in object)
    statement
```

`variable` odatda oâ€˜zgaruvchini nomlaydi, lekin u oâ€˜zgaruvchi eâ€™loni yoki tayinlash ifodasining chap tomoniga mos keladigan har qanday narsa boâ€˜lishi mumkin. `object` esa obyektga baholanadigan ifodadir. Odatdagidek, `statement` sikl tanasi vazifasini bajaruvchi koâ€˜rsatma yoki koâ€˜rsatmalar blokidir.

Siz `for/in` siklini quyidagicha ishlatishingiz mumkin:

``` js
for(let p in o) {       // `o` obyektining xossa nomlarini `p` oâ€˜zgaruvchisiga tayinlash
    console.log(o[p]);  // Har bir xossaning qiymatini chiqarish
}
```

`for/in` koâ€˜rsatmasini bajarish uchun JavaScript interpretatori avval `object` ifodasini baholaydi. Agar u `null` yoki `undefined`'ga baholansa, interpretator siklni oâ€˜tkazib yuboradi va keyingi koâ€˜rsatmaga oâ€˜tadi. Soâ€˜ngra interpretator obyektning har bir **sanab oâ€˜tiladigan (`enumerable`)** xossasi uchun sikl tanasini bir martadan bajaradi. Biroq har bir iteratsiyadan oldin, interpretator `variable` ifodasini baholaydi va unga xossaning nomini (satr qiymatini) tayinlaydi.

Eâ€™tibor bering, `for/in` siklidagi `variable` ixtiyoriy ifoda boâ€˜lishi mumkin, agar u tayinlashning chap tomoniga mos keladigan biror narsaga baholansa. Bu ifoda siklning har bir aylanishida baholanadi, bu esa uning har safar turlicha baholanishi mumkinligini anglatadi. Masalan, siz barcha obyekt xossalarining nomlarini massivga koâ€˜chirish uchun quyidagi kabi koddan foydalanishingiz mumkin:

``` js
let o = { x: 1, y: 2, z: 3 };
let a = [], i = 0;
for(a[i++] in o) /* boâ€˜sh */;
```

JavaScript massivlari shunchaki obyektning ixtisoslashgan bir turidir va massiv indekslari `for/in` sikli yordamida sanab oâ€˜tilishi mumkin boâ€˜lgan obyekt xossalaridir. Masalan, oldingi koddan keyin kelgan bu qator `0`, `1` va `2` massiv indekslarini sanab oâ€˜tadi:

``` js
for(let i in a) console.log(i);
```

Men oâ€˜z kodimdagi keng tarqalgan xatoliklar manbalaridan biri bu `for/of`'ni ishlatmoqchi boâ€˜lganimda, tasodifan massivlar bilan `for/in`'ni ishlatib yuborishim ekanligini payqaganman. Massivlar bilan ishlayotganda, deyarli har doim `for/in` oâ€˜rniga `for/of`'dan foydalanish kerak.

`for/in` sikli aslida obyektning **barcha** xossalarini sanab oâ€˜tmaydi. U nomlari `symbol` boâ€˜lgan xossalarni sanab oâ€˜tmaydi. Va nomlari satr boâ€˜lgan xossalardan faqat **sanab oâ€˜tiladigan (`enumerable`)** xossalar boâ€˜ylab aylanib chiqadi (Â§14.1-boâ€˜limga qarang). JavaScript yadrosi tomonidan taâ€™riflangan turli ichki oâ€˜rnatilgan metodlar sanab oâ€˜tilmaydi. Masalan, barcha obyektlar `toString()` metodiga ega, lekin `for/in` sikli bu `toString` xossasini sanab oâ€˜tmaydi. Ichki oâ€˜rnatilgan metodlardan tashqari, ichki oâ€˜rnatilgan obyektlarning koâ€˜plab boshqa xossalari ham sanab oâ€˜tilmaydi. Sizning kodingiz tomonidan taâ€™riflangan barcha xossalar va metodlar esa, standart holatda, sanab oâ€˜tiladigan boâ€˜ladi. (Â§14.1-boâ€˜limda tushuntirilgan usullar yordamida ularni sanab oâ€˜tilmaydigan qilishingiz mumkin.)

Sanab oâ€˜tiladigan meros qilib olingan xossalar (Â§6.3.2) ham `for/in` sikli tomonidan sanab oâ€˜tiladi. Bu shuni anglatadiki, agar siz `for/in` sikllaridan foydalansangiz va ayni paytda barcha obyektlar tomonidan meros qilib olinadigan xossalarni taâ€™riflaydigan koddan ham foydalansangiz, siklingiz siz kutgan tarzda ishlamasligi mumkin. Shu sababli, koâ€˜plab dasturchilar `for/in` sikli oâ€˜rniga `Object.keys()` bilan birga `for/of` siklidan foydalanishni afzal koâ€˜radilar.

Agar `for/in` siklining tanasi hali sanab oâ€˜tilmagan xossani oâ€˜chirsa, bu xossa sanab oâ€˜tilmaydi. Agar sikl tanasi obyektda yangi xossalar taâ€™riflasa, bu xossalar sanab oâ€˜tilishi yoki oâ€˜tilmasligi mumkin. `for/in`'ning obyekt xossalarini qanday tartibda sanab oâ€˜tishi haqida koâ€˜proq maâ€™lumot olish uchun Â§6.6.1-boâ€˜limga qarang.