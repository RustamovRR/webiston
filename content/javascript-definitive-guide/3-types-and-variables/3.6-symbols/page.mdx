---
title: "Symbol'lar"
description: "Symbol: unikal xossa nomlari, `Symbol()` va global reestr `Symbol.for()`, `toString()`/`valueOf()`, va `Symbol.iterator` kabi til kengaytmalari."
keywords: JavaScript, Symbol'lar, symbols, noyob kalitlar, unique keys, Symbol.for, global reestr, global registry, toString, valueOf, Symbol.iterator, xossalar, properties, xossa nomlari, property names, ES6, unikal identifikatorlar, unique identifiers
author: Webiston.uz
---
# `Symbol`'lar

`Symbol`'lar ES6 versiyasida satr bo'lmagan xossa nomlari sifatida xizmat qilish uchun kiritilgan. `Symbol`'larni tushunish uchun, avvalo, JavaScript'ning fundamental `Object` tipi har bir xossasi nom va qiymatga ega bo'lgan, tartiblanmagan xossalar to'plami ekanligini bilishingiz kerak. Xossa nomlari odatda satrlar bo'ladi (va ES6'gacha faqat satrlar bo'lgan). Lekin ES6 va undan keyingi versiyalarda `Symbol`'lar ham shu vazifani bajara oladi:

```js
let strname = "string name";      // Xossa nomi sifatida ishlatiladigan satr
let symname = Symbol("propname"); // Xossa nomi sifatida ishlatiladigan Symbol
typeof strname                    // => "string": strname - bu satr
typeof symname                    // => "symbol": symname - bu symbol
let o = {};                       // Yangi obyekt yaratamiz
o[strname] = 1;                   // Satr nomli xossani aniqlaymiz
o[symname] = 2;                   // Symbol nomli xossani aniqlaymiz
o[strname]                        // => 1: satr nomli xossaga murojaat
o[symname]                        // => 2: symbol nomli xossaga murojaat
```

`Symbol` tipining literal sintaksisi mavjud emas. `Symbol` qiymatini olish uchun siz `Symbol()` funksiyasini chaqirasiz. Bu funksiya, hatto bir xil argument bilan chaqirilganda ham, hech qachon bir xil qiymatni ikki marta qaytarmaydi. Bu shuni anglatadiki, agar siz `Symbol()` funksiyasini chaqirib, biror `Symbol` qiymatini olsangiz, bu qiymatdan obyektga yangi xossa qo'shish uchun xavfsiz foydalanishingiz mumkin va shu nomdagi mavjud xossani bexosdan qayta yozib yuborishdan xavotir olmasangiz ham bo'ladi. Xuddi shunday, agar siz `Symbol`'li xossa nomlaridan foydalansangiz va bu `symbol`'larni boshqalar bilan bo'lishmasangiz, dasturingizdagi boshqa kod modullari sizning xossalaringizni tasodifan qayta yozib yubormasligiga amin bo'lishingiz mumkin.

Amalda, `Symbol`'lar tilni kengaytirish mexanizmi sifatida xizmat qiladi. ES6 `for/of` siklini (§5.4.4) va iteratsiya qilinadigan (iterable) obyektlarni (12-bob) kiritganida, klasslar o'zlarini iteratsiya qilinadigan qilish uchun implementatsiya qilishi mumkin bo'lgan standart bir metodni aniqlashi kerak edi. Lekin bu iterator metodi uchun biror aniq satr nomini standartlashtirish mavjud kodlarni ishdan chiqargan bo'lardi. Shuning uchun, uning o'rniga `Symbol`'li nom ishlatilgan. 12-bobda ko'rib chiqadiganimizdek, `Symbol.iterator` — bu obyektni iteratsiya qilinadigan qilish uchun metod nomi sifatida ishlatilishi mumkin bo'lgan `Symbol` qiymatidir.

`Symbol()` funksiyasi ixtiyoriy satr argumentini qabul qiladi va unikal `Symbol` qiymatini qaytaradi. Agar siz satr argumentini taqdim etsangiz, o'sha satr `Symbol`'ning `toString()` metodi chiqargan natijada aks etadi. Biroq shuni yodda tutingki, `Symbol()` funksiyasini bir xil satr bilan ikki marta chaqirish ikki butunlay farqli `Symbol` qiymatini hosil qiladi.

```js
let s = Symbol("sym_x");
s.toString()  // => "Symbol(sym_x)"
```

`toString()` metodi `Symbol` nusxalarining yagona qiziqarli metodidir. Shunday bo'lsa-da, siz bilishingiz kerak bo'lgan `Symbol`'ga aloqador yana ikkita funksiya mavjud. Ba’zan `Symbol`'lardan foydalanganda, siz ularni o'z kodingiz uchungina maxfiy saqlashni xohlaysiz. Bu sizning xossalaringiz boshqa kod ishlatadigan xossalar bilan hech qachon ziddiyatga kirmasligiga kafolat beradi. Boshqa hollarda esa, siz biror `Symbol` qiymatini aniqlab, uni boshqa kodlar bilan keng miqyosda bo'lishishni xohlashingiz mumkin. Bu, masalan, avvalroq tasvirlangan `Symbol.iterator` mexanizmi kabi, boshqa kodlar ham ishtirok eta olishini xohlagan biror turdagi kengaytmani aniqlayotganingizda yuz berishi mumkin.

Aynan shu ikkinchi holat uchun, JavaScript global `Symbol` reestrini (ro'yxatini) taqdim etadi. `Symbol.for()` funksiyasi satr argumentini qabul qiladi va siz uzatgan satr bilan bog'langan `Symbol` qiymatini qaytaradi. Agar bu satr bilan hali hech qanday `Symbol` bog'lanmagan bo'lsa, yangisi yaratiladi va qaytariladi; aks holda, allaqachon mavjud bo'lgan `Symbol` qaytariladi. Ya’ni, `Symbol.for()` funksiyasi `Symbol()` funksiyasidan butunlay farq qiladi: `Symbol()` hech qachon bir xil qiymatni ikki marta qaytarmaydi, lekin `Symbol.for()` bir xil satr bilan chaqirilganda har doim bir xil qiymatni qaytaradi. `Symbol.for()`'ga uzatilgan satr qaytarilgan `Symbol`'ning `toString()` metodi natijasida ko'rinadi va uni qaytarilgan `Symbol`'da `Symbol.keyFor()`'ni chaqirish orqali ham olish mumkin.

``` js
let s = Symbol.for("shared");
let t = Symbol.for("shared");
s === t          // => true
s.toString()     // => "Symbol(shared)"
Symbol.keyFor(t) // => "shared"
```