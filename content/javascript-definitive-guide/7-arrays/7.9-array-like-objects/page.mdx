---
title: Massiv'simon obyekt'lar
description: "JavaScriptda massivsimon obyektlar (array-like objects): length xossasiga ega bo'lgan, lekin to'liq massiv metodlariga ega bo'lmagan tuzilmalar. arguments obyektidan foydalanish, DOM kolleksiyalari va ularni haqiqiy massivga aylantirish usullari."
keywords: JavaScript, massiv, array, massivsimon obyekt, array-like objects, arguments, DOM collection, NodeList, HTMLCollection, length property, convert to array, Array.from, slice.call, beginner, advanced, tutorial
author: Webiston.uz
---

# Massivsimon obyektlar

Ko'rib o'tganimizdek, JavaScript massivlari boshqa obyektlarda mavjud bo'lmagan ba'zi o'ziga xos xususiyatlarga ega:

- Ro'yxatga yangi elementlar qo'shilishi bilan `length` xossasi avtomatik ravishda yangilanib boradi.
- `length`'ni kichikroq qiymatga o'rnatish massivni kesadi (`truncate`).
- Massivlar `Array.prototype`'dan foydali metodlarni meros qilib oladi.
- `Array.isArray()` massivlar uchun `true` qaytaradi.

Aynan shu xususiyatlar JavaScript massivlarini oddiy obyektlardan ajratib turadi. Lekin bular massivning mohiyatini belgilaydigan asosiy xususiyatlar emas. Sonli `length` xossasiga va unga mos keladigan manfiy bo'lmagan butun sonli xossalarga ega bo'lgan har qanday obyektga bir turdagi massiv sifatida qarash ko'pincha juda o'rinlidir.

Bu **"massivsimon" (`array-like`)** obyektlar aslida amalda vaqti-vaqti bilan uchrab turadi va garchi siz ularda massiv metodlarini to'g'ridan-to'g'ri chaqira olmasangiz yoki `length` xossasidan alohida xatti-harakat kutmasangiz ham, baribir ular bo'ylab xuddi haqiqiy massiv uchun ishlatadigan kodingiz yordamida iteratsiya qilishingiz mumkin. Ma'lum bo'lishicha, ko'plab massiv algoritmlari haqiqiy massivlarda qanday ishlasa, massivsimon obyektlarda ham xuddi shunday yaxshi ishlaydi. Bu, ayniqsa, agar algoritmlaringiz massivni faqat o'qish uchun mo'ljallangan deb hisoblasa yoki hech bo'lmaganda massiv uzunligini o'zgarishsiz qoldirsa, to'g'ri keladi.

Quyidagi kod parchasi oddiy obyektni qanday qilib "massivsimon" obyektga aylantirish va so'ngra hosil bo'lgan psevdo-massivning "elementlari" bo'ylab iteratsiya qilish mumkinligini namoyish etadi:

``` js
let a = {}; // Oddiy bo'sh obyektdan boshlaymiz

// Uni "massivsimon" qilish uchun xossalar qo'shamiz
let i = 0;
while(i < 10) {
    a[i] = i * i;
    i++;
}
a.length = i;

// Endi u bo'ylab xuddi haqiqiy massivdek iteratsiya qilamiz
let total = 0;
for(let j = 0; j < a.length; j++) {
    total += a[j];
}
```

Klient tomonidagi JavaScript'da HTML dokumentlari bilan ishlaydigan bir qator metodlar (masalan, `document.querySelectorAll()`) massivsimon obyektlarni qaytaradi. Quyida massiv kabi ishlaydigan obyektlarni tekshirish uchun foydalanish mumkin bo'lgan funksiya keltirilgan:

``` js
// `o`ning massivsimon obyekt ekanligini aniqlash.
// Satrlar va funksiyalar sonli `length` xossalariga ega, lekin
// `typeof` tekshiruvi bilan chiqarib yuboriladi. Klient tomonidagi JavaScript'da, DOM matn
// tugunlari (`nodes`) sonli `length` xossasiga ega va ularni qo'shimcha
// `o.nodeType !== 3` tekshiruvi bilan chiqarib yuborish kerak bo'lishi mumkin.
function isArrayLike(o) {
    if (o &&                               // `o` `null`, `undefined` va hokazo emas.
        typeof o === "object" &&           // `o` - bu obyekt.
        Number.isFinite(o.length) &&       // `o.length` - chekli son.
        o.length >= 0 &&                   // `o.length` manfiy emas.
        Number.isInteger(o.length) &&      // `o.length` - butun son.
        o.length < 4294967295) {           // `o.length` < 2^32 - 1
        return true;                       // Demak, `o` massivsimon.
    } else {
        return false;                      // Aks holda, unday emas.
    }
}
```

Keyingi bo'limda satrlar o'zini massivlardek tutishini ko'rib chiqamiz. Shunga qaramay, massivsimon obyektlar uchun bu kabi tekshiruvlar odatda satrlar uchun `false` qaytaradi — ular bilan massiv sifatida emas, balki satr sifatida ishlagan ma'qul.

Ko'plab JavaScript massiv metodlari ataylab **universal (`generic`)** qilib yaratilganki, ular nafaqat haqiqiy massivlarga, balki massivsimon obyektlarga qo'llanilganda ham to'g'ri ishlaydi. Massivsimon obyektlar `Array.prototype`'dan meros olmagani uchun, ularda massiv metodlarini to'g'ridan-to'g'ri chaqira olmaysiz. Biroq ularni `Function.call` metodi yordamida bilvosita chaqirish mumkin (§8.7.4-bo'limda batafsil yoritilgan):

``` js
let a = {"0": "a", "1": "b", "2": "c", length: 3};  // Massivsimon obyekt
Array.prototype.join.call(a, "+")                   // => "a+b+c"
Array.prototype.map.call(a, x => x.toUpperCase())   // => ["A","B","C"]
Array.prototype.slice.call(a, 0)       // => ["a","b","c"]: haqiqiy massiv nusxasi
Array.from(a)                          // => ["a","b","c"]: massivni nusxalashning osonroq yo'li
```

Ushbu kodning oxiridan bitta oldingi qatori massivsimon obyektning elementlarini haqiqiy massiv obyektiga ko'chirish uchun o'sha obyektda `Array.slice()` metodini chaqiradi. Bu ko'plab eski kodlarda mavjud bo'lgan idiomatik usuldir, lekin hozir buni `Array.from()` yordamida ancha osonroq bajarish mumkin.