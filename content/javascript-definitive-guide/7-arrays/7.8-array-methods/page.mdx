---
title: Massiv metodlari
description: "JavaScriptda massiv metodlari: push, pop, shift, unshift, splice, slice, concat, map, filter, reduce va boshqa qulay usullar. Elementlarni qo'shish, o'chirish, qidirish va o'zgartirish bo'yicha amaliy misollar."
keywords: JavaScript, massiv, array, metodlar, array methods, push, pop, shift, unshift, splice, slice, concat, map, filter, reduce, sort, find, foreach, beginner, advanced, tutorial, misollar
author: Webiston.uz
---

# Massiv metodlari

Oldingi bo'limlar massivlar bilan ishlashning sintaktik asoslariga bag'ishlangan edi. Aslida esa, `Array` klassi taqdim etadigan metodlar eng qudratli vositalar hisoblanadi. Keyingi bo'limlar aynan shu metodlarni batafsil yoritib beradi.

Bu metodlar bilan tanishar ekansiz, bir muhim jihatni yodda tuting: ularning ba'zilari o'zlari chaqirilgan massivning asl holatini o'zgartiradi, boshqalari esa uni o'zgarishsiz qoldiradi. Bir qator metodlar natija sifatida massiv qaytaradi: ba'zan bu butunlay yangi massiv bo'ladi va asl nusxaga tegilmaydi. Boshqa hollarda esa, metod massivning o'zini o'zgartiradi va ayni paytda o'sha o'zgartirilgan massivga havolani ham qaytaradi.

Keyingi har bir quyi bo'limda o'zaro bog'liq bo'lgan massiv metodlari guruhini ko'rib chiqiladi:

- **Iterator metodlari** massiv elementlari bo'ylab aylanib chiqadi va odatda siz ko'rsatgan funksiyani o'sha elementlarning har birida ishga tushiradi.
- **Stek va navbat metodlari** massiv elementlarini massivning boshi va oxiriga qo'shadi hamda undan olib tashlaydi.
- **Quyi massiv metodlari** kattaroq massivning uzluksiz qismlarini ajratib olish, o'chirish, qo'shish, to'ldirish va nusxalash uchun xizmat qiladi.
- **Qidirish va saralash metodlari** massiv ichidan elementlarni topish va massiv elementlarini tartibga solish uchun ishlatiladi.

Quyidagi quyi bo'limlar, shuningdek, `Array` klassining statik metodlarini va massivlarni birlashtirish hamda ularni satrlarga o'zgartirishga mo'ljallangan bir nechta qo'shimcha metodlarni ham qamrab oladi.

## Massiv iterator metodlari

Ushbu bo'limda tasvirlangan metodlar massiv elementlarini tartib bilan siz taqdim etgan funksiyaga uzatish orqali massivlar bo'ylab iteratsiya qiladi. Ular massivlarni iteratsiya qilish, moslashtirish (`map`), filtrlash, tekshirish va qisqartirish (`reduce`) uchun qulay usullarni taqdim etadi.

Biroq metodlarni batafsil tushuntirishdan oldin, ular haqida ba'zi umumiy xulosalar chiqarib olish joiz.

Birinchidan, bu metodlarning barchasi birinchi argument sifatida funksiya qabul qiladi va bu funksiyani massivning har bir elementi (yoki ba'zi elementlari) uchun bir martadan chaqiradi. Agar massiv siyrak bo'lsa, siz uzatgan funksiya mavjud bo'lmagan elementlar uchun chaqirilmaydi. Ko'p hollarda, siz taqdim etgan funksiya uchta argument bilan chaqiriladi: massiv elementining qiymati, massiv elementining indeksi va massivning o'zi. Ko'pincha sizga faqat bu argument qiymatlaridan birinchisi kerak bo'ladi va ikkinchi hamda uchinchi qiymatlarni e'tiborsiz qoldirishingiz mumkin.

Keyingi quyi bo'limlarda tasvirlangan iterator metodlarining aksariyati ixtiyoriy ikkinchi argumentni qabul qiladi. Agar bu argument ko'rsatilsa, funksiya xuddi shu ikkinchi argumentning metodi kabi chaqiriladi. Ya'ni, siz uzatgan ikkinchi argument birinchi argument sifatida uzatgan funksiyangiz ichidagi `this` kalit so'zining qiymatiga aylanadi.

Siz uzatgan funksiyaning qaytargan qiymati odatda muhim, lekin turli metodlar bu qaytarilgan qiymatni turlicha qayta ishlaydi. Bu yerda tasvirlangan metodlarning hech biri o'zlari chaqirilgan massivni o'zgartirmaydi (garchi, albatta, siz uzatgan funksiya massivni o'zgartirishi mumkin bo'lsa ham).

Bu funksiyalarning har biri birinchi argumenti sifatida funksiya bilan chaqiriladi va bu funksiyani boshqa joyda ta'riflangan mavjud funksiyadan foydalanish o'rniga, metod chaqiruvi ifodasining bir qismi sifatida **ichkarida (`inline`)** ta'riflash juda keng tarqalgan. Strelkali funksiya sintaksisi (§8.1.3-bo'limga qarang) bu metodlar bilan ayniqsa yaxshi ishlaydi va biz keyingi misollarda undan foydalanamiz.

### `forEach()`

`forEach()` metodi massiv bo'ylab iteratsiya qilib, har bir element uchun siz ko'rsatgan funksiyani ishga tushiradi. Bu metodning ishlash prinsipi oddiy: siz unga birinchi argument sifatida biror funksiyani uzatasiz, `forEach()` esa o'z navbatida bu funksiyani uchta argument bilan chaqiradi: massiv elementining qiymati, uning indeksi va massivning o'zi. Agar sizga faqat elementning qiymati kerak bo'lsa, faqat bitta parametrli funksiya yozishingiz kifoya — qolgan argumentlar shunchaki e'tiborsiz qoldiriladi:

``` js
let data = [1,2,3,4,5], sum = 0;
// Massiv elementlarining yig'indisini hisoblash
data.forEach(value => { sum += value; }); // sum == 15

// Endi har bir massiv elementini bittaga oshiramiz
data.forEach(function(v, i, a) { a[i] = v + 1; }); // data == [2,3,4,5,6]
```

Shuni yodda tutingki, `forEach()` barcha elementlar qayta ishlanib bo'lmasdan oldin iteratsiyani to'xtatish imkoniyatini bermaydi. Ya'ni, oddiy `for` siklidagi kabi `break` ko'rsatmasining bu yerda muqobili yo'q.

### `map()`

`map()` metodi o'zi chaqirilgan massivning har bir elementini siz ko'rsatgan funksiyaga uzatadi va funksiyangiz qaytargan qiymatlardan iborat yangi massivni qaytaradi. Masalan:

``` js
let a = [1, 2, 3];
a.map(x => x*x) // => [1, 4, 9]: funksiya `x` ni qabul qilib, `x*x` ni qaytaradi
```

`map()`'ga uzatiladigan funksiya xuddi `forEach()`'ga uzatiladigan funksiya kabi chaqiriladi. Biroq `map()` metodi uchun siz uzatgan funksiya biror qiymat qaytarishi kerak.

E'tibor bering, `map()` **yangi massiv** qaytaradi: u o'zi chaqirilgan massivni o'zgartirmaydi. Agar asl massiv siyrak bo'lsa, sizning funksiyangiz mavjud bo'lmagan elementlar uchun chaqirilmaydi, lekin qaytarilgan massiv ham xuddi asl massiv kabi siyrak bo'ladi: u bir xil uzunlikka va bir xil mavjud bo'lmagan elementlarga ega bo'ladi.

### `filter()`

`filter()` metodi o'zi chaqirilgan massiv elementlarining bir qismidan iborat bo'lgan yangi massivni qaytaradi. Siz unga uzatadigan funksiya **predikat** bo'lishi kerak: ya'ni, `true` yoki `false` qaytaradigan funksiya. Predikat xuddi `forEach()` va `map()`'dagidek chaqiriladi. Agar qaytarilgan qiymat `true` yoki `true`'ga o'giriladigan qiymat bo'lsa, u holda predikatga uzatilgan element to'plamning bir a'zosi hisoblanadi va qaytariladigan massivga qo'shiladi. Misollar:

``` js
let a = [5, 4, 3, 2, 1];
a.filter(x => x < 3)            // => [2, 1]; 3 dan kichik qiymatlar
a.filter((x,i) => i%2 === 0)    // => [5, 3, 1]; har ikkinchi qiymat
```

E'tibor bering, `filter()` siyrak massivlardagi mavjud bo'lmagan elementlarni o'tkazib yuboradi va uning qaytargan qiymati **har doim zich** bo'ladi. Siyrak massivdagi bo'shliqlarni yo'qotish uchun shunday qilish mumkin:

``` js
let dense = sparse.filter(() => true);
```

Bo'shliqlarni yo'qotish va ayni paytda `undefined` hamda `null` elementlarini olib tashlash uchun esa `filter()`'dan quyidagicha foydalanish mumkin:

``` js
a = a.filter(x => x !== undefined && x !== null);
```

### `find()` va `findIndex()`

`find()` va `findIndex()` metodlari `filter()`'ga o'xshaydi — ular ham predikat funksiyangiz _truthy_ qiymat qaytaradigan elementlarni izlab, massivingiz bo'ylab iteratsiya qiladi. Biroq `filter()`'dan farqli o'laroq, bu ikki metod predikat biror elementni **birinchi marta topishi bilanoq** iteratsiyani to'xtatadi. Shu onda, `find()` mos kelgan elementni, `findIndex()` esa mos kelgan elementning indeksini qaytaradi. Agar mos keladigan element topilmasa, `find()` `undefined` qaytaradi, `findIndex()` esa `-1` qaytaradi:

``` js
let a = [1,2,3,4,5];
a.findIndex(x => x === 3) // => 2; `3` qiymati 2-indeksda joylashgan
a.findIndex(x => x < 0)   // => -1; massivda manfiy sonlar yo'q
a.find(x => x % 5 === 0)  // => 5: bu son 5 ga karrali
a.find(x => x % 7 === 0)  // => undefined: massivda 7 ga karrali sonlar yo'q
```

### `every()` va `some()`

`every()` va `some()` metodlari massiv predikatlaridir: ular siz ko'rsatgan predikat funksiyasini massiv elementlariga qo'llaydi, so'ngra `true` yoki `false` qaytaradi.

`every()` metodi matematikadagi "barcha uchun" kvantori (`∀`)'ga o'xshaydi: u faqat va faqat sizning predikat funksiyangiz massivdagi **barcha** elementlar uchun `true` qaytarsagina `true` qaytaradi:

``` js
let a = [1,2,3,4,5];
a.every(x => x < 10)       // => true: barcha qiymatlar 10 dan kichik.
a.every(x => x % 2 === 0)  // => false: barcha qiymatlar ham juft emas.
```

`some()` metodi esa matematikadagi "mavjudki" kvantori (`∃`)'ga o'xshaydi: u agar massivda predikat `true` qaytaradigan **hech bo'lmaganda bitta** element mavjud bo'lsa `true` qaytaradi va faqat va faqat predikat massivning barcha elementlari uchun `false` qaytarsagina `false` qaytaradi:

``` js
let a = [1,2,3,4,5];
a.some(x => x%2===0) // => true; `a`da ba'zi juft sonlar bor.
a.some(isNaN)        // => false; `a`da son bo'lmaganlar yo'q.
```

E'tibor bering, ham `every()`, ham `some()` qanday qiymat qaytarishini bilishi bilanoq massiv elementlarini iteratsiya qilishni to'xtatadi. `some()` sizning predikatingiz birinchi marta `true` qaytarganida `true` qaytaradi va faqat predikatingiz har doim `false` qaytarsagina butun massivni aylanib chiqadi. `every()` esa buning teskarisi: u predikatingiz birinchi marta `false` qaytarganida `false` qaytaradi va faqat predikatingiz har doim `true` qaytarsagina barcha elementlarni iteratsiya qiladi.

Shuni ham yodda tutingki, matematik kelishuvga binoan, bo'sh massivda chaqirilganda `every()` `true` qaytaradi, `some()` esa `false` qaytaradi.

### `reduce()` va `reduceRight()`

`reduce()` va `reduceRight()` metodlari massiv elementlarini siz ko'rsatgan funksiya yordamida birlashtirib, yagona bir qiymat hosil qiladi. Bu funksional dasturlashda keng tarqalgan amal bo'lib, "inject" va "fold" nomlari bilan ham ataladi. Misollar uning qanday ishlashini tushunishga yordam beradi:

``` js
let a = [1,2,3,4,5];
a.reduce((x,y) => x+y, 0)           // => 15; qiymatlar yig'indisi
a.reduce((x,y) => x*y, 1)           // => 120; qiymatlar ko'paytmasi
a.reduce((x,y) => (x > y) ? x : y)  // => 5; qiymatlarning eng kattasi
```

`reduce()` ikkita argument qabul qiladi. Birinchisi — bu **qisqartirish (`reduction`)** amalini bajaruvchi funksiya. Bu qisqartirish funksiyasining vazifasi — ikki qiymatni qandaydir usulda birlashtirish yoki bitta qiymatga qisqartirish va o'sha qisqartirilgan qiymatni qaytarishdir. Biz bu yerda ko'rsatgan misollarda funksiyalar ikki qiymatni qo'shish, ko'paytirish va eng kattasini tanlash orqali birlashtirmoqda. Ikkinchi (ixtiyoriy) argument esa funksiyaga uzatiladigan **boshlang'ich qiymatdir**.

`reduce()` bilan ishlatiladigan funksiyalar `forEach()` va `map()` bilan ishlatiladigan funksiyalardan farq qiladi. Bizga tanish bo'lgan qiymat (`value`), indeks (`index`) va massiv (`array`) qiymatlari ikkinchi, uchinchi va to'rtinchi argumentlar sifatida uzatiladi. Birinchi argument esa — bu hozirgacha bo'lgan qisqartirishning **to'plangan (`accumulated`) natijasidir**. Funksiyaning birinchi chaqiruvida bu birinchi argument siz `reduce()`'ga ikkinchi argument sifatida uzatgan boshlang'ich qiymat bo'ladi. Keyingi chaqiruvlarda esa, u funksiyaning oldingi chaqiruvi qaytargan qiymat bo'ladi.

Birinchi misolda qisqartirish funksiyasi avval `0` va `1` argumentlari bilan chaqiriladi. U bularni qo'shadi va `1` qaytaradi. So'ngra u yana `1` va `2` argumentlari bilan chaqiriladi va `3` qaytaradi. Keyin, u 3+3=6, so'ng 6+4=10 va nihoyat 10+5=15 ni hisoblaydi. Bu yakuniy qiymat, `15`, `reduce()`'ning qaytaradigan qiymatiga aylanadi.

Ehtimol, bu misoldagi uchinchi `reduce()` chaqiruvi faqat bitta argumentga ega ekanligiga e'tibor bergandirsiz: unda boshlang'ich qiymat ko'rsatilmagan. `reduce()`'ni bu tarzda, boshlang'ich qiymatsiz chaqirganingizda, u massivning birinchi elementini boshlang'ich qiymat sifatida ishlatadi. Bu shuni anglatadiki, qisqartirish funksiyasiga birinchi chaqiruvda uning birinchi va ikkinchi argumentlari sifatida massivning birinchi va ikkinchi elementlari keladi. Yig'indi va ko'paytma misollarida biz boshlang'ich qiymat argumentini tushirib qoldirishimiz mumkin edi.

Bo'sh massivda `reduce()`'ni boshlang'ich qiymat argumentsiz chaqirish `TypeError` xatoligiga sabab bo'ladi. Agar siz uni faqat bitta qiymat bilan — yo bitta elementli massiv va boshlang'ich qiymatsiz, yo bo'sh massiv va boshlang'ich qiymat bilan — chaqirsangiz, u qisqartirish funksiyasini umuman chaqirmasdan, shunchaki o'sha yagona qiymatni qaytaradi.

`reduceRight()` xuddi `reduce()` kabi ishlaydi, faqat u massivni eng pastdan eng yuqoriga qarab emas, balki eng yuqori indeksdan eng pastiga (o'ngdan chapga) qarab qayta ishlaydi. Buni, masalan, qisqartirish amali o'ngdan chapga assotsiativlikka ega bo'lganda ishlatishingiz mumkin:

``` js
// 2^(3^4) ni hisoblash. Darajaga ko'tarish o'ngdan chapga ustuvorlikka ega.
let a = [2, 3, 4];
a.reduceRight((acc,val) => Math.pow(val,acc)) // => 2.4178516392292583e+24
```

E'tibor bering, na `reduce()`, na `reduceRight()` qisqartirish funksiyasi chaqirilishi kerak bo'lgan `this` qiymatini belgilaydigan ixtiyoriy argumentni qabul qiladi. Uning o'rnini ixtiyoriy boshlang'ich qiymat argumenti egallaydi. Agar sizga qisqartirish funksiyangiz ma'lum bir obyektning metodi sifatida chaqirilishi kerak bo'lsa, `Function.bind()` metodiga (§8.7.5) qarang.

Hozirgacha ko'rsatilgan misollar sodda bo'lishi uchun sonli edi, lekin `reduce()` va `reduceRight()` faqat matematik hisob-kitoblar uchun mo'ljallanmagan. Ikki qiymatni (masalan, ikkita obyektni) bir xil tipdagi bitta qiymatga birlashtira oladigan har qanday funksiya qisqartirish funksiyasi sifatida ishlatilishi mumkin. Boshqa tomondan, massiv qisqartirishlari yordamida ifodalangan algoritmlar tezda murakkablashib, tushunish qiyin bo'lib qolishi mumkin va agarda siz massivlaringizni qayta ishlash uchun oddiy sikl tuzilmalaridan foydalansangiz, kodingizni o'qish, yozish va tahlil qilish osonroq ekanligini ko'rasiz.

## `flat()` va `flatMap()` bilan massivlarni yassilash

ES2019'da taqdim etilgan `flat()` metodi yangi massiv yaratadi va qaytaradi. Bu yangi massiv o'zi chaqirilgan massiv bilan bir xil elementlarni o'z ichiga oladi, faqat bir istisno bilan: agar elementlarning o'zi ham massiv bo'lsa, ular qaytarilgan massiv ichiga "yassilanadi". Masalan:

``` js
[1, [2, 3]].flat()      // => [1, 2, 3]
[1, [2, [3]]].flat()    // => [1, 2, [3]]
```

Hech qanday argumentsiz chaqirilganda, `flat()` bir darajadagi ichma-ichlikni yassilaydi. Asl massivning o'zlari massiv bo'lgan elementlari yassilanadi, lekin bu massivlarning ichidagi massiv elementlariga tegilmaydi. Agar siz chuqurroq darajalarni yassilamoqchi bo'lsangiz, `flat()`'ga kerakli chuqurlik darajasini son sifatida uzating:

``` js
let a = [1, [2, [3, [4]]]];
a.flat(1) // => [1, 2, [3, [4]]]
a.flat(2) // => [1, 2, 3, [4]]
a.flat(3) // => [1, 2, 3, 4]
a.flat(4) // => [1, 2, 3, 4]
```

`flatMap()` metodi xuddi `map()` metodi kabi ishlaydi, faqat unda qaytarilgan massiv xuddi `flat()`'ga uzatilgandek avtomatik ravishda yassilanadi. Ya'ni, `a.flatMap(f)`'ni chaqirish `a.map(f).flat()` bilan bir xil natija beradi (lekin undan samaraliroqdir):

``` js
let phrases = ["hello world", "the definitive guide"];
let words = phrases.flatMap(phrase => phrase.split(" "));
words // => ["hello", "world", "the", "definitive", "guide"];
```

Siz `flatMap()`'ni `map()`'ning umumlashtirilgan shakli deb tasavvur qilishingiz mumkin. U kiruvchi massivning har bir elementini chiquvchi massivning istalgancha (nol yoki undan ko'p) elementiga moslashtirish imkonini beradi. `flatMap()`'ning yana bir imkoniyati shundaki, u kiruvchi elementlarni bo'sh massivga moslashtirishga yo'l qo'yadi. Bo'sh massivlar esa yassilanish jarayonida shunchaki e'tiborsiz qoldiriladi va yakuniy massivda aks etmaydi:

``` js
// Manfiy bo'lmagan sonlarni ularning kvadrat ildizlariga moslashtirish
[-2, -1, 1, 2].flatMap(x => x < 0 ? [] : Math.sqrt(x)) // => [1, 1.414...]
```

## `concat()` bilan massivlarni qo'shish

`concat()` metodi yangi massiv yaratadi va qaytaradi. Bu yangi massiv `concat()` chaqirilgan asl massivning elementlari, undan keyin esa `concat()`'ga uzatilgan har bir argumentdan tashkil topadi. Agar bu argumentlardan birortasi massiv bo'lsa, u holda massivning o'zi emas, balki uning elementlari birlashtiriladi. Biroq shuni yodda tutingki, `concat()` massivlar ichidagi massivlarni rekursiv tarzda yassilamaydi. `concat()` o'zi chaqirilgan massivni o'zgartirmaydi:

``` js
let a = [1,2,3];
a.concat(4, 5)          // => [1,2,3,4,5]
a.concat([4,5],[6,7])   // => [1,2,3,4,5,6,7]; massivlar yassilanadi
a.concat(4, [5,[6,7]])  // => [1,2,3,4,5,[6,7]]; lekin ichma-ich massivlar emas
a                       // => [1,2,3]; asl massiv o'zgarishsiz qoladi
```

E'tibor bering, `concat()` o'zi chaqirilgan massivning yangi nusxasini yaratadi. Ko'p hollarda bu to'g'ri yondashuv, lekin bu ko'p ressurs talab qiladigan (`expensive`) amaldir. Agar kodingizda `a = a.concat(x)` kabi yozuvga duch kelsangiz, bu yangi massiv yaratish o'rniga, massivingizni `push()` yoki `splice()` yordamida joyida o'zgartirish haqida o'ylab ko'rishingiz kerakligidan darak beradi.

## `push()`, `pop()`, `shift()` va `unshift()` yordamida stek va navbatlar

`push()` va `pop()` metodlari massivlar bilan xuddi ular stekdek ishlash imkonini beradi. `push()` metodi massivning oxiriga bir yoki bir nechta yangi element qo'shadi va massivning yangi uzunligini qaytaradi. `concat()`'dan farqli o'laroq, `push()` o'ziga uzatilgan massiv argumentlarini yassilamaydi. `pop()` metodi esa buning teskarisini qiladi: u massivning oxirgi elementini o'chiradi, massiv uzunligini kamaytiradi va olib tashlangan qiymatni qaytaradi. E'tibor bering, har ikkala metod ham massivni **joyida o'zgartiradi**. `push()` va `pop()` birikmasi JavaScript massividan **birinchi kirgan, oxiri chiqadi (`first-in, last-out`)** stekini implementatsiya qilishga imkon beradi. Masalan:

``` js
let stack = [];     // stack == []
stack.push(1,2);    // stack == [1,2];
stack.pop();        // stack == [1]; 2 ni qaytaradi
stack.push(3);      // stack == [1,3]
stack.pop();        // stack == [1]; 3 ni qaytaradi
stack.push([4,5]);  // stack == [1,[4,5]]
stack.pop()         // stack == [1]; [4,5] ni qaytaradi
stack.pop();        // stack == []; 1 ni qaytaradi
```

`push()` metodi unga uzatilgan massivni yassilamaydi, lekin agar siz bir massivning barcha elementlarini boshqa massivga qo'shmoqchi bo'lsangiz, uni aniq yassilash uchun yoyish (`spread`) operatoridan (§8.3.4) foydalanishingiz mumkin:

``` js
a.push(...values);
```

`unshift()` va `shift()` metodlari xuddi `push()` va `pop()` kabi ishlaydi, faqat ular elementlarni massivning oxiridan emas, boshidan qo'shadi va olib tashlaydi. `unshift()` massivning boshiga bir yoki bir nechta element qo'shadi, joy ochish uchun mavjud massiv elementlarini yuqoriroq indekslarga siljitadi va massivning yangi uzunligini qaytaradi. `shift()` esa massivning birinchi elementini olib tashlaydi va qaytaradi, qolgan barcha elementlarni bir pog'ona pastga, massiv boshida yangi bo'shagan joyni egallash uchun siljitadi.

`unshift()` va `shift()` yordamida stekni implementatsiya qilish mumkin edi, lekin bu `push()` va `pop()`'dan foydalanishdan ko'ra samarasizroq bo'lardi, chunki massiv boshiga element qo'shilganda yoki olib tashlanganda har safar elementlarni yuqoriga yoki pastga siljitishga to'g'ri keladi. Buning o'rniga, `push()` yordamida elementlarni massiv oxiriga qo'shib, `shift()` yordamida ularni massiv boshidan olib tashlash orqali navbat (`queue`) ma'lumotlar tuzilmasini implementatsiya qilish mumkin:

``` js
let q = [];      // q == []
q.push(1,2);     // q == [1,2]
q.shift();       // q == [2]; 1 ni qaytaradi
q.push(3)        // q == [2, 3]
q.shift()        // q == [3]; 2 ni qaytaradi
q.shift()        // q == []; 3 ni qaytaradi
```

`unshift()`'ning bir xususiyati borki, uni alohida ta'kidlab o'tish joiz, chunki u sizni ajablantirishi mumkin. `unshift()`'ga bir nechta argument uzatganda, ular bir vaqtning o'zida qo'shiladi, bu esa ularning massivdagi yakuniy tartibi, agar ularni birma-bir qo'shgandagidan farqli bo'lishini anglatadi:

``` js
let a = [];     // a == []
a.unshift(1)    // a == [1]
a.unshift(2)    // a == [2, 1]
a = [];         // a == []
a.unshift(1,2)  // a == [1, 2]
```

## `slice()`, `splice()`, `fill()` va `copyWithin()` bilan quyi massivlar

Massivlar o'zida uzluksiz hududlar, ya'ni massivning quyi massivlari yoki "kesimlari" (`slices`) bilan ishlaydigan bir qator metodlarni taqdim etadi. Keyingi bo'limlarda kesimlarni ajratib olish, almashtirish, to'ldirish va nusxalash uchun mo'ljallangan metodlar haqida yoritib beriladi.

### `slice()`

`slice()` metodi belgilangan massivning bir **kesim (`slice`)**'ini yoki quyi massivini qaytaradi. Uning ikki argumenti qaytarilishi kerak bo'lgan kesimning boshlanishi va oxirini belgilaydi. Qaytarilgan massiv birinchi argument bilan belgilangan elementni va undan keyingi barcha elementlarni, ikkinchi argument bilan belgilangan elementgacha bo'lgan qismini (lekin bu elementning o'zini kiritmagan holda) o'z ichiga oladi.

Agar faqat bitta argument ko'rsatilsa, qaytarilgan massiv boshlang'ich pozitsiyadan massivning oxirigacha bo'lgan barcha elementlarni o'z ichiga oladi. Agar argumentlardan birortasi manfiy bo'lsa, u massiv elementini massiv uzunligiga nisbatan belgilaydi. Masalan, `–1` argumenti massivdagi oxirgi elementni, `–2` argumenti esa undan oldingi elementni bildiradi.

E'tibor bering, `slice()` o'zi chaqirilgan massivni **o'zgartirmaydi**. Quyida bir nechta misollar keltirilgan:

``` js
let a = [1,2,3,4,5];
a.slice(0,3);   // [1,2,3] ni qaytaradi
a.slice(3);     // [4,5] ni qaytaradi
a.slice(1,-1);  // [2,3,4] ni qaytaradi
a.slice(-3,-2); // [3] ni qaytaradi
```

### `splice()`

`splice()` — bu massivdan elementlarni qo'shish yoki olib tashlash uchun mo'ljallangan universal metoddir. `slice()` va `concat()`'dan farqli o'laroq, `splice()` o'zi chaqirilgan massivni **joyida o'zgartiradi**. E'tibor bering, `splice()` va `slice()` juda o'xshash nomlarga ega, lekin ular tubdan farq qiluvchi amallarni bajaradi.

`splice()` massivdan elementlarni o'chirishi, massivga yangi elementlar qo'shishi yoki har ikki amalni bir vaqtning o'zida bajarishi mumkin. Qo'shish yoki o'chirish nuqtasidan keyin keladigan massiv elementlarining indekslari massivning qolgan qismi bilan uzluksiz qolishi uchun kerak bo'lganda oshiriladi yoki kamaytiriladi.

`splice()`'ning birinchi argumenti qo'shish va/yoki o'chirish boshlanishi kerak bo'lgan massiv pozitsiyasini ko'rsatadi. Ikkinchi argument esa massivdan o'chirilishi kerak bo'lgan ("kesib olinishi" kerak bo'lgan) elementlar sonini belgilaydi. (E'tibor bering, bu ikki metod o'rtasidagi yana bir farqdir. `slice()`'ning ikkinchi argumenti — bu tugash pozitsiyasi. `splice()`'ning ikkinchi argumenti esa — uzunlikdir.) Agar bu ikkinchi argument tushirib qoldirilsa, boshlang'ich elementdan massivning oxirigacha bo'lgan barcha massiv elementlari olib tashlanadi. `splice()` o'chirilgan elementlar massivini, agar hech qanday element o'chirilmagan bo'lsa, bo'sh massivni qaytaradi. Masalan:

``` js
let a = [1,2,3,4,5,6,7,8];
a.splice(4)    // => [5,6,7,8]; `a` endi `[1,2,3,4]`
a.splice(1,2)  // => [2,3]; `a` endi `[1,4]`
a.splice(1,1)  // => [4]; `a` endi `[1]`
```

`splice()`'ning dastlabki ikki argumenti qaysi massiv elementlari o'chirilishini belgilaydi. Bu argumentlardan keyin massivga, birinchi argument bilan ko'rsatilgan pozitsiyadan boshlab, qo'shilishi kerak bo'lgan elementlarni belgilovchi istalgancha qo'shimcha argumentlar kelishi mumkin. Masalan:

``` js
let a = [1,2,3,4,5];
a.splice(2,0,"a","b")   // => []; `a` endi `[1,2,"a","b",3,4,5]`
a.splice(2,2,[1,2],3)   // => ["a","b"]; `a` endi `[1,2,[1,2],3,3,4,5]`
```

E'tibor bering, `concat()`'dan farqli o'laroq, `splice()` massivlarning elementlarini emas, balki massivlarning o'zini qo'shadi.

### `fill()`

`fill()` metodi massivning elementlarini yoki massivning bir kesimini belgilangan qiymatga o'rnatadi. U o'zi chaqirilgan massivni mutatsiya qiladi va ayni paytda o'zgartirilgan massivni ham qaytaradi:

``` js
let a = new Array(5);   // Elementlari yo'q va uzunligi 5 bo'lgan massivdan boshlaymiz
a.fill(0)               // => [0,0,0,0,0]; massivni nollar bilan to'ldirish
a.fill(9, 1)            // => [0,9,9,9,9]; 1-indeksdan boshlab 9 bilan to'ldirish
a.fill(8, 2, -1)        // => [0,9,8,8,9]; 2 va 3-indekslarni 8 bilan to'ldirish
```

`fill()`'ning birinchi argumenti — bu massiv elementlarini o'rnatish kerak bo'lgan qiymat. Ixtiyoriy ikkinchi argument boshlang'ich indeksni belgilaydi. Agar tushirib qoldirilsa, to'ldirish 0-indeksdan boshlanadi. Ixtiyoriy uchinchi argument esa tugash indeksini belgilaydi — massiv elementlari shu indeksgacha (lekin uni o'z ichiga olmagan holda) to'ldiriladi. Agar bu argument tushirib qoldirilsa, massiv boshlang'ich indeksdan oxirigacha to'ldiriladi. Siz xuddi `slice()`'dagi kabi, manfiy sonlarni uzatish orqali massiv oxiriga nisbatan indekslarni belgilashingiz mumkin.

### `copyWithin()`

`copyWithin()` metodi massivning biror kesimini massiv ichidagi yangi pozitsiyaga ko'chiradi. U massivni **joyida o'zgartiradi** va o'zgartirilgan massivni qaytaradi, lekin massivning uzunligini o'zgartirmaydi.

Birinchi argument birinchi element ko'chirilishi kerak bo'lgan **maqsad (`destination`)** indeksni belgilaydi. Ikkinchi argument esa ko'chirilishi kerak bo'lgan birinchi elementning indeksini belgilaydi. Agar bu ikkinchi argument tushirib qoldirilsa, `0` ishlatiladi. Uchinchi argument ko'chirilishi kerak bo'lgan elementlar kesimining oxirini belgilaydi. Agar tushirib qoldirilsa, massivning uzunligi ishlatiladi. Boshlang'ich indeksdan boshlab tugash indeksigacha bo'lgan (lekin tugash indeksining o'zini kiritmagan holda) elementlar ko'chiriladi.

Siz xuddi `slice()`'dagi kabi, manfiy sonlarni uzatish orqali massiv oxiriga nisbatan indekslarni belgilashingiz mumkin:

``` js
let a = [1,2,3,4,5];
a.copyWithin(1)       // => [1,1,2,3,4]: massiv elementlarini bir pog'ona yuqoriga ko'chirish
a.copyWithin(2, 3, 5) // => [1,1,3,4,4]: oxirgi 2 ta elementni 2-indeksga ko'chirish
a.copyWithin(0, -2)   // => [4,4,3,4,4]: manfiy siljishlar ham ishlaydi
```

`copyWithin()` yuqori unumdorlikka ega bo'lgan va ayniqsa tiplashtirilgan massivlar (§11.2) bilan ishlashda foydali bo'lgan metod sifatida mo'ljallangan. Bu metod `C` standart kutubxonasidagi `memmove()` funksiyasidan andoza olgan. E'tibor bering, nusxalash manba va maqsad hududlari o'rtasida ustma-ust tushish bo'lsa ham to'g'ri ishlaydi.

## Massivlarni qidirish va saralash metodlari

Massivlar satrlarning xuddi shu nomdagi metodlariga o'xshash bo'lgan `indexOf()`, `lastIndexOf()` va `includes()` metodlarini implementatsiya qiladi. Shuningdek, massiv elementlarining tartibini o'zgartirish uchun `sort()` va `reverse()` metodlari ham mavjud. Bu metodlar keyingi quyi bo'limlarda yoritilgan.

### `indexOf()` va `lastIndexOf()`

`indexOf()` va `lastIndexOf()` massiv ichidan belgilangan qiymatga ega elementni qidiradi va topilgan birinchi shunday elementning indeksini qaytaradi. Agar hech narsa topilmasa, `-1` qaytaradi. `indexOf()` massivni boshidan oxirigacha, `lastIndexOf()` esa oxiridan boshigacha qidiradi:

``` js
let a = [0,1,2,1,0];
a.indexOf(1)      // => 1: `a[1]` 1 ga teng
a.lastIndexOf(1)  // => 3: `a[3]` 1 ga teng
a.indexOf(3)      // => -1: qiymati 3 bo'lgan element yo'q
```

`indexOf()` va `lastIndexOf()` o'z argumentini massiv elementlari bilan `===` operatorining ekvivalenti yordamida taqqoslaydi. Agar massivingiz primitiv qiymatlar o'rniga obyektlarni o'z ichiga olsa, bu metodlar ikki havola aynan bitta obyektga ishora qilishini tekshiradi. Agar siz obyektning ichidagi tarkibni tekshirmoqchi bo'lsangiz, buning o'rniga o'zingizning shaxsiy predikat funksiyangiz bilan `find()` metodini sinab ko'ring.

`indexOf()` va `lastIndexOf()` qidiruvni boshlash kerak bo'lgan massiv indeksini belgilaydigan ixtiyoriy ikkinchi argumentni qabul qiladi. Agar bu argument tushirib qoldirilsa, `indexOf()` boshidan, `lastIndexOf()` esa oxiridan boshlaydi. Ikkinchi argument uchun manfiy qiymatlarga ruxsat etiladi va ular xuddi `slice()` metodidagi kabi, massiv oxiriga nisbatan siljish sifatida qabul qilinadi: masalan, `–1` qiymati massivning oxirgi elementini bildiradi.

Quyidagi funksiya massivdan belgilangan qiymatni qidiradi va barcha mos keladigan indekslar massivini qaytaradi. Bu `indexOf()`'ning ikkinchi argumentidan birinchisidan keyingi mosliklarni topish uchun qanday foydalanish mumkinligini namoyish etadi.

``` js
// `a` massividagi `x` qiymatining barcha uchragan holatlarini topish
// va mos keladigan indekslar massivini qaytarish
function findall(a, x) {
    let results = [],            // Biz qaytaradigan indekslar massivi
        len = a.length,          // Qidiriladigan massivning uzunligi
        pos = 0;                 // Qidiruvni boshlash pozitsiyasi

    while(pos < len) {           // Qidirish uchun yana elementlar bor ekan...
        pos = a.indexOf(x, pos); // Qidiramiz
        if (pos === -1) break;   // Agar hech narsa topilmasa, tamom.
        results.push(pos);       // Aks holda, indeksni massivda saqlaymiz
        pos = pos + 1;           // Va keyingi qidiruvni keyingi elementdan boshlaymiz
    }
    return results;              // Indekslar massivini qaytaramiz
}
```

E'tibor bering, satrlarning ham xuddi shu massiv metodlari kabi ishlaydigan `indexOf()` va `lastIndexOf()` metodlari mavjud, faqat ularda manfiy ikkinchi argument nol sifatida qabul qilinadi.

### `includes()`

ES2016'da kiritilgan `includes()` metodi yagona argument qabul qiladi va agar massiv o'sha qiymatni o'z ichiga olsa `true`, aks holda `false` qaytaradi. U sizga qiymatning indeksini aytmaydi, faqat uning mavjud yoki yo'qligini bildiradi. `includes()` metodi amalda massivlar uchun to'plamga a'zolikni tekshirish vazifasini bajaradi. Biroq shuni yodda tutingki, massivlar to'plamlarni ifodalash uchun samarali vosita emas va agar siz bir nechta elementdan ko'proq ma'lumot bilan ishlayotgan bo'lsangiz, haqiqiy `Set` obyektidan (§11.1.1) foydalanganingiz ma'qul.

`includes()` metodi `indexOf()` metodidan bitta muhim jihati bilan biroz farq qiladi. `indexOf()` tenglikni `===` operatori ishlatadigan algoritm bilan tekshiradi va bu tenglik algoritmi "son emas" (`NaN`) qiymatini boshqa har qanday qiymatdan, jumladan, o'zidan ham farqli deb hisoblaydi. `includes()` esa `NaN`'ni o'ziga teng deb hisoblaydigan biroz boshqacharoq tenglik versiyasidan foydalanadi. Bu shuni anglatadiki, `indexOf()` massivdagi `NaN` qiymatini aniqlay olmaydi, lekin `includes()` buni uddalaydi:

``` js
let a = [1,true,3,NaN];
a.includes(true) // => true
a.includes(2)    // => false
a.includes(NaN)  // => true
a.indexOf(NaN)   // => -1; `indexOf` `NaN`ni topa olmaydi
```

### `sort()`

`sort()` massiv elementlarini **joyida saralaydi** va saralangan massivni qaytaradi. `sort()` hech qanday argumentsiz chaqirilganda, u massiv elementlarini alifbo tartibida saralaydi (agar kerak bo'lsa, taqqoslashni amalga oshirish uchun ularni vaqtincha satrlarga o'zgartiradi):

``` js
let a = ["banana", "cherry", "apple"];
a.sort(); // a == ["apple", "banana", "cherry"]
```

Agar massiv ichida `undefined` elementlari bo'lsa, ular massivning oxiriga saralanadi.

Massivni alifbo tartibidan boshqacha tartibda saralash uchun siz `sort()`'ga argument sifatida **taqqoslash funksiyasi** uzatishingiz kerak. Bu funksiya o'zining ikki argumentidan qaysi biri saralangan massivda birinchi kelishi kerakligini hal qiladi.

- Agar birinchi argument ikkinchisidan **oldin** kelishi kerak bo'lsa, taqqoslash funksiyasi noldan kichik son qaytarishi kerak.
- Agar birinchi argument ikkinchisidan **keyin** kelishi kerak bo'lsa, funksiya noldan katta son qaytarishi kerak.
- Agar ikki qiymat ekvivalent bo'lsa (ya'ni, ularning tartibi ahamiyatsiz bo'lsa), taqqoslash funksiyasi `0` qaytarishi kerak.

Shunday qilib, masalan, massiv elementlarini alifbo tartibida emas, balki sonli tartibda saralash uchun quyidagicha yo'l tutishingiz mumkin:

``` js
let a = [33, 4, 1111, 222];
a.sort();                  // a == [1111, 222, 33, 4]; alifbo tartibi
a.sort(function(a,b) {     // Taqqoslagich (comparator) funksiyasini uzatamiz
    return a-b;            // Tartibga qarab `< 0`, `0`, yoki `> 0` qaytaradi
});                        // a == [4, 33, 222, 1111]; sonli tartib
a.sort((a,b) => b-a);      // a == [1111, 222, 33, 4]; teskari sonli tartib
```

Massiv elementlarini saralashning yana bir misoli sifatida, satrlar massivida katta-kichik harflarga sezgir bo'lmagan alifbo tartibida saralashni amalga oshirish mumkin. Buning uchun ikkala argumentni ham taqqoslashdan oldin `toLowerCase()` metodi yordamida kichik harflarga o'tkazadigan taqqoslash funksiyasini uzatish kerak:

``` js
let a = ["ant", "Bug", "cat", "Dog"];
a.sort();   // a == ["Bug","Dog","ant","cat"]; katta-kichik harfga sezgir saralash
a.sort(function(s,t) {
    let a = s.toLowerCase();
    let b = t.toLowerCase();
    if (a < b) return -1;
    if (a > b) return 1;
    return 0;
});         // a == ["ant","Bug","cat","Dog"]; katta-kichik harfga sezgir bo'lmagan saralash
```

### `reverse()`

`reverse()` metodi massiv elementlarining tartibini teskarisiga o'giradi va teskari qilingan massivni qaytaradi. U bu ishni **joyida** bajaradi; boshqacha aytganda, u elementlari qayta tartiblangan yangi massiv yaratmaydi, balki ularni allaqachon mavjud bo'lgan massivning o'zida qayta tartiblaydi:

``` js
let a = [1,2,3];
a.reverse(); // a == [3,2,1]
```

## Massivlarni satrlarga o'zgartirish

`Array` klassi massivlarni satrlarga o'zgartirishi mumkin bo'lgan uchta metodni taqdim etadi. Bu odatda log va xatolik xabarlarini yaratishda kerak bo'ladigan amaldir. (Agar siz massiv tarkibini keyinchalik qayta ishlatish uchun matnli shaklda saqlamoqchi bo'lsangiz, bu yerda tasvirlangan metodlar o'rniga massivni `JSON.stringify()` (§6.8) yordamida seriyalashtiring.)

`join()` metodi massivning barcha elementlarini satrlarga o'zgartiradi va ularni birlashtirib, yakuniy satrni qaytaradi. Siz yakuniy satrda elementlarni ajratib turadigan ixtiyoriy satrni ko'rsatishingiz mumkin. Agar ajratuvchi satr ko'rsatilmasa, vergul ishlatiladi:

``` js
let a = [1, 2, 3];
a.join();               // => "1,2,3"
a.join(" ");            // => "1 2 3"
a.join("");             // => "123"
let b = new Array(10);  // Elementlari yo'q, uzunligi 10 bo'lgan massiv
b.join("-")             // => "---------": 9 ta chiziqchadan iborat satr
```

`join()` metodi `String.split()` metodining teskarisidir. `split()` metodi satrni qismlarga bo'lish orqali massiv yaratadi.

Barcha JavaScript obyektlari singari, massivlar ham `toString()` metodiga ega. Massiv uchun bu metod xuddi hech qanday argumentsiz chaqirilgan `join()` metodi kabi ishlaydi:

``` js
.toString()                 // => "1,2,3"
["a", "b", "c"].toString()  // => "a,b,c"
[1, [2,"c"]].toString()     // => "1,2,c"
```

E'tibor bering, natija massiv qiymati atrofida kvadrat qavslar yoki boshqa biror turdagi chegaralovchini o'z ichiga olmaydi.

`toLocaleString()` — bu `toString()`'ning mahalliylashtirilgan versiyasidir. U har bir massiv elementini o'sha elementning `toLocaleString()` metodini chaqirish orqali satrga o'zgartiradi va so'ngra hosil bo'lgan satrlarni hududga xos (va implementatsiya tomonidan belgilanadigan) ajratuvchi satr yordamida birlashtiradi.

## Statik massiv funksiyalari

Biz allaqachon yuqorida keltirib o'tgan massiv metodlariga qo'shimcha ravishda, `Array` klassi massivlarda emas, balki `Array` konstruktorining o'zi orqali chaqiriladigan uchta statik funksiyani ham taqdim etadi.

`Array.of()` va `Array.from()` — bu yangi massivlar yaratish uchun mo'ljallangan fabrika metodlaridir. Ular §7.1.4 va §7.1.5-bo'limlarda yoritilgan edi.

Yana bir statik massiv funksiyasi — bu `Array.isArray()`'dir. U noma'lum bir qiymatning massiv yoki massiv emasligini aniqlash uchun juda foydalidir:

``` js
Array.isArray([]) // => true
Array.isArray({}) // => false
```